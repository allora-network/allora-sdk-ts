// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: cosmos/accounts/testing/counter/v1/counter.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../../../base/v1beta1/coin";

export const protobufPackage = "cosmos.accounts.testing.counter.v1";

/** MsgInit defines a message which initializes the counter with a given amount. */
export interface MsgInit {
  /** initial_value is the initial amount to set the counter to. */
  initialValue: string;
}

/** MsgInitResponse defines the MsgInit response type. */
export interface MsgInitResponse {
}

/** MsgIncreaseCounter defines a message which increases the counter by a given amount. */
export interface MsgIncreaseCounter {
  /** amount is the amount to increase the counter by. */
  amount: string;
}

/**
 * MsgIncreaseCounterResponse defines the MsgIncreaseCounter response type.
 * Returns the new counter value.
 */
export interface MsgIncreaseCounterResponse {
  /** new_amount defines the new counter value after the increase. */
  newAmount: string;
}

/** MsgTestDependencies is used to test the dependencies. */
export interface MsgTestDependencies {
}

/** MsgTestDependenciesResponse is used to test the dependencies. */
export interface MsgTestDependenciesResponse {
  /** chain_id is used to test that the header service correctly works. */
  chainId: string;
  /** address is used to test address codec. */
  address: string;
  /** before_gas is used to test the gas meter reporting. */
  beforeGas: string;
  /** after_gas is used to test gas meter increasing. */
  afterGas: string;
  /** funds reports the funds from the implementation.Funds method. */
  funds: Coin[];
}

/** QueryCounterRequest is used to query the counter value. */
export interface QueryCounterRequest {
}

/** QueryCounterResponse returns the counter value. */
export interface QueryCounterResponse {
  /** value defines the value of the counter. */
  value: string;
}

function createBaseMsgInit(): MsgInit {
  return { initialValue: "0" };
}

export const MsgInit: MessageFns<MsgInit> = {
  encode(message: MsgInit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialValue !== "0") {
      writer.uint32(8).uint64(message.initialValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.initialValue = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgInit {
    return { initialValue: isSet(object.initialValue) ? globalThis.String(object.initialValue) : "0" };
  },

  toJSON(message: MsgInit): unknown {
    const obj: any = {};
    if (message.initialValue !== "0") {
      obj.initialValue = message.initialValue;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgInit>): MsgInit {
    return MsgInit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgInit>): MsgInit {
    const message = createBaseMsgInit();
    message.initialValue = object.initialValue ?? "0";
    return message;
  },
};

function createBaseMsgInitResponse(): MsgInitResponse {
  return {};
}

export const MsgInitResponse: MessageFns<MsgInitResponse> = {
  encode(_: MsgInitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgInitResponse {
    return {};
  },

  toJSON(_: MsgInitResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInitResponse>): MsgInitResponse {
    return MsgInitResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgInitResponse>): MsgInitResponse {
    const message = createBaseMsgInitResponse();
    return message;
  },
};

function createBaseMsgIncreaseCounter(): MsgIncreaseCounter {
  return { amount: "0" };
}

export const MsgIncreaseCounter: MessageFns<MsgIncreaseCounter> = {
  encode(message: MsgIncreaseCounter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "0") {
      writer.uint32(8).uint64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgIncreaseCounter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIncreaseCounter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.amount = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgIncreaseCounter {
    return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "0" };
  },

  toJSON(message: MsgIncreaseCounter): unknown {
    const obj: any = {};
    if (message.amount !== "0") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgIncreaseCounter>): MsgIncreaseCounter {
    return MsgIncreaseCounter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgIncreaseCounter>): MsgIncreaseCounter {
    const message = createBaseMsgIncreaseCounter();
    message.amount = object.amount ?? "0";
    return message;
  },
};

function createBaseMsgIncreaseCounterResponse(): MsgIncreaseCounterResponse {
  return { newAmount: "0" };
}

export const MsgIncreaseCounterResponse: MessageFns<MsgIncreaseCounterResponse> = {
  encode(message: MsgIncreaseCounterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newAmount !== "0") {
      writer.uint32(8).uint64(message.newAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgIncreaseCounterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIncreaseCounterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.newAmount = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgIncreaseCounterResponse {
    return { newAmount: isSet(object.newAmount) ? globalThis.String(object.newAmount) : "0" };
  },

  toJSON(message: MsgIncreaseCounterResponse): unknown {
    const obj: any = {};
    if (message.newAmount !== "0") {
      obj.newAmount = message.newAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgIncreaseCounterResponse>): MsgIncreaseCounterResponse {
    return MsgIncreaseCounterResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgIncreaseCounterResponse>): MsgIncreaseCounterResponse {
    const message = createBaseMsgIncreaseCounterResponse();
    message.newAmount = object.newAmount ?? "0";
    return message;
  },
};

function createBaseMsgTestDependencies(): MsgTestDependencies {
  return {};
}

export const MsgTestDependencies: MessageFns<MsgTestDependencies> = {
  encode(_: MsgTestDependencies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTestDependencies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTestDependencies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTestDependencies {
    return {};
  },

  toJSON(_: MsgTestDependencies): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgTestDependencies>): MsgTestDependencies {
    return MsgTestDependencies.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgTestDependencies>): MsgTestDependencies {
    const message = createBaseMsgTestDependencies();
    return message;
  },
};

function createBaseMsgTestDependenciesResponse(): MsgTestDependenciesResponse {
  return { chainId: "", address: "", beforeGas: "0", afterGas: "0", funds: [] };
}

export const MsgTestDependenciesResponse: MessageFns<MsgTestDependenciesResponse> = {
  encode(message: MsgTestDependenciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.beforeGas !== "0") {
      writer.uint32(24).uint64(message.beforeGas);
    }
    if (message.afterGas !== "0") {
      writer.uint32(32).uint64(message.afterGas);
    }
    for (const v of message.funds) {
      Coin.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTestDependenciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTestDependenciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.beforeGas = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.afterGas = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.funds.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTestDependenciesResponse {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      beforeGas: isSet(object.beforeGas) ? globalThis.String(object.beforeGas) : "0",
      afterGas: isSet(object.afterGas) ? globalThis.String(object.afterGas) : "0",
      funds: globalThis.Array.isArray(object?.funds) ? object.funds.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgTestDependenciesResponse): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.beforeGas !== "0") {
      obj.beforeGas = message.beforeGas;
    }
    if (message.afterGas !== "0") {
      obj.afterGas = message.afterGas;
    }
    if (message.funds?.length) {
      obj.funds = message.funds.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MsgTestDependenciesResponse>): MsgTestDependenciesResponse {
    return MsgTestDependenciesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgTestDependenciesResponse>): MsgTestDependenciesResponse {
    const message = createBaseMsgTestDependenciesResponse();
    message.chainId = object.chainId ?? "";
    message.address = object.address ?? "";
    message.beforeGas = object.beforeGas ?? "0";
    message.afterGas = object.afterGas ?? "0";
    message.funds = object.funds?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryCounterRequest(): QueryCounterRequest {
  return {};
}

export const QueryCounterRequest: MessageFns<QueryCounterRequest> = {
  encode(_: QueryCounterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCounterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCounterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryCounterRequest {
    return {};
  },

  toJSON(_: QueryCounterRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryCounterRequest>): QueryCounterRequest {
    return QueryCounterRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueryCounterRequest>): QueryCounterRequest {
    const message = createBaseQueryCounterRequest();
    return message;
  },
};

function createBaseQueryCounterResponse(): QueryCounterResponse {
  return { value: "0" };
}

export const QueryCounterResponse: MessageFns<QueryCounterResponse> = {
  encode(message: QueryCounterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "0") {
      writer.uint32(8).uint64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCounterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCounterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCounterResponse {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "0" };
  },

  toJSON(message: QueryCounterResponse): unknown {
    const obj: any = {};
    if (message.value !== "0") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryCounterResponse>): QueryCounterResponse {
    return QueryCounterResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryCounterResponse>): QueryCounterResponse {
    const message = createBaseQueryCounterResponse();
    message.value = object.value ?? "0";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
