// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: emissions/v3/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ReputerValueBundle } from "./reputer";
import { WorkerDataBundle } from "./worker";

export const protobufPackage = "emissions.v3";

/**
 * Because gocosmos, grpc-gateway, and go-pulsar do not support optional fields
 * and including google themselves
 * https://cloud.google.com/apis/design/design_patterns.md#optional_primitive_fields
 * we instead use a repeated field with a single element to represent an
 * optional field and if the repeated field is empty, it is considered to be the
 * same as if the field was not set
 */
export interface OptionalParams {
  version: string[];
  maxSerializedMsgLength: string[];
  minTopicWeight: string[];
  requiredMinimumStake: string[];
  removeStakeDelayWindow: string[];
  minEpochLength: string[];
  betaEntropy: string[];
  learningRate: string[];
  maxGradientThreshold: string[];
  minStakeFraction: string[];
  maxUnfulfilledWorkerRequests: string[];
  maxUnfulfilledReputerRequests: string[];
  topicRewardStakeImportance: string[];
  topicRewardFeeRevenueImportance: string[];
  topicRewardAlpha: string[];
  taskRewardAlpha: string[];
  validatorsVsAlloraPercentReward: string[];
  maxSamplesToScaleScores: string[];
  maxTopInferersToReward: string[];
  maxTopForecastersToReward: string[];
  maxTopReputersToReward: string[];
  createTopicFee: string[];
  gradientDescentMaxIters: string[];
  registrationFee: string[];
  defaultPageLimit: string[];
  maxPageLimit: string[];
  minEpochLengthRecordLimit: string[];
  blocksPerMonth: string[];
  pRewardInference: string[];
  pRewardForecast: string[];
  pRewardReputer: string[];
  cRewardInference: string[];
  cRewardForecast: string[];
  cNorm: string[];
  epsilonReputer: string[];
  halfMaxProcessStakeRemovalsEndBlock: string[];
  dataSendingFee: string[];
  epsilonSafeDiv: string[];
  maxElementsPerForecast: string[];
  maxActiveTopicsPerBlock: string[];
}

export interface MsgUpdateParams {
  sender: string;
  params?: OptionalParams | undefined;
}

export interface MsgUpdateParamsResponse {
}

export interface MsgCreateNewTopic {
  /** creator is the message sender. */
  creator: string;
  metadata: string;
  lossMethod: string;
  epochLength: string;
  groundTruthLag: string;
  pNorm: string;
  alphaRegret: string;
  allowNegative: boolean;
  epsilon: string;
  workerSubmissionWindow: string;
  meritSortitionAlpha: string;
  activeInfererQuantile: string;
  activeForecasterQuantile: string;
  activeReputerQuantile: string;
}

export interface MsgCreateNewTopicResponse {
  topicId: string;
}

export interface MsgInsertReputerPayload {
  sender: string;
  reputerValueBundle?: ReputerValueBundle | undefined;
}

export interface MsgInsertReputerPayloadResponse {
}

export interface MsgInsertWorkerPayload {
  sender: string;
  workerDataBundle?: WorkerDataBundle | undefined;
}

export interface MsgInsertWorkerPayloadResponse {
}

export interface MsgRegister {
  sender: string;
  topicId: string;
  owner: string;
  isReputer: boolean;
}

export interface MsgRegisterResponse {
  success: boolean;
  message: string;
}

export interface MsgRemoveRegistration {
  sender: string;
  topicId: string;
  isReputer: boolean;
}

export interface MsgRemoveRegistrationResponse {
  success: boolean;
  message: string;
}

export interface MsgAddStake {
  sender: string;
  topicId: string;
  amount: string;
}

export interface MsgAddStakeResponse {
}

export interface MsgRemoveStake {
  sender: string;
  topicId: string;
  amount: string;
}

export interface MsgRemoveStakeResponse {
}

export interface MsgCancelRemoveStake {
  sender: string;
  topicId: string;
}

export interface MsgCancelRemoveStakeResponse {
}

export interface MsgDelegateStake {
  sender: string;
  topicId: string;
  reputer: string;
  amount: string;
}

export interface MsgDelegateStakeResponse {
}

export interface MsgRemoveDelegateStake {
  sender: string;
  reputer: string;
  topicId: string;
  amount: string;
}

export interface MsgRemoveDelegateStakeResponse {
}

export interface MsgCancelRemoveDelegateStake {
  sender: string;
  topicId: string;
  delegator: string;
  reputer: string;
}

export interface MsgCancelRemoveDelegateStakeResponse {
}

/**
 * Inferences are requested by consumers who fund topics by sending ALLO to
 * ecosystem account via TopicFund messages
 */
export interface MsgFundTopic {
  sender: string;
  topicId: string;
  /** how many funds to send from alice with this Inference Request */
  amount: string;
}

export interface MsgFundTopicResponse {
}

export interface MsgAddToWhitelistAdmin {
  sender: string;
  address: string;
}

export interface MsgAddToWhitelistAdminResponse {
}

export interface MsgRemoveFromWhitelistAdmin {
  sender: string;
  address: string;
}

export interface MsgRemoveFromWhitelistAdminResponse {
}

export interface MsgRewardDelegateStakeResponse {
}

export interface MsgRewardDelegateStake {
  sender: string;
  topicId: string;
  reputer: string;
}

function createBaseOptionalParams(): OptionalParams {
  return {
    version: [],
    maxSerializedMsgLength: [],
    minTopicWeight: [],
    requiredMinimumStake: [],
    removeStakeDelayWindow: [],
    minEpochLength: [],
    betaEntropy: [],
    learningRate: [],
    maxGradientThreshold: [],
    minStakeFraction: [],
    maxUnfulfilledWorkerRequests: [],
    maxUnfulfilledReputerRequests: [],
    topicRewardStakeImportance: [],
    topicRewardFeeRevenueImportance: [],
    topicRewardAlpha: [],
    taskRewardAlpha: [],
    validatorsVsAlloraPercentReward: [],
    maxSamplesToScaleScores: [],
    maxTopInferersToReward: [],
    maxTopForecastersToReward: [],
    maxTopReputersToReward: [],
    createTopicFee: [],
    gradientDescentMaxIters: [],
    registrationFee: [],
    defaultPageLimit: [],
    maxPageLimit: [],
    minEpochLengthRecordLimit: [],
    blocksPerMonth: [],
    pRewardInference: [],
    pRewardForecast: [],
    pRewardReputer: [],
    cRewardInference: [],
    cRewardForecast: [],
    cNorm: [],
    epsilonReputer: [],
    halfMaxProcessStakeRemovalsEndBlock: [],
    dataSendingFee: [],
    epsilonSafeDiv: [],
    maxElementsPerForecast: [],
    maxActiveTopicsPerBlock: [],
  };
}

export const OptionalParams: MessageFns<OptionalParams> = {
  encode(message: OptionalParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.version) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.maxSerializedMsgLength) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.minTopicWeight) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.requiredMinimumStake) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.removeStakeDelayWindow) {
      writer.int64(v);
    }
    writer.join();
    writer.uint32(58).fork();
    for (const v of message.minEpochLength) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.betaEntropy) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.learningRate) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.maxGradientThreshold) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.minStakeFraction) {
      writer.uint32(90).string(v!);
    }
    writer.uint32(106).fork();
    for (const v of message.maxUnfulfilledWorkerRequests) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(114).fork();
    for (const v of message.maxUnfulfilledReputerRequests) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.topicRewardStakeImportance) {
      writer.uint32(122).string(v!);
    }
    for (const v of message.topicRewardFeeRevenueImportance) {
      writer.uint32(130).string(v!);
    }
    for (const v of message.topicRewardAlpha) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.taskRewardAlpha) {
      writer.uint32(146).string(v!);
    }
    for (const v of message.validatorsVsAlloraPercentReward) {
      writer.uint32(154).string(v!);
    }
    writer.uint32(162).fork();
    for (const v of message.maxSamplesToScaleScores) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(170).fork();
    for (const v of message.maxTopInferersToReward) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(178).fork();
    for (const v of message.maxTopForecastersToReward) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(186).fork();
    for (const v of message.maxTopReputersToReward) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.createTopicFee) {
      writer.uint32(194).string(v!);
    }
    writer.uint32(202).fork();
    for (const v of message.gradientDescentMaxIters) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.registrationFee) {
      writer.uint32(226).string(v!);
    }
    writer.uint32(234).fork();
    for (const v of message.defaultPageLimit) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(242).fork();
    for (const v of message.maxPageLimit) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(250).fork();
    for (const v of message.minEpochLengthRecordLimit) {
      writer.int64(v);
    }
    writer.join();
    writer.uint32(258).fork();
    for (const v of message.blocksPerMonth) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.pRewardInference) {
      writer.uint32(266).string(v!);
    }
    for (const v of message.pRewardForecast) {
      writer.uint32(274).string(v!);
    }
    for (const v of message.pRewardReputer) {
      writer.uint32(282).string(v!);
    }
    for (const v of message.cRewardInference) {
      writer.uint32(290).string(v!);
    }
    for (const v of message.cRewardForecast) {
      writer.uint32(298).string(v!);
    }
    for (const v of message.cNorm) {
      writer.uint32(306).string(v!);
    }
    for (const v of message.epsilonReputer) {
      writer.uint32(322).string(v!);
    }
    writer.uint32(338).fork();
    for (const v of message.halfMaxProcessStakeRemovalsEndBlock) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.dataSendingFee) {
      writer.uint32(346).string(v!);
    }
    for (const v of message.epsilonSafeDiv) {
      writer.uint32(354).string(v!);
    }
    writer.uint32(362).fork();
    for (const v of message.maxElementsPerForecast) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(370).fork();
    for (const v of message.maxActiveTopicsPerBlock) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionalParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionalParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version.push(reader.string());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.maxSerializedMsgLength.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxSerializedMsgLength.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minTopicWeight.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requiredMinimumStake.push(reader.string());
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.removeStakeDelayWindow.push(reader.int64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.removeStakeDelayWindow.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.minEpochLength.push(reader.int64().toString());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.minEpochLength.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.betaEntropy.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.learningRate.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.maxGradientThreshold.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.minStakeFraction.push(reader.string());
          continue;
        }
        case 13: {
          if (tag === 104) {
            message.maxUnfulfilledWorkerRequests.push(reader.uint64().toString());

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxUnfulfilledWorkerRequests.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 14: {
          if (tag === 112) {
            message.maxUnfulfilledReputerRequests.push(reader.uint64().toString());

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxUnfulfilledReputerRequests.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.topicRewardStakeImportance.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.topicRewardFeeRevenueImportance.push(reader.string());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.topicRewardAlpha.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.taskRewardAlpha.push(reader.string());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.validatorsVsAlloraPercentReward.push(reader.string());
          continue;
        }
        case 20: {
          if (tag === 160) {
            message.maxSamplesToScaleScores.push(reader.uint64().toString());

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxSamplesToScaleScores.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 21: {
          if (tag === 168) {
            message.maxTopInferersToReward.push(reader.uint64().toString());

            continue;
          }

          if (tag === 170) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxTopInferersToReward.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 22: {
          if (tag === 176) {
            message.maxTopForecastersToReward.push(reader.uint64().toString());

            continue;
          }

          if (tag === 178) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxTopForecastersToReward.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 23: {
          if (tag === 184) {
            message.maxTopReputersToReward.push(reader.uint64().toString());

            continue;
          }

          if (tag === 186) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxTopReputersToReward.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.createTopicFee.push(reader.string());
          continue;
        }
        case 25: {
          if (tag === 200) {
            message.gradientDescentMaxIters.push(reader.uint64().toString());

            continue;
          }

          if (tag === 202) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.gradientDescentMaxIters.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.registrationFee.push(reader.string());
          continue;
        }
        case 29: {
          if (tag === 232) {
            message.defaultPageLimit.push(reader.uint64().toString());

            continue;
          }

          if (tag === 234) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.defaultPageLimit.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 30: {
          if (tag === 240) {
            message.maxPageLimit.push(reader.uint64().toString());

            continue;
          }

          if (tag === 242) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxPageLimit.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 31: {
          if (tag === 248) {
            message.minEpochLengthRecordLimit.push(reader.int64().toString());

            continue;
          }

          if (tag === 250) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.minEpochLengthRecordLimit.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 32: {
          if (tag === 256) {
            message.blocksPerMonth.push(reader.uint64().toString());

            continue;
          }

          if (tag === 258) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.blocksPerMonth.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.pRewardInference.push(reader.string());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.pRewardForecast.push(reader.string());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.pRewardReputer.push(reader.string());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.cRewardInference.push(reader.string());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.cRewardForecast.push(reader.string());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.cNorm.push(reader.string());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.epsilonReputer.push(reader.string());
          continue;
        }
        case 42: {
          if (tag === 336) {
            message.halfMaxProcessStakeRemovalsEndBlock.push(reader.uint64().toString());

            continue;
          }

          if (tag === 338) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.halfMaxProcessStakeRemovalsEndBlock.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.dataSendingFee.push(reader.string());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.epsilonSafeDiv.push(reader.string());
          continue;
        }
        case 45: {
          if (tag === 360) {
            message.maxElementsPerForecast.push(reader.uint64().toString());

            continue;
          }

          if (tag === 362) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxElementsPerForecast.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 46: {
          if (tag === 368) {
            message.maxActiveTopicsPerBlock.push(reader.uint64().toString());

            continue;
          }

          if (tag === 370) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxActiveTopicsPerBlock.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionalParams {
    return {
      version: globalThis.Array.isArray(object?.version) ? object.version.map((e: any) => globalThis.String(e)) : [],
      maxSerializedMsgLength: globalThis.Array.isArray(object?.maxSerializedMsgLength)
        ? object.maxSerializedMsgLength.map((e: any) => globalThis.String(e))
        : [],
      minTopicWeight: globalThis.Array.isArray(object?.minTopicWeight)
        ? object.minTopicWeight.map((e: any) => globalThis.String(e))
        : [],
      requiredMinimumStake: globalThis.Array.isArray(object?.requiredMinimumStake)
        ? object.requiredMinimumStake.map((e: any) => globalThis.String(e))
        : [],
      removeStakeDelayWindow: globalThis.Array.isArray(object?.removeStakeDelayWindow)
        ? object.removeStakeDelayWindow.map((e: any) => globalThis.String(e))
        : [],
      minEpochLength: globalThis.Array.isArray(object?.minEpochLength)
        ? object.minEpochLength.map((e: any) => globalThis.String(e))
        : [],
      betaEntropy: globalThis.Array.isArray(object?.betaEntropy)
        ? object.betaEntropy.map((e: any) => globalThis.String(e))
        : [],
      learningRate: globalThis.Array.isArray(object?.learningRate)
        ? object.learningRate.map((e: any) => globalThis.String(e))
        : [],
      maxGradientThreshold: globalThis.Array.isArray(object?.maxGradientThreshold)
        ? object.maxGradientThreshold.map((e: any) => globalThis.String(e))
        : [],
      minStakeFraction: globalThis.Array.isArray(object?.minStakeFraction)
        ? object.minStakeFraction.map((e: any) => globalThis.String(e))
        : [],
      maxUnfulfilledWorkerRequests: globalThis.Array.isArray(object?.maxUnfulfilledWorkerRequests)
        ? object.maxUnfulfilledWorkerRequests.map((e: any) => globalThis.String(e))
        : [],
      maxUnfulfilledReputerRequests: globalThis.Array.isArray(object?.maxUnfulfilledReputerRequests)
        ? object.maxUnfulfilledReputerRequests.map((e: any) => globalThis.String(e))
        : [],
      topicRewardStakeImportance: globalThis.Array.isArray(object?.topicRewardStakeImportance)
        ? object.topicRewardStakeImportance.map((e: any) => globalThis.String(e))
        : [],
      topicRewardFeeRevenueImportance: globalThis.Array.isArray(object?.topicRewardFeeRevenueImportance)
        ? object.topicRewardFeeRevenueImportance.map((e: any) => globalThis.String(e))
        : [],
      topicRewardAlpha: globalThis.Array.isArray(object?.topicRewardAlpha)
        ? object.topicRewardAlpha.map((e: any) => globalThis.String(e))
        : [],
      taskRewardAlpha: globalThis.Array.isArray(object?.taskRewardAlpha)
        ? object.taskRewardAlpha.map((e: any) => globalThis.String(e))
        : [],
      validatorsVsAlloraPercentReward: globalThis.Array.isArray(object?.validatorsVsAlloraPercentReward)
        ? object.validatorsVsAlloraPercentReward.map((e: any) => globalThis.String(e))
        : [],
      maxSamplesToScaleScores: globalThis.Array.isArray(object?.maxSamplesToScaleScores)
        ? object.maxSamplesToScaleScores.map((e: any) => globalThis.String(e))
        : [],
      maxTopInferersToReward: globalThis.Array.isArray(object?.maxTopInferersToReward)
        ? object.maxTopInferersToReward.map((e: any) => globalThis.String(e))
        : [],
      maxTopForecastersToReward: globalThis.Array.isArray(object?.maxTopForecastersToReward)
        ? object.maxTopForecastersToReward.map((e: any) => globalThis.String(e))
        : [],
      maxTopReputersToReward: globalThis.Array.isArray(object?.maxTopReputersToReward)
        ? object.maxTopReputersToReward.map((e: any) => globalThis.String(e))
        : [],
      createTopicFee: globalThis.Array.isArray(object?.createTopicFee)
        ? object.createTopicFee.map((e: any) => globalThis.String(e))
        : [],
      gradientDescentMaxIters: globalThis.Array.isArray(object?.gradientDescentMaxIters)
        ? object.gradientDescentMaxIters.map((e: any) => globalThis.String(e))
        : [],
      registrationFee: globalThis.Array.isArray(object?.registrationFee)
        ? object.registrationFee.map((e: any) => globalThis.String(e))
        : [],
      defaultPageLimit: globalThis.Array.isArray(object?.defaultPageLimit)
        ? object.defaultPageLimit.map((e: any) => globalThis.String(e))
        : [],
      maxPageLimit: globalThis.Array.isArray(object?.maxPageLimit)
        ? object.maxPageLimit.map((e: any) => globalThis.String(e))
        : [],
      minEpochLengthRecordLimit: globalThis.Array.isArray(object?.minEpochLengthRecordLimit)
        ? object.minEpochLengthRecordLimit.map((e: any) => globalThis.String(e))
        : [],
      blocksPerMonth: globalThis.Array.isArray(object?.blocksPerMonth)
        ? object.blocksPerMonth.map((e: any) => globalThis.String(e))
        : [],
      pRewardInference: globalThis.Array.isArray(object?.pRewardInference)
        ? object.pRewardInference.map((e: any) => globalThis.String(e))
        : [],
      pRewardForecast: globalThis.Array.isArray(object?.pRewardForecast)
        ? object.pRewardForecast.map((e: any) => globalThis.String(e))
        : [],
      pRewardReputer: globalThis.Array.isArray(object?.pRewardReputer)
        ? object.pRewardReputer.map((e: any) => globalThis.String(e))
        : [],
      cRewardInference: globalThis.Array.isArray(object?.cRewardInference)
        ? object.cRewardInference.map((e: any) => globalThis.String(e))
        : [],
      cRewardForecast: globalThis.Array.isArray(object?.cRewardForecast)
        ? object.cRewardForecast.map((e: any) => globalThis.String(e))
        : [],
      cNorm: globalThis.Array.isArray(object?.cNorm) ? object.cNorm.map((e: any) => globalThis.String(e)) : [],
      epsilonReputer: globalThis.Array.isArray(object?.epsilonReputer)
        ? object.epsilonReputer.map((e: any) => globalThis.String(e))
        : [],
      halfMaxProcessStakeRemovalsEndBlock: globalThis.Array.isArray(object?.halfMaxProcessStakeRemovalsEndBlock)
        ? object.halfMaxProcessStakeRemovalsEndBlock.map((e: any) => globalThis.String(e))
        : [],
      dataSendingFee: globalThis.Array.isArray(object?.dataSendingFee)
        ? object.dataSendingFee.map((e: any) => globalThis.String(e))
        : [],
      epsilonSafeDiv: globalThis.Array.isArray(object?.epsilonSafeDiv)
        ? object.epsilonSafeDiv.map((e: any) => globalThis.String(e))
        : [],
      maxElementsPerForecast: globalThis.Array.isArray(object?.maxElementsPerForecast)
        ? object.maxElementsPerForecast.map((e: any) => globalThis.String(e))
        : [],
      maxActiveTopicsPerBlock: globalThis.Array.isArray(object?.maxActiveTopicsPerBlock)
        ? object.maxActiveTopicsPerBlock.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OptionalParams): unknown {
    const obj: any = {};
    if (message.version?.length) {
      obj.version = message.version;
    }
    if (message.maxSerializedMsgLength?.length) {
      obj.maxSerializedMsgLength = message.maxSerializedMsgLength;
    }
    if (message.minTopicWeight?.length) {
      obj.minTopicWeight = message.minTopicWeight;
    }
    if (message.requiredMinimumStake?.length) {
      obj.requiredMinimumStake = message.requiredMinimumStake;
    }
    if (message.removeStakeDelayWindow?.length) {
      obj.removeStakeDelayWindow = message.removeStakeDelayWindow;
    }
    if (message.minEpochLength?.length) {
      obj.minEpochLength = message.minEpochLength;
    }
    if (message.betaEntropy?.length) {
      obj.betaEntropy = message.betaEntropy;
    }
    if (message.learningRate?.length) {
      obj.learningRate = message.learningRate;
    }
    if (message.maxGradientThreshold?.length) {
      obj.maxGradientThreshold = message.maxGradientThreshold;
    }
    if (message.minStakeFraction?.length) {
      obj.minStakeFraction = message.minStakeFraction;
    }
    if (message.maxUnfulfilledWorkerRequests?.length) {
      obj.maxUnfulfilledWorkerRequests = message.maxUnfulfilledWorkerRequests;
    }
    if (message.maxUnfulfilledReputerRequests?.length) {
      obj.maxUnfulfilledReputerRequests = message.maxUnfulfilledReputerRequests;
    }
    if (message.topicRewardStakeImportance?.length) {
      obj.topicRewardStakeImportance = message.topicRewardStakeImportance;
    }
    if (message.topicRewardFeeRevenueImportance?.length) {
      obj.topicRewardFeeRevenueImportance = message.topicRewardFeeRevenueImportance;
    }
    if (message.topicRewardAlpha?.length) {
      obj.topicRewardAlpha = message.topicRewardAlpha;
    }
    if (message.taskRewardAlpha?.length) {
      obj.taskRewardAlpha = message.taskRewardAlpha;
    }
    if (message.validatorsVsAlloraPercentReward?.length) {
      obj.validatorsVsAlloraPercentReward = message.validatorsVsAlloraPercentReward;
    }
    if (message.maxSamplesToScaleScores?.length) {
      obj.maxSamplesToScaleScores = message.maxSamplesToScaleScores;
    }
    if (message.maxTopInferersToReward?.length) {
      obj.maxTopInferersToReward = message.maxTopInferersToReward;
    }
    if (message.maxTopForecastersToReward?.length) {
      obj.maxTopForecastersToReward = message.maxTopForecastersToReward;
    }
    if (message.maxTopReputersToReward?.length) {
      obj.maxTopReputersToReward = message.maxTopReputersToReward;
    }
    if (message.createTopicFee?.length) {
      obj.createTopicFee = message.createTopicFee;
    }
    if (message.gradientDescentMaxIters?.length) {
      obj.gradientDescentMaxIters = message.gradientDescentMaxIters;
    }
    if (message.registrationFee?.length) {
      obj.registrationFee = message.registrationFee;
    }
    if (message.defaultPageLimit?.length) {
      obj.defaultPageLimit = message.defaultPageLimit;
    }
    if (message.maxPageLimit?.length) {
      obj.maxPageLimit = message.maxPageLimit;
    }
    if (message.minEpochLengthRecordLimit?.length) {
      obj.minEpochLengthRecordLimit = message.minEpochLengthRecordLimit;
    }
    if (message.blocksPerMonth?.length) {
      obj.blocksPerMonth = message.blocksPerMonth;
    }
    if (message.pRewardInference?.length) {
      obj.pRewardInference = message.pRewardInference;
    }
    if (message.pRewardForecast?.length) {
      obj.pRewardForecast = message.pRewardForecast;
    }
    if (message.pRewardReputer?.length) {
      obj.pRewardReputer = message.pRewardReputer;
    }
    if (message.cRewardInference?.length) {
      obj.cRewardInference = message.cRewardInference;
    }
    if (message.cRewardForecast?.length) {
      obj.cRewardForecast = message.cRewardForecast;
    }
    if (message.cNorm?.length) {
      obj.cNorm = message.cNorm;
    }
    if (message.epsilonReputer?.length) {
      obj.epsilonReputer = message.epsilonReputer;
    }
    if (message.halfMaxProcessStakeRemovalsEndBlock?.length) {
      obj.halfMaxProcessStakeRemovalsEndBlock = message.halfMaxProcessStakeRemovalsEndBlock;
    }
    if (message.dataSendingFee?.length) {
      obj.dataSendingFee = message.dataSendingFee;
    }
    if (message.epsilonSafeDiv?.length) {
      obj.epsilonSafeDiv = message.epsilonSafeDiv;
    }
    if (message.maxElementsPerForecast?.length) {
      obj.maxElementsPerForecast = message.maxElementsPerForecast;
    }
    if (message.maxActiveTopicsPerBlock?.length) {
      obj.maxActiveTopicsPerBlock = message.maxActiveTopicsPerBlock;
    }
    return obj;
  },

  create(base?: DeepPartial<OptionalParams>): OptionalParams {
    return OptionalParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptionalParams>): OptionalParams {
    const message = createBaseOptionalParams();
    message.version = object.version?.map((e) => e) || [];
    message.maxSerializedMsgLength = object.maxSerializedMsgLength?.map((e) => e) || [];
    message.minTopicWeight = object.minTopicWeight?.map((e) => e) || [];
    message.requiredMinimumStake = object.requiredMinimumStake?.map((e) => e) || [];
    message.removeStakeDelayWindow = object.removeStakeDelayWindow?.map((e) => e) || [];
    message.minEpochLength = object.minEpochLength?.map((e) => e) || [];
    message.betaEntropy = object.betaEntropy?.map((e) => e) || [];
    message.learningRate = object.learningRate?.map((e) => e) || [];
    message.maxGradientThreshold = object.maxGradientThreshold?.map((e) => e) || [];
    message.minStakeFraction = object.minStakeFraction?.map((e) => e) || [];
    message.maxUnfulfilledWorkerRequests = object.maxUnfulfilledWorkerRequests?.map((e) => e) || [];
    message.maxUnfulfilledReputerRequests = object.maxUnfulfilledReputerRequests?.map((e) => e) || [];
    message.topicRewardStakeImportance = object.topicRewardStakeImportance?.map((e) => e) || [];
    message.topicRewardFeeRevenueImportance = object.topicRewardFeeRevenueImportance?.map((e) => e) || [];
    message.topicRewardAlpha = object.topicRewardAlpha?.map((e) => e) || [];
    message.taskRewardAlpha = object.taskRewardAlpha?.map((e) => e) || [];
    message.validatorsVsAlloraPercentReward = object.validatorsVsAlloraPercentReward?.map((e) => e) || [];
    message.maxSamplesToScaleScores = object.maxSamplesToScaleScores?.map((e) => e) || [];
    message.maxTopInferersToReward = object.maxTopInferersToReward?.map((e) => e) || [];
    message.maxTopForecastersToReward = object.maxTopForecastersToReward?.map((e) => e) || [];
    message.maxTopReputersToReward = object.maxTopReputersToReward?.map((e) => e) || [];
    message.createTopicFee = object.createTopicFee?.map((e) => e) || [];
    message.gradientDescentMaxIters = object.gradientDescentMaxIters?.map((e) => e) || [];
    message.registrationFee = object.registrationFee?.map((e) => e) || [];
    message.defaultPageLimit = object.defaultPageLimit?.map((e) => e) || [];
    message.maxPageLimit = object.maxPageLimit?.map((e) => e) || [];
    message.minEpochLengthRecordLimit = object.minEpochLengthRecordLimit?.map((e) => e) || [];
    message.blocksPerMonth = object.blocksPerMonth?.map((e) => e) || [];
    message.pRewardInference = object.pRewardInference?.map((e) => e) || [];
    message.pRewardForecast = object.pRewardForecast?.map((e) => e) || [];
    message.pRewardReputer = object.pRewardReputer?.map((e) => e) || [];
    message.cRewardInference = object.cRewardInference?.map((e) => e) || [];
    message.cRewardForecast = object.cRewardForecast?.map((e) => e) || [];
    message.cNorm = object.cNorm?.map((e) => e) || [];
    message.epsilonReputer = object.epsilonReputer?.map((e) => e) || [];
    message.halfMaxProcessStakeRemovalsEndBlock = object.halfMaxProcessStakeRemovalsEndBlock?.map((e) => e) || [];
    message.dataSendingFee = object.dataSendingFee?.map((e) => e) || [];
    message.epsilonSafeDiv = object.epsilonSafeDiv?.map((e) => e) || [];
    message.maxElementsPerForecast = object.maxElementsPerForecast?.map((e) => e) || [];
    message.maxActiveTopicsPerBlock = object.maxActiveTopicsPerBlock?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { sender: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.params !== undefined) {
      OptionalParams.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = OptionalParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      params: isSet(object.params) ? OptionalParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.params !== undefined) {
      obj.params = OptionalParams.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.sender = object.sender ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? OptionalParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgCreateNewTopic(): MsgCreateNewTopic {
  return {
    creator: "",
    metadata: "",
    lossMethod: "",
    epochLength: "0",
    groundTruthLag: "0",
    pNorm: "",
    alphaRegret: "",
    allowNegative: false,
    epsilon: "",
    workerSubmissionWindow: "0",
    meritSortitionAlpha: "",
    activeInfererQuantile: "",
    activeForecasterQuantile: "",
    activeReputerQuantile: "",
  };
}

export const MsgCreateNewTopic: MessageFns<MsgCreateNewTopic> = {
  encode(message: MsgCreateNewTopic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.metadata !== "") {
      writer.uint32(18).string(message.metadata);
    }
    if (message.lossMethod !== "") {
      writer.uint32(34).string(message.lossMethod);
    }
    if (message.epochLength !== "0") {
      writer.uint32(56).int64(message.epochLength);
    }
    if (message.groundTruthLag !== "0") {
      writer.uint32(64).int64(message.groundTruthLag);
    }
    if (message.pNorm !== "") {
      writer.uint32(82).string(message.pNorm);
    }
    if (message.alphaRegret !== "") {
      writer.uint32(90).string(message.alphaRegret);
    }
    if (message.allowNegative !== false) {
      writer.uint32(96).bool(message.allowNegative);
    }
    if (message.epsilon !== "") {
      writer.uint32(106).string(message.epsilon);
    }
    if (message.workerSubmissionWindow !== "0") {
      writer.uint32(112).int64(message.workerSubmissionWindow);
    }
    if (message.meritSortitionAlpha !== "") {
      writer.uint32(122).string(message.meritSortitionAlpha);
    }
    if (message.activeInfererQuantile !== "") {
      writer.uint32(130).string(message.activeInfererQuantile);
    }
    if (message.activeForecasterQuantile !== "") {
      writer.uint32(138).string(message.activeForecasterQuantile);
    }
    if (message.activeReputerQuantile !== "") {
      writer.uint32(146).string(message.activeReputerQuantile);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateNewTopic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateNewTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lossMethod = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.epochLength = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.groundTruthLag = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pNorm = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.alphaRegret = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.allowNegative = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.epsilon = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.workerSubmissionWindow = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.meritSortitionAlpha = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.activeInfererQuantile = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.activeForecasterQuantile = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.activeReputerQuantile = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateNewTopic {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      lossMethod: isSet(object.lossMethod) ? globalThis.String(object.lossMethod) : "",
      epochLength: isSet(object.epochLength) ? globalThis.String(object.epochLength) : "0",
      groundTruthLag: isSet(object.groundTruthLag) ? globalThis.String(object.groundTruthLag) : "0",
      pNorm: isSet(object.pNorm) ? globalThis.String(object.pNorm) : "",
      alphaRegret: isSet(object.alphaRegret) ? globalThis.String(object.alphaRegret) : "",
      allowNegative: isSet(object.allowNegative) ? globalThis.Boolean(object.allowNegative) : false,
      epsilon: isSet(object.epsilon) ? globalThis.String(object.epsilon) : "",
      workerSubmissionWindow: isSet(object.workerSubmissionWindow)
        ? globalThis.String(object.workerSubmissionWindow)
        : "0",
      meritSortitionAlpha: isSet(object.meritSortitionAlpha) ? globalThis.String(object.meritSortitionAlpha) : "",
      activeInfererQuantile: isSet(object.activeInfererQuantile) ? globalThis.String(object.activeInfererQuantile) : "",
      activeForecasterQuantile: isSet(object.activeForecasterQuantile)
        ? globalThis.String(object.activeForecasterQuantile)
        : "",
      activeReputerQuantile: isSet(object.activeReputerQuantile) ? globalThis.String(object.activeReputerQuantile) : "",
    };
  },

  toJSON(message: MsgCreateNewTopic): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.lossMethod !== "") {
      obj.lossMethod = message.lossMethod;
    }
    if (message.epochLength !== "0") {
      obj.epochLength = message.epochLength;
    }
    if (message.groundTruthLag !== "0") {
      obj.groundTruthLag = message.groundTruthLag;
    }
    if (message.pNorm !== "") {
      obj.pNorm = message.pNorm;
    }
    if (message.alphaRegret !== "") {
      obj.alphaRegret = message.alphaRegret;
    }
    if (message.allowNegative !== false) {
      obj.allowNegative = message.allowNegative;
    }
    if (message.epsilon !== "") {
      obj.epsilon = message.epsilon;
    }
    if (message.workerSubmissionWindow !== "0") {
      obj.workerSubmissionWindow = message.workerSubmissionWindow;
    }
    if (message.meritSortitionAlpha !== "") {
      obj.meritSortitionAlpha = message.meritSortitionAlpha;
    }
    if (message.activeInfererQuantile !== "") {
      obj.activeInfererQuantile = message.activeInfererQuantile;
    }
    if (message.activeForecasterQuantile !== "") {
      obj.activeForecasterQuantile = message.activeForecasterQuantile;
    }
    if (message.activeReputerQuantile !== "") {
      obj.activeReputerQuantile = message.activeReputerQuantile;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgCreateNewTopic>): MsgCreateNewTopic {
    return MsgCreateNewTopic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgCreateNewTopic>): MsgCreateNewTopic {
    const message = createBaseMsgCreateNewTopic();
    message.creator = object.creator ?? "";
    message.metadata = object.metadata ?? "";
    message.lossMethod = object.lossMethod ?? "";
    message.epochLength = object.epochLength ?? "0";
    message.groundTruthLag = object.groundTruthLag ?? "0";
    message.pNorm = object.pNorm ?? "";
    message.alphaRegret = object.alphaRegret ?? "";
    message.allowNegative = object.allowNegative ?? false;
    message.epsilon = object.epsilon ?? "";
    message.workerSubmissionWindow = object.workerSubmissionWindow ?? "0";
    message.meritSortitionAlpha = object.meritSortitionAlpha ?? "";
    message.activeInfererQuantile = object.activeInfererQuantile ?? "";
    message.activeForecasterQuantile = object.activeForecasterQuantile ?? "";
    message.activeReputerQuantile = object.activeReputerQuantile ?? "";
    return message;
  },
};

function createBaseMsgCreateNewTopicResponse(): MsgCreateNewTopicResponse {
  return { topicId: "0" };
}

export const MsgCreateNewTopicResponse: MessageFns<MsgCreateNewTopicResponse> = {
  encode(message: MsgCreateNewTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateNewTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateNewTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateNewTopicResponse {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: MsgCreateNewTopicResponse): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgCreateNewTopicResponse>): MsgCreateNewTopicResponse {
    return MsgCreateNewTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgCreateNewTopicResponse>): MsgCreateNewTopicResponse {
    const message = createBaseMsgCreateNewTopicResponse();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseMsgInsertReputerPayload(): MsgInsertReputerPayload {
  return { sender: "", reputerValueBundle: undefined };
}

export const MsgInsertReputerPayload: MessageFns<MsgInsertReputerPayload> = {
  encode(message: MsgInsertReputerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.reputerValueBundle !== undefined) {
      ReputerValueBundle.encode(message.reputerValueBundle, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInsertReputerPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInsertReputerPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputerValueBundle = ReputerValueBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgInsertReputerPayload {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      reputerValueBundle: isSet(object.reputerValueBundle)
        ? ReputerValueBundle.fromJSON(object.reputerValueBundle)
        : undefined,
    };
  },

  toJSON(message: MsgInsertReputerPayload): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.reputerValueBundle !== undefined) {
      obj.reputerValueBundle = ReputerValueBundle.toJSON(message.reputerValueBundle);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgInsertReputerPayload>): MsgInsertReputerPayload {
    return MsgInsertReputerPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgInsertReputerPayload>): MsgInsertReputerPayload {
    const message = createBaseMsgInsertReputerPayload();
    message.sender = object.sender ?? "";
    message.reputerValueBundle = (object.reputerValueBundle !== undefined && object.reputerValueBundle !== null)
      ? ReputerValueBundle.fromPartial(object.reputerValueBundle)
      : undefined;
    return message;
  },
};

function createBaseMsgInsertReputerPayloadResponse(): MsgInsertReputerPayloadResponse {
  return {};
}

export const MsgInsertReputerPayloadResponse: MessageFns<MsgInsertReputerPayloadResponse> = {
  encode(_: MsgInsertReputerPayloadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInsertReputerPayloadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInsertReputerPayloadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgInsertReputerPayloadResponse {
    return {};
  },

  toJSON(_: MsgInsertReputerPayloadResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInsertReputerPayloadResponse>): MsgInsertReputerPayloadResponse {
    return MsgInsertReputerPayloadResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgInsertReputerPayloadResponse>): MsgInsertReputerPayloadResponse {
    const message = createBaseMsgInsertReputerPayloadResponse();
    return message;
  },
};

function createBaseMsgInsertWorkerPayload(): MsgInsertWorkerPayload {
  return { sender: "", workerDataBundle: undefined };
}

export const MsgInsertWorkerPayload: MessageFns<MsgInsertWorkerPayload> = {
  encode(message: MsgInsertWorkerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.workerDataBundle !== undefined) {
      WorkerDataBundle.encode(message.workerDataBundle, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInsertWorkerPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInsertWorkerPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerDataBundle = WorkerDataBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgInsertWorkerPayload {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      workerDataBundle: isSet(object.workerDataBundle) ? WorkerDataBundle.fromJSON(object.workerDataBundle) : undefined,
    };
  },

  toJSON(message: MsgInsertWorkerPayload): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.workerDataBundle !== undefined) {
      obj.workerDataBundle = WorkerDataBundle.toJSON(message.workerDataBundle);
    }
    return obj;
  },

  create(base?: DeepPartial<MsgInsertWorkerPayload>): MsgInsertWorkerPayload {
    return MsgInsertWorkerPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgInsertWorkerPayload>): MsgInsertWorkerPayload {
    const message = createBaseMsgInsertWorkerPayload();
    message.sender = object.sender ?? "";
    message.workerDataBundle = (object.workerDataBundle !== undefined && object.workerDataBundle !== null)
      ? WorkerDataBundle.fromPartial(object.workerDataBundle)
      : undefined;
    return message;
  },
};

function createBaseMsgInsertWorkerPayloadResponse(): MsgInsertWorkerPayloadResponse {
  return {};
}

export const MsgInsertWorkerPayloadResponse: MessageFns<MsgInsertWorkerPayloadResponse> = {
  encode(_: MsgInsertWorkerPayloadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInsertWorkerPayloadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInsertWorkerPayloadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgInsertWorkerPayloadResponse {
    return {};
  },

  toJSON(_: MsgInsertWorkerPayloadResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgInsertWorkerPayloadResponse>): MsgInsertWorkerPayloadResponse {
    return MsgInsertWorkerPayloadResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgInsertWorkerPayloadResponse>): MsgInsertWorkerPayloadResponse {
    const message = createBaseMsgInsertWorkerPayloadResponse();
    return message;
  },
};

function createBaseMsgRegister(): MsgRegister {
  return { sender: "", topicId: "0", owner: "", isReputer: false };
}

export const MsgRegister: MessageFns<MsgRegister> = {
  encode(message: MsgRegister, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(32).uint64(message.topicId);
    }
    if (message.owner !== "") {
      writer.uint32(42).string(message.owner);
    }
    if (message.isReputer !== false) {
      writer.uint32(48).bool(message.isReputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegister {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegister();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isReputer = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegister {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      isReputer: isSet(object.isReputer) ? globalThis.Boolean(object.isReputer) : false,
    };
  },

  toJSON(message: MsgRegister): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.isReputer !== false) {
      obj.isReputer = message.isReputer;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRegister>): MsgRegister {
    return MsgRegister.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRegister>): MsgRegister {
    const message = createBaseMsgRegister();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.owner = object.owner ?? "";
    message.isReputer = object.isReputer ?? false;
    return message;
  },
};

function createBaseMsgRegisterResponse(): MsgRegisterResponse {
  return { success: false, message: "" };
}

export const MsgRegisterResponse: MessageFns<MsgRegisterResponse> = {
  encode(message: MsgRegisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: MsgRegisterResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRegisterResponse>): MsgRegisterResponse {
    return MsgRegisterResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRegisterResponse>): MsgRegisterResponse {
    const message = createBaseMsgRegisterResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseMsgRemoveRegistration(): MsgRemoveRegistration {
  return { sender: "", topicId: "0", isReputer: false };
}

export const MsgRemoveRegistration: MessageFns<MsgRemoveRegistration> = {
  encode(message: MsgRemoveRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.isReputer !== false) {
      writer.uint32(24).bool(message.isReputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isReputer = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveRegistration {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      isReputer: isSet(object.isReputer) ? globalThis.Boolean(object.isReputer) : false,
    };
  },

  toJSON(message: MsgRemoveRegistration): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.isReputer !== false) {
      obj.isReputer = message.isReputer;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveRegistration>): MsgRemoveRegistration {
    return MsgRemoveRegistration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveRegistration>): MsgRemoveRegistration {
    const message = createBaseMsgRemoveRegistration();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.isReputer = object.isReputer ?? false;
    return message;
  },
};

function createBaseMsgRemoveRegistrationResponse(): MsgRemoveRegistrationResponse {
  return { success: false, message: "" };
}

export const MsgRemoveRegistrationResponse: MessageFns<MsgRemoveRegistrationResponse> = {
  encode(message: MsgRemoveRegistrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveRegistrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveRegistrationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: MsgRemoveRegistrationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveRegistrationResponse>): MsgRemoveRegistrationResponse {
    return MsgRemoveRegistrationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveRegistrationResponse>): MsgRemoveRegistrationResponse {
    const message = createBaseMsgRemoveRegistrationResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseMsgAddStake(): MsgAddStake {
  return { sender: "", topicId: "0", amount: "" };
}

export const MsgAddStake: MessageFns<MsgAddStake> = {
  encode(message: MsgAddStake, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddStake {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddStake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddStake {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgAddStake): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAddStake>): MsgAddStake {
    return MsgAddStake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAddStake>): MsgAddStake {
    const message = createBaseMsgAddStake();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgAddStakeResponse(): MsgAddStakeResponse {
  return {};
}

export const MsgAddStakeResponse: MessageFns<MsgAddStakeResponse> = {
  encode(_: MsgAddStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddStakeResponse {
    return {};
  },

  toJSON(_: MsgAddStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAddStakeResponse>): MsgAddStakeResponse {
    return MsgAddStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAddStakeResponse>): MsgAddStakeResponse {
    const message = createBaseMsgAddStakeResponse();
    return message;
  },
};

function createBaseMsgRemoveStake(): MsgRemoveStake {
  return { sender: "", topicId: "0", amount: "" };
}

export const MsgRemoveStake: MessageFns<MsgRemoveStake> = {
  encode(message: MsgRemoveStake, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveStake {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveStake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveStake {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgRemoveStake): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveStake>): MsgRemoveStake {
    return MsgRemoveStake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveStake>): MsgRemoveStake {
    const message = createBaseMsgRemoveStake();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgRemoveStakeResponse(): MsgRemoveStakeResponse {
  return {};
}

export const MsgRemoveStakeResponse: MessageFns<MsgRemoveStakeResponse> = {
  encode(_: MsgRemoveStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveStakeResponse {
    return {};
  },

  toJSON(_: MsgRemoveStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveStakeResponse>): MsgRemoveStakeResponse {
    return MsgRemoveStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRemoveStakeResponse>): MsgRemoveStakeResponse {
    const message = createBaseMsgRemoveStakeResponse();
    return message;
  },
};

function createBaseMsgCancelRemoveStake(): MsgCancelRemoveStake {
  return { sender: "", topicId: "0" };
}

export const MsgCancelRemoveStake: MessageFns<MsgCancelRemoveStake> = {
  encode(message: MsgCancelRemoveStake, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelRemoveStake {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelRemoveStake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCancelRemoveStake {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: MsgCancelRemoveStake): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgCancelRemoveStake>): MsgCancelRemoveStake {
    return MsgCancelRemoveStake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgCancelRemoveStake>): MsgCancelRemoveStake {
    const message = createBaseMsgCancelRemoveStake();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseMsgCancelRemoveStakeResponse(): MsgCancelRemoveStakeResponse {
  return {};
}

export const MsgCancelRemoveStakeResponse: MessageFns<MsgCancelRemoveStakeResponse> = {
  encode(_: MsgCancelRemoveStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelRemoveStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelRemoveStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCancelRemoveStakeResponse {
    return {};
  },

  toJSON(_: MsgCancelRemoveStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCancelRemoveStakeResponse>): MsgCancelRemoveStakeResponse {
    return MsgCancelRemoveStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgCancelRemoveStakeResponse>): MsgCancelRemoveStakeResponse {
    const message = createBaseMsgCancelRemoveStakeResponse();
    return message;
  },
};

function createBaseMsgDelegateStake(): MsgDelegateStake {
  return { sender: "", topicId: "0", reputer: "", amount: "" };
}

export const MsgDelegateStake: MessageFns<MsgDelegateStake> = {
  encode(message: MsgDelegateStake, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(26).string(message.reputer);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDelegateStake {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDelegateStake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDelegateStake {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgDelegateStake): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgDelegateStake>): MsgDelegateStake {
    return MsgDelegateStake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgDelegateStake>): MsgDelegateStake {
    const message = createBaseMsgDelegateStake();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgDelegateStakeResponse(): MsgDelegateStakeResponse {
  return {};
}

export const MsgDelegateStakeResponse: MessageFns<MsgDelegateStakeResponse> = {
  encode(_: MsgDelegateStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDelegateStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDelegateStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDelegateStakeResponse {
    return {};
  },

  toJSON(_: MsgDelegateStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgDelegateStakeResponse>): MsgDelegateStakeResponse {
    return MsgDelegateStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgDelegateStakeResponse>): MsgDelegateStakeResponse {
    const message = createBaseMsgDelegateStakeResponse();
    return message;
  },
};

function createBaseMsgRemoveDelegateStake(): MsgRemoveDelegateStake {
  return { sender: "", reputer: "", topicId: "0", amount: "" };
}

export const MsgRemoveDelegateStake: MessageFns<MsgRemoveDelegateStake> = {
  encode(message: MsgRemoveDelegateStake, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.reputer !== "") {
      writer.uint32(18).string(message.reputer);
    }
    if (message.topicId !== "0") {
      writer.uint32(24).uint64(message.topicId);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveDelegateStake {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveDelegateStake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveDelegateStake {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgRemoveDelegateStake): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveDelegateStake>): MsgRemoveDelegateStake {
    return MsgRemoveDelegateStake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveDelegateStake>): MsgRemoveDelegateStake {
    const message = createBaseMsgRemoveDelegateStake();
    message.sender = object.sender ?? "";
    message.reputer = object.reputer ?? "";
    message.topicId = object.topicId ?? "0";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgRemoveDelegateStakeResponse(): MsgRemoveDelegateStakeResponse {
  return {};
}

export const MsgRemoveDelegateStakeResponse: MessageFns<MsgRemoveDelegateStakeResponse> = {
  encode(_: MsgRemoveDelegateStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveDelegateStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveDelegateStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveDelegateStakeResponse {
    return {};
  },

  toJSON(_: MsgRemoveDelegateStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveDelegateStakeResponse>): MsgRemoveDelegateStakeResponse {
    return MsgRemoveDelegateStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRemoveDelegateStakeResponse>): MsgRemoveDelegateStakeResponse {
    const message = createBaseMsgRemoveDelegateStakeResponse();
    return message;
  },
};

function createBaseMsgCancelRemoveDelegateStake(): MsgCancelRemoveDelegateStake {
  return { sender: "", topicId: "0", delegator: "", reputer: "" };
}

export const MsgCancelRemoveDelegateStake: MessageFns<MsgCancelRemoveDelegateStake> = {
  encode(message: MsgCancelRemoveDelegateStake, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.delegator !== "") {
      writer.uint32(26).string(message.delegator);
    }
    if (message.reputer !== "") {
      writer.uint32(34).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelRemoveDelegateStake {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelRemoveDelegateStake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delegator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCancelRemoveDelegateStake {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      delegator: isSet(object.delegator) ? globalThis.String(object.delegator) : "",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: MsgCancelRemoveDelegateStake): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.delegator !== "") {
      obj.delegator = message.delegator;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgCancelRemoveDelegateStake>): MsgCancelRemoveDelegateStake {
    return MsgCancelRemoveDelegateStake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgCancelRemoveDelegateStake>): MsgCancelRemoveDelegateStake {
    const message = createBaseMsgCancelRemoveDelegateStake();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.delegator = object.delegator ?? "";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseMsgCancelRemoveDelegateStakeResponse(): MsgCancelRemoveDelegateStakeResponse {
  return {};
}

export const MsgCancelRemoveDelegateStakeResponse: MessageFns<MsgCancelRemoveDelegateStakeResponse> = {
  encode(_: MsgCancelRemoveDelegateStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelRemoveDelegateStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelRemoveDelegateStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCancelRemoveDelegateStakeResponse {
    return {};
  },

  toJSON(_: MsgCancelRemoveDelegateStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgCancelRemoveDelegateStakeResponse>): MsgCancelRemoveDelegateStakeResponse {
    return MsgCancelRemoveDelegateStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgCancelRemoveDelegateStakeResponse>): MsgCancelRemoveDelegateStakeResponse {
    const message = createBaseMsgCancelRemoveDelegateStakeResponse();
    return message;
  },
};

function createBaseMsgFundTopic(): MsgFundTopic {
  return { sender: "", topicId: "0", amount: "" };
}

export const MsgFundTopic: MessageFns<MsgFundTopic> = {
  encode(message: MsgFundTopic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFundTopic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFundTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFundTopic {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: MsgFundTopic): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgFundTopic>): MsgFundTopic {
    return MsgFundTopic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgFundTopic>): MsgFundTopic {
    const message = createBaseMsgFundTopic();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseMsgFundTopicResponse(): MsgFundTopicResponse {
  return {};
}

export const MsgFundTopicResponse: MessageFns<MsgFundTopicResponse> = {
  encode(_: MsgFundTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFundTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFundTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFundTopicResponse {
    return {};
  },

  toJSON(_: MsgFundTopicResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgFundTopicResponse>): MsgFundTopicResponse {
    return MsgFundTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgFundTopicResponse>): MsgFundTopicResponse {
    const message = createBaseMsgFundTopicResponse();
    return message;
  },
};

function createBaseMsgAddToWhitelistAdmin(): MsgAddToWhitelistAdmin {
  return { sender: "", address: "" };
}

export const MsgAddToWhitelistAdmin: MessageFns<MsgAddToWhitelistAdmin> = {
  encode(message: MsgAddToWhitelistAdmin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddToWhitelistAdmin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddToWhitelistAdmin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddToWhitelistAdmin {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: MsgAddToWhitelistAdmin): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgAddToWhitelistAdmin>): MsgAddToWhitelistAdmin {
    return MsgAddToWhitelistAdmin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgAddToWhitelistAdmin>): MsgAddToWhitelistAdmin {
    const message = createBaseMsgAddToWhitelistAdmin();
    message.sender = object.sender ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseMsgAddToWhitelistAdminResponse(): MsgAddToWhitelistAdminResponse {
  return {};
}

export const MsgAddToWhitelistAdminResponse: MessageFns<MsgAddToWhitelistAdminResponse> = {
  encode(_: MsgAddToWhitelistAdminResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddToWhitelistAdminResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddToWhitelistAdminResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddToWhitelistAdminResponse {
    return {};
  },

  toJSON(_: MsgAddToWhitelistAdminResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgAddToWhitelistAdminResponse>): MsgAddToWhitelistAdminResponse {
    return MsgAddToWhitelistAdminResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgAddToWhitelistAdminResponse>): MsgAddToWhitelistAdminResponse {
    const message = createBaseMsgAddToWhitelistAdminResponse();
    return message;
  },
};

function createBaseMsgRemoveFromWhitelistAdmin(): MsgRemoveFromWhitelistAdmin {
  return { sender: "", address: "" };
}

export const MsgRemoveFromWhitelistAdmin: MessageFns<MsgRemoveFromWhitelistAdmin> = {
  encode(message: MsgRemoveFromWhitelistAdmin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveFromWhitelistAdmin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveFromWhitelistAdmin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveFromWhitelistAdmin {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: MsgRemoveFromWhitelistAdmin): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveFromWhitelistAdmin>): MsgRemoveFromWhitelistAdmin {
    return MsgRemoveFromWhitelistAdmin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRemoveFromWhitelistAdmin>): MsgRemoveFromWhitelistAdmin {
    const message = createBaseMsgRemoveFromWhitelistAdmin();
    message.sender = object.sender ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseMsgRemoveFromWhitelistAdminResponse(): MsgRemoveFromWhitelistAdminResponse {
  return {};
}

export const MsgRemoveFromWhitelistAdminResponse: MessageFns<MsgRemoveFromWhitelistAdminResponse> = {
  encode(_: MsgRemoveFromWhitelistAdminResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveFromWhitelistAdminResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveFromWhitelistAdminResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveFromWhitelistAdminResponse {
    return {};
  },

  toJSON(_: MsgRemoveFromWhitelistAdminResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRemoveFromWhitelistAdminResponse>): MsgRemoveFromWhitelistAdminResponse {
    return MsgRemoveFromWhitelistAdminResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRemoveFromWhitelistAdminResponse>): MsgRemoveFromWhitelistAdminResponse {
    const message = createBaseMsgRemoveFromWhitelistAdminResponse();
    return message;
  },
};

function createBaseMsgRewardDelegateStakeResponse(): MsgRewardDelegateStakeResponse {
  return {};
}

export const MsgRewardDelegateStakeResponse: MessageFns<MsgRewardDelegateStakeResponse> = {
  encode(_: MsgRewardDelegateStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRewardDelegateStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRewardDelegateStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRewardDelegateStakeResponse {
    return {};
  },

  toJSON(_: MsgRewardDelegateStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MsgRewardDelegateStakeResponse>): MsgRewardDelegateStakeResponse {
    return MsgRewardDelegateStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MsgRewardDelegateStakeResponse>): MsgRewardDelegateStakeResponse {
    const message = createBaseMsgRewardDelegateStakeResponse();
    return message;
  },
};

function createBaseMsgRewardDelegateStake(): MsgRewardDelegateStake {
  return { sender: "", topicId: "0", reputer: "" };
}

export const MsgRewardDelegateStake: MessageFns<MsgRewardDelegateStake> = {
  encode(message: MsgRewardDelegateStake, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(26).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRewardDelegateStake {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRewardDelegateStake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRewardDelegateStake {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: MsgRewardDelegateStake): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<MsgRewardDelegateStake>): MsgRewardDelegateStake {
    return MsgRewardDelegateStake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MsgRewardDelegateStake>): MsgRewardDelegateStake {
    const message = createBaseMsgRewardDelegateStake();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

/** Msg defines the module Msg service. */
export interface Msg {
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  CreateNewTopic(request: MsgCreateNewTopic): Promise<MsgCreateNewTopicResponse>;
  Register(request: MsgRegister): Promise<MsgRegisterResponse>;
  RemoveRegistration(request: MsgRemoveRegistration): Promise<MsgRemoveRegistrationResponse>;
  AddStake(request: MsgAddStake): Promise<MsgAddStakeResponse>;
  RemoveStake(request: MsgRemoveStake): Promise<MsgRemoveStakeResponse>;
  CancelRemoveStake(request: MsgCancelRemoveStake): Promise<MsgCancelRemoveStakeResponse>;
  DelegateStake(request: MsgDelegateStake): Promise<MsgDelegateStakeResponse>;
  RewardDelegateStake(request: MsgRewardDelegateStake): Promise<MsgRewardDelegateStakeResponse>;
  RemoveDelegateStake(request: MsgRemoveDelegateStake): Promise<MsgRemoveDelegateStakeResponse>;
  CancelRemoveDelegateStake(request: MsgCancelRemoveDelegateStake): Promise<MsgCancelRemoveDelegateStakeResponse>;
  FundTopic(request: MsgFundTopic): Promise<MsgFundTopicResponse>;
  AddToWhitelistAdmin(request: MsgAddToWhitelistAdmin): Promise<MsgAddToWhitelistAdminResponse>;
  RemoveFromWhitelistAdmin(request: MsgRemoveFromWhitelistAdmin): Promise<MsgRemoveFromWhitelistAdminResponse>;
  InsertWorkerPayload(request: MsgInsertWorkerPayload): Promise<MsgInsertWorkerPayloadResponse>;
  InsertReputerPayload(request: MsgInsertReputerPayload): Promise<MsgInsertReputerPayloadResponse>;
}

export const MsgServiceName = "emissions.v3.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.CreateNewTopic = this.CreateNewTopic.bind(this);
    this.Register = this.Register.bind(this);
    this.RemoveRegistration = this.RemoveRegistration.bind(this);
    this.AddStake = this.AddStake.bind(this);
    this.RemoveStake = this.RemoveStake.bind(this);
    this.CancelRemoveStake = this.CancelRemoveStake.bind(this);
    this.DelegateStake = this.DelegateStake.bind(this);
    this.RewardDelegateStake = this.RewardDelegateStake.bind(this);
    this.RemoveDelegateStake = this.RemoveDelegateStake.bind(this);
    this.CancelRemoveDelegateStake = this.CancelRemoveDelegateStake.bind(this);
    this.FundTopic = this.FundTopic.bind(this);
    this.AddToWhitelistAdmin = this.AddToWhitelistAdmin.bind(this);
    this.RemoveFromWhitelistAdmin = this.RemoveFromWhitelistAdmin.bind(this);
    this.InsertWorkerPayload = this.InsertWorkerPayload.bind(this);
    this.InsertReputerPayload = this.InsertReputerPayload.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  CreateNewTopic(request: MsgCreateNewTopic): Promise<MsgCreateNewTopicResponse> {
    const data = MsgCreateNewTopic.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateNewTopic", data);
    return promise.then((data) => MsgCreateNewTopicResponse.decode(new BinaryReader(data)));
  }

  Register(request: MsgRegister): Promise<MsgRegisterResponse> {
    const data = MsgRegister.encode(request).finish();
    const promise = this.rpc.request(this.service, "Register", data);
    return promise.then((data) => MsgRegisterResponse.decode(new BinaryReader(data)));
  }

  RemoveRegistration(request: MsgRemoveRegistration): Promise<MsgRemoveRegistrationResponse> {
    const data = MsgRemoveRegistration.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveRegistration", data);
    return promise.then((data) => MsgRemoveRegistrationResponse.decode(new BinaryReader(data)));
  }

  AddStake(request: MsgAddStake): Promise<MsgAddStakeResponse> {
    const data = MsgAddStake.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddStake", data);
    return promise.then((data) => MsgAddStakeResponse.decode(new BinaryReader(data)));
  }

  RemoveStake(request: MsgRemoveStake): Promise<MsgRemoveStakeResponse> {
    const data = MsgRemoveStake.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveStake", data);
    return promise.then((data) => MsgRemoveStakeResponse.decode(new BinaryReader(data)));
  }

  CancelRemoveStake(request: MsgCancelRemoveStake): Promise<MsgCancelRemoveStakeResponse> {
    const data = MsgCancelRemoveStake.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelRemoveStake", data);
    return promise.then((data) => MsgCancelRemoveStakeResponse.decode(new BinaryReader(data)));
  }

  DelegateStake(request: MsgDelegateStake): Promise<MsgDelegateStakeResponse> {
    const data = MsgDelegateStake.encode(request).finish();
    const promise = this.rpc.request(this.service, "DelegateStake", data);
    return promise.then((data) => MsgDelegateStakeResponse.decode(new BinaryReader(data)));
  }

  RewardDelegateStake(request: MsgRewardDelegateStake): Promise<MsgRewardDelegateStakeResponse> {
    const data = MsgRewardDelegateStake.encode(request).finish();
    const promise = this.rpc.request(this.service, "RewardDelegateStake", data);
    return promise.then((data) => MsgRewardDelegateStakeResponse.decode(new BinaryReader(data)));
  }

  RemoveDelegateStake(request: MsgRemoveDelegateStake): Promise<MsgRemoveDelegateStakeResponse> {
    const data = MsgRemoveDelegateStake.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveDelegateStake", data);
    return promise.then((data) => MsgRemoveDelegateStakeResponse.decode(new BinaryReader(data)));
  }

  CancelRemoveDelegateStake(request: MsgCancelRemoveDelegateStake): Promise<MsgCancelRemoveDelegateStakeResponse> {
    const data = MsgCancelRemoveDelegateStake.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelRemoveDelegateStake", data);
    return promise.then((data) => MsgCancelRemoveDelegateStakeResponse.decode(new BinaryReader(data)));
  }

  FundTopic(request: MsgFundTopic): Promise<MsgFundTopicResponse> {
    const data = MsgFundTopic.encode(request).finish();
    const promise = this.rpc.request(this.service, "FundTopic", data);
    return promise.then((data) => MsgFundTopicResponse.decode(new BinaryReader(data)));
  }

  AddToWhitelistAdmin(request: MsgAddToWhitelistAdmin): Promise<MsgAddToWhitelistAdminResponse> {
    const data = MsgAddToWhitelistAdmin.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddToWhitelistAdmin", data);
    return promise.then((data) => MsgAddToWhitelistAdminResponse.decode(new BinaryReader(data)));
  }

  RemoveFromWhitelistAdmin(request: MsgRemoveFromWhitelistAdmin): Promise<MsgRemoveFromWhitelistAdminResponse> {
    const data = MsgRemoveFromWhitelistAdmin.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveFromWhitelistAdmin", data);
    return promise.then((data) => MsgRemoveFromWhitelistAdminResponse.decode(new BinaryReader(data)));
  }

  InsertWorkerPayload(request: MsgInsertWorkerPayload): Promise<MsgInsertWorkerPayloadResponse> {
    const data = MsgInsertWorkerPayload.encode(request).finish();
    const promise = this.rpc.request(this.service, "InsertWorkerPayload", data);
    return promise.then((data) => MsgInsertWorkerPayloadResponse.decode(new BinaryReader(data)));
  }

  InsertReputerPayload(request: MsgInsertReputerPayload): Promise<MsgInsertReputerPayloadResponse> {
    const data = MsgInsertReputerPayload.encode(request).finish();
    const promise = this.rpc.request(this.service, "InsertReputerPayload", data);
    return promise.then((data) => MsgInsertReputerPayloadResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
