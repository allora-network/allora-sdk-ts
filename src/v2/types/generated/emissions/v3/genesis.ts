// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: emissions/v3/genesis.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { OffchainNode } from "./node";
import { Nonces, ReputerRequestNonces } from "./nonce";
import { Params } from "./params";
import { ReputerValueBundles, ValueBundle } from "./reputer";
import { Score, Scores } from "./score";
import { DelegateStakeRemovalInfo, DelegatorInfo, StakeRemovalInfo } from "./stake";
import { TimestampedActorNonce, Topic, TopicIds, TopicIdWeightPair } from "./topic";
import { ListeningCoefficient } from "./types";
import { Forecast, Forecasts, Inference, Inferences, TimestampedValue } from "./worker";

export const protobufPackage = "emissions.v3";

/** GenesisState is the state that must be provided at genesis. */
export interface GenesisState {
  /** params defines all the parameters of the module. */
  params?:
    | Params
    | undefined;
  /**
   * / TOPIC
   * the next topic id to be used, equal to the number of topics that have been
   * created
   */
  nextTopicId: string;
  /**
   * every topic that has been created indexed by their topicId starting from 1
   * (0 is reserved for the root network)
   */
  topics: TopicIdAndTopic[];
  activeTopics: string[];
  /**
   * every topic that has been churned and ready to be rewarded i.e. reputer
   * losses have been committed
   */
  rewardableTopics: string[];
  /** for a topic, what is every worker node that has registered to it? */
  topicWorkers: TopicAndActorId[];
  /** for a topic, what is every reputer node that has registered to it? */
  topicReputers: TopicAndActorId[];
  /** map of (topic) -> nonce/block height */
  topicRewardNonce: TopicIdAndBlockHeight[];
  /**
   * / SCORES
   * map of (topic, block_height, worker) -> score
   */
  infererScoresByBlock: TopicIdBlockHeightScores[];
  /** map of (topic, block_height, worker) -> score */
  forecasterScoresByBlock: TopicIdBlockHeightScores[];
  /** map of (topic, block_height, reputer) -> score */
  reputerScoresByBlock: TopicIdBlockHeightScores[];
  /** map of (topic, block_height, worker) -> score */
  infererScoreEmas: TopicIdActorIdScore[];
  /** map of (topic, block_height, worker) -> score */
  forecasterScoreEmas: TopicIdActorIdScore[];
  /** map of (topic, block_height, reputer) -> score */
  reputerScoreEmas: TopicIdActorIdScore[];
  /** map of (topic, reputer) -> listening coefficient */
  reputerListeningCoefficient: TopicIdActorIdListeningCoefficient[];
  /** map of (topic, reputer) -> previous reward (used for EMA) */
  previousReputerRewardFraction: TopicIdActorIdDec[];
  /** map of (topic, worker) -> previous reward for inference (used for EMA) */
  previousInferenceRewardFraction: TopicIdActorIdDec[];
  /** map of (topic, worker) -> previous reward for forecast (used for EMA) */
  previousForecastRewardFraction: TopicIdActorIdDec[];
  /** map of (topic) -> ratio of forecaster score */
  previousForecasterScoreRatio: TopicIdAndDec[];
  /** total sum stake of all stakers on the network */
  totalStake: string;
  /** for every topic, how much total stake does that topic have accumulated? */
  topicStake: TopicIdAndInt[];
  /**
   * stake reputer placed in topic + delegate stake placed in them,
   * signalling their total authority on the topic
   * (topic Id, reputer) -> stake from reputer on self +
   * stakeFromDelegatorsUponReputer
   */
  stakeReputerAuthority: TopicIdActorIdInt[];
  /**
   * map of (topic id, delegator) -> total amount of stake in that topic placed
   * by that delegator
   */
  stakeSumFromDelegator: TopicIdActorIdInt[];
  /**
   * map of (topic id, delegator, reputer) -> amount of stake that has been
   * placed by that delegator on that target
   */
  delegatedStakes: TopicIdDelegatorReputerDelegatorInfo[];
  /**
   * map of (topic id, reputer) -> total amount of stake that has been placed on
   * that reputer by delegators
   */
  stakeFromDelegatorsUponReputer: TopicIdActorIdInt[];
  /** map of (topicId, reputer) -> share of delegate reward */
  delegateRewardPerShare: TopicIdActorIdDec[];
  /**
   * stake removals are double indexed to avoid O(n) lookups when removing stake
   * map of (blockHeight, topic, reputer) -> removal information for that
   * reputer
   */
  stakeRemovalsByBlock: BlockHeightTopicIdReputerStakeRemovalInfo[];
  /**
   * key set of (reputer, topic, blockHeight) to existence of a removal in the
   * forwards map
   */
  stakeRemovalsByActor: ActorIdTopicIdBlockHeight[];
  /**
   * delegate stake removals are double indexed to avoid O(n) lookups when
   * removing stake map of (blockHeight, topic, delegator, reputer staked upon)
   * -> (list of reputers delegated upon and info) to have stake removed at that
   * block
   */
  delegateStakeRemovalsByBlock: BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo[];
  /**
   * key set of (delegator, reputer, topicId, blockHeight) to existence of a
   * removal in the forwards map
   */
  delegateStakeRemovalsByActor: DelegatorReputerTopicIdBlockHeight[];
  /**
   * / MISC GLOBAL STATE
   * map of (topic, worker) -> inference
   */
  inferences: TopicIdActorIdInference[];
  /** map of (topic, worker) -> forecast[] */
  forecasts: TopicIdActorIdForecast[];
  /** map of worker id to node data about that worker */
  workers: LibP2pKeyAndOffchainNode[];
  /** map of reputer id to node data about that reputer */
  reputers: LibP2pKeyAndOffchainNode[];
  /** fee revenue collected by a topic over the course of the last reward cadence */
  topicFeeRevenue: TopicIdAndInt[];
  /** store previous weights for exponential moving average in rewards calc */
  previousTopicWeight: TopicIdAndDec[];
  /** map of (topic, block_height) -> Inference */
  allInferences: TopicIdBlockHeightInferences[];
  /** map of (topic, block_height) -> Forecast */
  allForecasts: TopicIdBlockHeightForecasts[];
  /**
   * map of (topic, block_height) -> ReputerValueBundles (1 per reputer active
   * at that time)
   */
  allLossBundles: TopicIdBlockHeightReputerValueBundles[];
  /**
   * map of (topic, block_height) -> ValueBundle (1 network wide bundle per
   * timestep)
   */
  networkLossBundles: TopicIdBlockHeightValueBundles[];
  /**
   * Percentage of all rewards, paid out to staked reputers, during the previous
   * reward cadence. Used by mint module
   */
  previousPercentageRewardToStakedReputers: string;
  /** map of open worker nonce windows for topics on particular block heights */
  openWorkerWindows: BlockHeightAndTopicIds[];
  /** map of (topic) -> unfulfilled nonces */
  unfulfilledWorkerNonces: TopicIdAndNonces[];
  /** map of (topic) -> unfulfilled nonces */
  unfulfilledReputerNonces: TopicIdAndReputerRequestNonces[];
  /** map of (topic) -> last dripped block */
  lastDripBlock: TopicIdAndBlockHeight[];
  /**
   * / REGRETS
   * map of (topic, worker) -> regret of worker from comparing loss of worker
   * relative to loss of other inferers
   */
  latestInfererNetworkRegrets: TopicIdActorIdTimeStampedValue[];
  /**
   * map of (topic, worker) -> regret of worker from comparing loss of worker
   * relative to loss of other forecasters
   */
  latestForecasterNetworkRegrets: TopicIdActorIdTimeStampedValue[];
  /**
   * map of (topic, forecaster, inferer) -> R^+_{ij_kk} regret of forecaster
   * loss from comparing one-in loss with all network inferer (3rd index)
   * regrets L_ij made under the regime of the one-in forecaster (2nd index)
   */
  latestOneInForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
  /**
   * the forecaster (2nd index) regrets made under the regime of the same
   * forecaster as a one-in forecaster
   */
  latestNaiveInfererNetworkRegrets: TopicIdActorIdTimeStampedValue[];
  latestOneOutInfererInfererNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
  latestOneOutInfererForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
  latestOneOutForecasterInfererNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
  latestOneOutForecasterForecasterNetworkRegrets: TopicIdActorIdActorIdTimeStampedValue[];
  /** / WHITELISTS */
  coreTeamAddresses: string[];
  /** / RECORD COMMITS */
  topicLastWorkerCommit: TopicIdTimestampedActorNonce[];
  topicLastReputerCommit: TopicIdTimestampedActorNonce[];
  /** ACTIVE TOPIC */
  topicToNextPossibleChurningBlock: TopicIdAndBlockHeight[];
  blockToActiveTopics: BlockHeightTopicIds[];
  blockToLowestActiveTopicWeight: BlockHeightTopicIdWeightPair[];
  /** EMA */
  previousTopicQuantileInfererScoreEma: TopicIdAndDec[];
  previousTopicQuantileForecasterScoreEma: TopicIdAndDec[];
  previousTopicQuantileReputerScoreEma: TopicIdAndDec[];
}

export interface TopicIdAndTopic {
  TopicId: string;
  Topic?: Topic | undefined;
}

export interface TopicAndActorId {
  TopicId: string;
  ActorId: string;
}

export interface TopicIdAndBlockHeight {
  TopicId: string;
  BlockHeight: string;
}

export interface BlockHeightAndTopicIds {
  BlockHeight: string;
  TopicIds: string[];
}

export interface TopicIdBlockHeightScores {
  TopicId: string;
  BlockHeight: string;
  Scores?: Scores | undefined;
}

export interface TopicIdActorIdScore {
  TopicId: string;
  ActorId: string;
  Score?: Score | undefined;
}

export interface TopicIdActorIdListeningCoefficient {
  TopicId: string;
  ActorId: string;
  ListeningCoefficient?: ListeningCoefficient | undefined;
}

export interface TopicIdActorIdDec {
  TopicId: string;
  ActorId: string;
  Dec: string;
}

export interface TopicIdAndInt {
  TopicId: string;
  Int: string;
}

export interface TopicIdActorIdInt {
  TopicId: string;
  ActorId: string;
  Int: string;
}

export interface TopicIdDelegatorReputerDelegatorInfo {
  TopicId: string;
  Delegator: string;
  Reputer: string;
  DelegatorInfo?: DelegatorInfo | undefined;
}

export interface BlockHeightTopicIdReputerStakeRemovalInfo {
  BlockHeight: string;
  TopicId: string;
  Reputer: string;
  StakeRemovalInfo?: StakeRemovalInfo | undefined;
}

export interface ActorIdTopicIdBlockHeight {
  ActorId: string;
  TopicId: string;
  BlockHeight: string;
}

export interface BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo {
  BlockHeight: string;
  TopicId: string;
  Delegator: string;
  Reputer: string;
  DelegateStakeRemovalInfo?: DelegateStakeRemovalInfo | undefined;
}

export interface DelegatorReputerTopicIdBlockHeight {
  Delegator: string;
  Reputer: string;
  TopicId: string;
  BlockHeight: string;
}

export interface TopicIdActorIdInference {
  TopicId: string;
  ActorId: string;
  Inference?: Inference | undefined;
}

export interface TopicIdActorIdForecast {
  TopicId: string;
  ActorId: string;
  Forecast?: Forecast | undefined;
}

export interface LibP2pKeyAndOffchainNode {
  LibP2pKey: string;
  OffchainNode?: OffchainNode | undefined;
}

export interface TopicIdAndDec {
  TopicId: string;
  Dec: string;
}

export interface TopicIdBlockHeightInferences {
  TopicId: string;
  BlockHeight: string;
  Inferences?: Inferences | undefined;
}

export interface TopicIdBlockHeightForecasts {
  TopicId: string;
  BlockHeight: string;
  Forecasts?: Forecasts | undefined;
}

export interface TopicIdBlockHeightReputerValueBundles {
  TopicId: string;
  BlockHeight: string;
  ReputerValueBundles?: ReputerValueBundles | undefined;
}

export interface TopicIdBlockHeightValueBundles {
  TopicId: string;
  BlockHeight: string;
  ValueBundle?: ValueBundle | undefined;
}

export interface TopicIdAndNonces {
  TopicId: string;
  Nonces?: Nonces | undefined;
}

export interface TopicIdAndReputerRequestNonces {
  TopicId: string;
  ReputerRequestNonces?: ReputerRequestNonces | undefined;
}

export interface TopicIdActorIdTimeStampedValue {
  TopicId: string;
  ActorId: string;
  TimestampedValue?: TimestampedValue | undefined;
}

export interface TopicIdActorIdActorIdTimeStampedValue {
  TopicId: string;
  ActorId1: string;
  ActorId2: string;
  TimestampedValue?: TimestampedValue | undefined;
}

export interface TopicIdTimestampedActorNonce {
  TopicId: string;
  TimestampedActorNonce?: TimestampedActorNonce | undefined;
}

export interface BlockHeightTopicIds {
  BlockHeight: string;
  TopicIds?: TopicIds | undefined;
}

export interface BlockHeightTopicIdWeightPair {
  BlockHeight: string;
  TopicWeight?: TopicIdWeightPair | undefined;
}

function createBaseGenesisState(): GenesisState {
  return {
    params: undefined,
    nextTopicId: "0",
    topics: [],
    activeTopics: [],
    rewardableTopics: [],
    topicWorkers: [],
    topicReputers: [],
    topicRewardNonce: [],
    infererScoresByBlock: [],
    forecasterScoresByBlock: [],
    reputerScoresByBlock: [],
    infererScoreEmas: [],
    forecasterScoreEmas: [],
    reputerScoreEmas: [],
    reputerListeningCoefficient: [],
    previousReputerRewardFraction: [],
    previousInferenceRewardFraction: [],
    previousForecastRewardFraction: [],
    previousForecasterScoreRatio: [],
    totalStake: "",
    topicStake: [],
    stakeReputerAuthority: [],
    stakeSumFromDelegator: [],
    delegatedStakes: [],
    stakeFromDelegatorsUponReputer: [],
    delegateRewardPerShare: [],
    stakeRemovalsByBlock: [],
    stakeRemovalsByActor: [],
    delegateStakeRemovalsByBlock: [],
    delegateStakeRemovalsByActor: [],
    inferences: [],
    forecasts: [],
    workers: [],
    reputers: [],
    topicFeeRevenue: [],
    previousTopicWeight: [],
    allInferences: [],
    allForecasts: [],
    allLossBundles: [],
    networkLossBundles: [],
    previousPercentageRewardToStakedReputers: "",
    openWorkerWindows: [],
    unfulfilledWorkerNonces: [],
    unfulfilledReputerNonces: [],
    lastDripBlock: [],
    latestInfererNetworkRegrets: [],
    latestForecasterNetworkRegrets: [],
    latestOneInForecasterNetworkRegrets: [],
    latestNaiveInfererNetworkRegrets: [],
    latestOneOutInfererInfererNetworkRegrets: [],
    latestOneOutInfererForecasterNetworkRegrets: [],
    latestOneOutForecasterInfererNetworkRegrets: [],
    latestOneOutForecasterForecasterNetworkRegrets: [],
    coreTeamAddresses: [],
    topicLastWorkerCommit: [],
    topicLastReputerCommit: [],
    topicToNextPossibleChurningBlock: [],
    blockToActiveTopics: [],
    blockToLowestActiveTopicWeight: [],
    previousTopicQuantileInfererScoreEma: [],
    previousTopicQuantileForecasterScoreEma: [],
    previousTopicQuantileReputerScoreEma: [],
  };
}

export const GenesisState: MessageFns<GenesisState> = {
  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.nextTopicId !== "0") {
      writer.uint32(24).uint64(message.nextTopicId);
    }
    for (const v of message.topics) {
      TopicIdAndTopic.encode(v!, writer.uint32(34).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.activeTopics) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.rewardableTopics) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.topicWorkers) {
      TopicAndActorId.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.topicReputers) {
      TopicAndActorId.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.topicRewardNonce) {
      TopicIdAndBlockHeight.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.infererScoresByBlock) {
      TopicIdBlockHeightScores.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.forecasterScoresByBlock) {
      TopicIdBlockHeightScores.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.reputerScoresByBlock) {
      TopicIdBlockHeightScores.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.infererScoreEmas) {
      TopicIdActorIdScore.encode(v!, writer.uint32(482).fork()).join();
    }
    for (const v of message.forecasterScoreEmas) {
      TopicIdActorIdScore.encode(v!, writer.uint32(490).fork()).join();
    }
    for (const v of message.reputerScoreEmas) {
      TopicIdActorIdScore.encode(v!, writer.uint32(498).fork()).join();
    }
    for (const v of message.reputerListeningCoefficient) {
      TopicIdActorIdListeningCoefficient.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.previousReputerRewardFraction) {
      TopicIdActorIdDec.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.previousInferenceRewardFraction) {
      TopicIdActorIdDec.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.previousForecastRewardFraction) {
      TopicIdActorIdDec.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.previousForecasterScoreRatio) {
      TopicIdAndDec.encode(v!, writer.uint32(162).fork()).join();
    }
    if (message.totalStake !== "") {
      writer.uint32(170).string(message.totalStake);
    }
    for (const v of message.topicStake) {
      TopicIdAndInt.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.stakeReputerAuthority) {
      TopicIdActorIdInt.encode(v!, writer.uint32(186).fork()).join();
    }
    for (const v of message.stakeSumFromDelegator) {
      TopicIdActorIdInt.encode(v!, writer.uint32(194).fork()).join();
    }
    for (const v of message.delegatedStakes) {
      TopicIdDelegatorReputerDelegatorInfo.encode(v!, writer.uint32(202).fork()).join();
    }
    for (const v of message.stakeFromDelegatorsUponReputer) {
      TopicIdActorIdInt.encode(v!, writer.uint32(210).fork()).join();
    }
    for (const v of message.delegateRewardPerShare) {
      TopicIdActorIdDec.encode(v!, writer.uint32(218).fork()).join();
    }
    for (const v of message.stakeRemovalsByBlock) {
      BlockHeightTopicIdReputerStakeRemovalInfo.encode(v!, writer.uint32(226).fork()).join();
    }
    for (const v of message.stakeRemovalsByActor) {
      ActorIdTopicIdBlockHeight.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.delegateStakeRemovalsByBlock) {
      BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo.encode(v!, writer.uint32(242).fork()).join();
    }
    for (const v of message.delegateStakeRemovalsByActor) {
      DelegatorReputerTopicIdBlockHeight.encode(v!, writer.uint32(250).fork()).join();
    }
    for (const v of message.inferences) {
      TopicIdActorIdInference.encode(v!, writer.uint32(258).fork()).join();
    }
    for (const v of message.forecasts) {
      TopicIdActorIdForecast.encode(v!, writer.uint32(266).fork()).join();
    }
    for (const v of message.workers) {
      LibP2pKeyAndOffchainNode.encode(v!, writer.uint32(274).fork()).join();
    }
    for (const v of message.reputers) {
      LibP2pKeyAndOffchainNode.encode(v!, writer.uint32(282).fork()).join();
    }
    for (const v of message.topicFeeRevenue) {
      TopicIdAndInt.encode(v!, writer.uint32(290).fork()).join();
    }
    for (const v of message.previousTopicWeight) {
      TopicIdAndDec.encode(v!, writer.uint32(298).fork()).join();
    }
    for (const v of message.allInferences) {
      TopicIdBlockHeightInferences.encode(v!, writer.uint32(306).fork()).join();
    }
    for (const v of message.allForecasts) {
      TopicIdBlockHeightForecasts.encode(v!, writer.uint32(314).fork()).join();
    }
    for (const v of message.allLossBundles) {
      TopicIdBlockHeightReputerValueBundles.encode(v!, writer.uint32(322).fork()).join();
    }
    for (const v of message.networkLossBundles) {
      TopicIdBlockHeightValueBundles.encode(v!, writer.uint32(330).fork()).join();
    }
    if (message.previousPercentageRewardToStakedReputers !== "") {
      writer.uint32(338).string(message.previousPercentageRewardToStakedReputers);
    }
    for (const v of message.openWorkerWindows) {
      BlockHeightAndTopicIds.encode(v!, writer.uint32(442).fork()).join();
    }
    for (const v of message.unfulfilledWorkerNonces) {
      TopicIdAndNonces.encode(v!, writer.uint32(346).fork()).join();
    }
    for (const v of message.unfulfilledReputerNonces) {
      TopicIdAndReputerRequestNonces.encode(v!, writer.uint32(354).fork()).join();
    }
    for (const v of message.lastDripBlock) {
      TopicIdAndBlockHeight.encode(v!, writer.uint32(450).fork()).join();
    }
    for (const v of message.latestInfererNetworkRegrets) {
      TopicIdActorIdTimeStampedValue.encode(v!, writer.uint32(362).fork()).join();
    }
    for (const v of message.latestForecasterNetworkRegrets) {
      TopicIdActorIdTimeStampedValue.encode(v!, writer.uint32(370).fork()).join();
    }
    for (const v of message.latestOneInForecasterNetworkRegrets) {
      TopicIdActorIdActorIdTimeStampedValue.encode(v!, writer.uint32(378).fork()).join();
    }
    for (const v of message.latestNaiveInfererNetworkRegrets) {
      TopicIdActorIdTimeStampedValue.encode(v!, writer.uint32(386).fork()).join();
    }
    for (const v of message.latestOneOutInfererInfererNetworkRegrets) {
      TopicIdActorIdActorIdTimeStampedValue.encode(v!, writer.uint32(394).fork()).join();
    }
    for (const v of message.latestOneOutInfererForecasterNetworkRegrets) {
      TopicIdActorIdActorIdTimeStampedValue.encode(v!, writer.uint32(402).fork()).join();
    }
    for (const v of message.latestOneOutForecasterInfererNetworkRegrets) {
      TopicIdActorIdActorIdTimeStampedValue.encode(v!, writer.uint32(410).fork()).join();
    }
    for (const v of message.latestOneOutForecasterForecasterNetworkRegrets) {
      TopicIdActorIdActorIdTimeStampedValue.encode(v!, writer.uint32(418).fork()).join();
    }
    for (const v of message.coreTeamAddresses) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.topicLastWorkerCommit) {
      TopicIdTimestampedActorNonce.encode(v!, writer.uint32(426).fork()).join();
    }
    for (const v of message.topicLastReputerCommit) {
      TopicIdTimestampedActorNonce.encode(v!, writer.uint32(434).fork()).join();
    }
    for (const v of message.topicToNextPossibleChurningBlock) {
      TopicIdAndBlockHeight.encode(v!, writer.uint32(458).fork()).join();
    }
    for (const v of message.blockToActiveTopics) {
      BlockHeightTopicIds.encode(v!, writer.uint32(466).fork()).join();
    }
    for (const v of message.blockToLowestActiveTopicWeight) {
      BlockHeightTopicIdWeightPair.encode(v!, writer.uint32(474).fork()).join();
    }
    for (const v of message.previousTopicQuantileInfererScoreEma) {
      TopicIdAndDec.encode(v!, writer.uint32(506).fork()).join();
    }
    for (const v of message.previousTopicQuantileForecasterScoreEma) {
      TopicIdAndDec.encode(v!, writer.uint32(514).fork()).join();
    }
    for (const v of message.previousTopicQuantileReputerScoreEma) {
      TopicIdAndDec.encode(v!, writer.uint32(522).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nextTopicId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.topics.push(TopicIdAndTopic.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.activeTopics.push(reader.uint64().toString());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.activeTopics.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag === 48) {
            message.rewardableTopics.push(reader.uint64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.rewardableTopics.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.topicWorkers.push(TopicAndActorId.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.topicReputers.push(TopicAndActorId.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.topicRewardNonce.push(TopicIdAndBlockHeight.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.infererScoresByBlock.push(TopicIdBlockHeightScores.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.forecasterScoresByBlock.push(TopicIdBlockHeightScores.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.reputerScoresByBlock.push(TopicIdBlockHeightScores.decode(reader, reader.uint32()));
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.infererScoreEmas.push(TopicIdActorIdScore.decode(reader, reader.uint32()));
          continue;
        }
        case 61: {
          if (tag !== 490) {
            break;
          }

          message.forecasterScoreEmas.push(TopicIdActorIdScore.decode(reader, reader.uint32()));
          continue;
        }
        case 62: {
          if (tag !== 498) {
            break;
          }

          message.reputerScoreEmas.push(TopicIdActorIdScore.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.reputerListeningCoefficient.push(TopicIdActorIdListeningCoefficient.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.previousReputerRewardFraction.push(TopicIdActorIdDec.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.previousInferenceRewardFraction.push(TopicIdActorIdDec.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.previousForecastRewardFraction.push(TopicIdActorIdDec.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.previousForecasterScoreRatio.push(TopicIdAndDec.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.totalStake = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.topicStake.push(TopicIdAndInt.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.stakeReputerAuthority.push(TopicIdActorIdInt.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.stakeSumFromDelegator.push(TopicIdActorIdInt.decode(reader, reader.uint32()));
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.delegatedStakes.push(TopicIdDelegatorReputerDelegatorInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.stakeFromDelegatorsUponReputer.push(TopicIdActorIdInt.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.delegateRewardPerShare.push(TopicIdActorIdDec.decode(reader, reader.uint32()));
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.stakeRemovalsByBlock.push(BlockHeightTopicIdReputerStakeRemovalInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.stakeRemovalsByActor.push(ActorIdTopicIdBlockHeight.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.delegateStakeRemovalsByBlock.push(
            BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.delegateStakeRemovalsByActor.push(DelegatorReputerTopicIdBlockHeight.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.inferences.push(TopicIdActorIdInference.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.forecasts.push(TopicIdActorIdForecast.decode(reader, reader.uint32()));
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.workers.push(LibP2pKeyAndOffchainNode.decode(reader, reader.uint32()));
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.reputers.push(LibP2pKeyAndOffchainNode.decode(reader, reader.uint32()));
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.topicFeeRevenue.push(TopicIdAndInt.decode(reader, reader.uint32()));
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.previousTopicWeight.push(TopicIdAndDec.decode(reader, reader.uint32()));
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.allInferences.push(TopicIdBlockHeightInferences.decode(reader, reader.uint32()));
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.allForecasts.push(TopicIdBlockHeightForecasts.decode(reader, reader.uint32()));
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.allLossBundles.push(TopicIdBlockHeightReputerValueBundles.decode(reader, reader.uint32()));
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.networkLossBundles.push(TopicIdBlockHeightValueBundles.decode(reader, reader.uint32()));
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.previousPercentageRewardToStakedReputers = reader.string();
          continue;
        }
        case 55: {
          if (tag !== 442) {
            break;
          }

          message.openWorkerWindows.push(BlockHeightAndTopicIds.decode(reader, reader.uint32()));
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.unfulfilledWorkerNonces.push(TopicIdAndNonces.decode(reader, reader.uint32()));
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.unfulfilledReputerNonces.push(TopicIdAndReputerRequestNonces.decode(reader, reader.uint32()));
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.lastDripBlock.push(TopicIdAndBlockHeight.decode(reader, reader.uint32()));
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.latestInfererNetworkRegrets.push(TopicIdActorIdTimeStampedValue.decode(reader, reader.uint32()));
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.latestForecasterNetworkRegrets.push(TopicIdActorIdTimeStampedValue.decode(reader, reader.uint32()));
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.latestOneInForecasterNetworkRegrets.push(
            TopicIdActorIdActorIdTimeStampedValue.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.latestNaiveInfererNetworkRegrets.push(TopicIdActorIdTimeStampedValue.decode(reader, reader.uint32()));
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.latestOneOutInfererInfererNetworkRegrets.push(
            TopicIdActorIdActorIdTimeStampedValue.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.latestOneOutInfererForecasterNetworkRegrets.push(
            TopicIdActorIdActorIdTimeStampedValue.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.latestOneOutForecasterInfererNetworkRegrets.push(
            TopicIdActorIdActorIdTimeStampedValue.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.latestOneOutForecasterForecasterNetworkRegrets.push(
            TopicIdActorIdActorIdTimeStampedValue.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.coreTeamAddresses.push(reader.string());
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.topicLastWorkerCommit.push(TopicIdTimestampedActorNonce.decode(reader, reader.uint32()));
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.topicLastReputerCommit.push(TopicIdTimestampedActorNonce.decode(reader, reader.uint32()));
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.topicToNextPossibleChurningBlock.push(TopicIdAndBlockHeight.decode(reader, reader.uint32()));
          continue;
        }
        case 58: {
          if (tag !== 466) {
            break;
          }

          message.blockToActiveTopics.push(BlockHeightTopicIds.decode(reader, reader.uint32()));
          continue;
        }
        case 59: {
          if (tag !== 474) {
            break;
          }

          message.blockToLowestActiveTopicWeight.push(BlockHeightTopicIdWeightPair.decode(reader, reader.uint32()));
          continue;
        }
        case 63: {
          if (tag !== 506) {
            break;
          }

          message.previousTopicQuantileInfererScoreEma.push(TopicIdAndDec.decode(reader, reader.uint32()));
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.previousTopicQuantileForecasterScoreEma.push(TopicIdAndDec.decode(reader, reader.uint32()));
          continue;
        }
        case 65: {
          if (tag !== 522) {
            break;
          }

          message.previousTopicQuantileReputerScoreEma.push(TopicIdAndDec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
      nextTopicId: isSet(object.nextTopicId) ? globalThis.String(object.nextTopicId) : "0",
      topics: globalThis.Array.isArray(object?.topics)
        ? object.topics.map((e: any) => TopicIdAndTopic.fromJSON(e))
        : [],
      activeTopics: globalThis.Array.isArray(object?.activeTopics)
        ? object.activeTopics.map((e: any) => globalThis.String(e))
        : [],
      rewardableTopics: globalThis.Array.isArray(object?.rewardableTopics)
        ? object.rewardableTopics.map((e: any) => globalThis.String(e))
        : [],
      topicWorkers: globalThis.Array.isArray(object?.topicWorkers)
        ? object.topicWorkers.map((e: any) => TopicAndActorId.fromJSON(e))
        : [],
      topicReputers: globalThis.Array.isArray(object?.topicReputers)
        ? object.topicReputers.map((e: any) => TopicAndActorId.fromJSON(e))
        : [],
      topicRewardNonce: globalThis.Array.isArray(object?.topicRewardNonce)
        ? object.topicRewardNonce.map((e: any) => TopicIdAndBlockHeight.fromJSON(e))
        : [],
      infererScoresByBlock: globalThis.Array.isArray(object?.infererScoresByBlock)
        ? object.infererScoresByBlock.map((e: any) => TopicIdBlockHeightScores.fromJSON(e))
        : [],
      forecasterScoresByBlock: globalThis.Array.isArray(object?.forecasterScoresByBlock)
        ? object.forecasterScoresByBlock.map((e: any) => TopicIdBlockHeightScores.fromJSON(e))
        : [],
      reputerScoresByBlock: globalThis.Array.isArray(object?.reputerScoresByBlock)
        ? object.reputerScoresByBlock.map((e: any) => TopicIdBlockHeightScores.fromJSON(e))
        : [],
      infererScoreEmas: globalThis.Array.isArray(object?.infererScoreEmas)
        ? object.infererScoreEmas.map((e: any) => TopicIdActorIdScore.fromJSON(e))
        : [],
      forecasterScoreEmas: globalThis.Array.isArray(object?.forecasterScoreEmas)
        ? object.forecasterScoreEmas.map((e: any) => TopicIdActorIdScore.fromJSON(e))
        : [],
      reputerScoreEmas: globalThis.Array.isArray(object?.reputerScoreEmas)
        ? object.reputerScoreEmas.map((e: any) => TopicIdActorIdScore.fromJSON(e))
        : [],
      reputerListeningCoefficient: globalThis.Array.isArray(object?.reputerListeningCoefficient)
        ? object.reputerListeningCoefficient.map((e: any) => TopicIdActorIdListeningCoefficient.fromJSON(e))
        : [],
      previousReputerRewardFraction: globalThis.Array.isArray(object?.previousReputerRewardFraction)
        ? object.previousReputerRewardFraction.map((e: any) => TopicIdActorIdDec.fromJSON(e))
        : [],
      previousInferenceRewardFraction: globalThis.Array.isArray(object?.previousInferenceRewardFraction)
        ? object.previousInferenceRewardFraction.map((e: any) => TopicIdActorIdDec.fromJSON(e))
        : [],
      previousForecastRewardFraction: globalThis.Array.isArray(object?.previousForecastRewardFraction)
        ? object.previousForecastRewardFraction.map((e: any) => TopicIdActorIdDec.fromJSON(e))
        : [],
      previousForecasterScoreRatio: globalThis.Array.isArray(object?.previousForecasterScoreRatio)
        ? object.previousForecasterScoreRatio.map((e: any) => TopicIdAndDec.fromJSON(e))
        : [],
      totalStake: isSet(object.totalStake) ? globalThis.String(object.totalStake) : "",
      topicStake: globalThis.Array.isArray(object?.topicStake)
        ? object.topicStake.map((e: any) => TopicIdAndInt.fromJSON(e))
        : [],
      stakeReputerAuthority: globalThis.Array.isArray(object?.stakeReputerAuthority)
        ? object.stakeReputerAuthority.map((e: any) => TopicIdActorIdInt.fromJSON(e))
        : [],
      stakeSumFromDelegator: globalThis.Array.isArray(object?.stakeSumFromDelegator)
        ? object.stakeSumFromDelegator.map((e: any) => TopicIdActorIdInt.fromJSON(e))
        : [],
      delegatedStakes: globalThis.Array.isArray(object?.delegatedStakes)
        ? object.delegatedStakes.map((e: any) => TopicIdDelegatorReputerDelegatorInfo.fromJSON(e))
        : [],
      stakeFromDelegatorsUponReputer: globalThis.Array.isArray(object?.stakeFromDelegatorsUponReputer)
        ? object.stakeFromDelegatorsUponReputer.map((e: any) => TopicIdActorIdInt.fromJSON(e))
        : [],
      delegateRewardPerShare: globalThis.Array.isArray(object?.delegateRewardPerShare)
        ? object.delegateRewardPerShare.map((e: any) => TopicIdActorIdDec.fromJSON(e))
        : [],
      stakeRemovalsByBlock: globalThis.Array.isArray(object?.stakeRemovalsByBlock)
        ? object.stakeRemovalsByBlock.map((e: any) => BlockHeightTopicIdReputerStakeRemovalInfo.fromJSON(e))
        : [],
      stakeRemovalsByActor: globalThis.Array.isArray(object?.stakeRemovalsByActor)
        ? object.stakeRemovalsByActor.map((e: any) => ActorIdTopicIdBlockHeight.fromJSON(e))
        : [],
      delegateStakeRemovalsByBlock: globalThis.Array.isArray(object?.delegateStakeRemovalsByBlock)
        ? object.delegateStakeRemovalsByBlock.map((e: any) =>
          BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo.fromJSON(e)
        )
        : [],
      delegateStakeRemovalsByActor: globalThis.Array.isArray(object?.delegateStakeRemovalsByActor)
        ? object.delegateStakeRemovalsByActor.map((e: any) => DelegatorReputerTopicIdBlockHeight.fromJSON(e))
        : [],
      inferences: globalThis.Array.isArray(object?.inferences)
        ? object.inferences.map((e: any) => TopicIdActorIdInference.fromJSON(e))
        : [],
      forecasts: globalThis.Array.isArray(object?.forecasts)
        ? object.forecasts.map((e: any) => TopicIdActorIdForecast.fromJSON(e))
        : [],
      workers: globalThis.Array.isArray(object?.workers)
        ? object.workers.map((e: any) => LibP2pKeyAndOffchainNode.fromJSON(e))
        : [],
      reputers: globalThis.Array.isArray(object?.reputers)
        ? object.reputers.map((e: any) => LibP2pKeyAndOffchainNode.fromJSON(e))
        : [],
      topicFeeRevenue: globalThis.Array.isArray(object?.topicFeeRevenue)
        ? object.topicFeeRevenue.map((e: any) => TopicIdAndInt.fromJSON(e))
        : [],
      previousTopicWeight: globalThis.Array.isArray(object?.previousTopicWeight)
        ? object.previousTopicWeight.map((e: any) => TopicIdAndDec.fromJSON(e))
        : [],
      allInferences: globalThis.Array.isArray(object?.allInferences)
        ? object.allInferences.map((e: any) => TopicIdBlockHeightInferences.fromJSON(e))
        : [],
      allForecasts: globalThis.Array.isArray(object?.allForecasts)
        ? object.allForecasts.map((e: any) => TopicIdBlockHeightForecasts.fromJSON(e))
        : [],
      allLossBundles: globalThis.Array.isArray(object?.allLossBundles)
        ? object.allLossBundles.map((e: any) => TopicIdBlockHeightReputerValueBundles.fromJSON(e))
        : [],
      networkLossBundles: globalThis.Array.isArray(object?.networkLossBundles)
        ? object.networkLossBundles.map((e: any) => TopicIdBlockHeightValueBundles.fromJSON(e))
        : [],
      previousPercentageRewardToStakedReputers: isSet(object.previousPercentageRewardToStakedReputers)
        ? globalThis.String(object.previousPercentageRewardToStakedReputers)
        : "",
      openWorkerWindows: globalThis.Array.isArray(object?.openWorkerWindows)
        ? object.openWorkerWindows.map((e: any) => BlockHeightAndTopicIds.fromJSON(e))
        : [],
      unfulfilledWorkerNonces: globalThis.Array.isArray(object?.unfulfilledWorkerNonces)
        ? object.unfulfilledWorkerNonces.map((e: any) => TopicIdAndNonces.fromJSON(e))
        : [],
      unfulfilledReputerNonces: globalThis.Array.isArray(object?.unfulfilledReputerNonces)
        ? object.unfulfilledReputerNonces.map((e: any) => TopicIdAndReputerRequestNonces.fromJSON(e))
        : [],
      lastDripBlock: globalThis.Array.isArray(object?.lastDripBlock)
        ? object.lastDripBlock.map((e: any) => TopicIdAndBlockHeight.fromJSON(e))
        : [],
      latestInfererNetworkRegrets: globalThis.Array.isArray(object?.latestInfererNetworkRegrets)
        ? object.latestInfererNetworkRegrets.map((e: any) => TopicIdActorIdTimeStampedValue.fromJSON(e))
        : [],
      latestForecasterNetworkRegrets: globalThis.Array.isArray(object?.latestForecasterNetworkRegrets)
        ? object.latestForecasterNetworkRegrets.map((e: any) => TopicIdActorIdTimeStampedValue.fromJSON(e))
        : [],
      latestOneInForecasterNetworkRegrets: globalThis.Array.isArray(object?.latestOneInForecasterNetworkRegrets)
        ? object.latestOneInForecasterNetworkRegrets.map((e: any) => TopicIdActorIdActorIdTimeStampedValue.fromJSON(e))
        : [],
      latestNaiveInfererNetworkRegrets: globalThis.Array.isArray(object?.latestNaiveInfererNetworkRegrets)
        ? object.latestNaiveInfererNetworkRegrets.map((e: any) => TopicIdActorIdTimeStampedValue.fromJSON(e))
        : [],
      latestOneOutInfererInfererNetworkRegrets:
        globalThis.Array.isArray(object?.latestOneOutInfererInfererNetworkRegrets)
          ? object.latestOneOutInfererInfererNetworkRegrets.map((e: any) =>
            TopicIdActorIdActorIdTimeStampedValue.fromJSON(e)
          )
          : [],
      latestOneOutInfererForecasterNetworkRegrets:
        globalThis.Array.isArray(object?.latestOneOutInfererForecasterNetworkRegrets)
          ? object.latestOneOutInfererForecasterNetworkRegrets.map((e: any) =>
            TopicIdActorIdActorIdTimeStampedValue.fromJSON(e)
          )
          : [],
      latestOneOutForecasterInfererNetworkRegrets:
        globalThis.Array.isArray(object?.latestOneOutForecasterInfererNetworkRegrets)
          ? object.latestOneOutForecasterInfererNetworkRegrets.map((e: any) =>
            TopicIdActorIdActorIdTimeStampedValue.fromJSON(e)
          )
          : [],
      latestOneOutForecasterForecasterNetworkRegrets:
        globalThis.Array.isArray(object?.latestOneOutForecasterForecasterNetworkRegrets)
          ? object.latestOneOutForecasterForecasterNetworkRegrets.map((e: any) =>
            TopicIdActorIdActorIdTimeStampedValue.fromJSON(e)
          )
          : [],
      coreTeamAddresses: globalThis.Array.isArray(object?.coreTeamAddresses)
        ? object.coreTeamAddresses.map((e: any) => globalThis.String(e))
        : [],
      topicLastWorkerCommit: globalThis.Array.isArray(object?.topicLastWorkerCommit)
        ? object.topicLastWorkerCommit.map((e: any) => TopicIdTimestampedActorNonce.fromJSON(e))
        : [],
      topicLastReputerCommit: globalThis.Array.isArray(object?.topicLastReputerCommit)
        ? object.topicLastReputerCommit.map((e: any) => TopicIdTimestampedActorNonce.fromJSON(e))
        : [],
      topicToNextPossibleChurningBlock: globalThis.Array.isArray(object?.topicToNextPossibleChurningBlock)
        ? object.topicToNextPossibleChurningBlock.map((e: any) => TopicIdAndBlockHeight.fromJSON(e))
        : [],
      blockToActiveTopics: globalThis.Array.isArray(object?.blockToActiveTopics)
        ? object.blockToActiveTopics.map((e: any) => BlockHeightTopicIds.fromJSON(e))
        : [],
      blockToLowestActiveTopicWeight: globalThis.Array.isArray(object?.blockToLowestActiveTopicWeight)
        ? object.blockToLowestActiveTopicWeight.map((e: any) => BlockHeightTopicIdWeightPair.fromJSON(e))
        : [],
      previousTopicQuantileInfererScoreEma: globalThis.Array.isArray(object?.previousTopicQuantileInfererScoreEma)
        ? object.previousTopicQuantileInfererScoreEma.map((e: any) => TopicIdAndDec.fromJSON(e))
        : [],
      previousTopicQuantileForecasterScoreEma: globalThis.Array.isArray(object?.previousTopicQuantileForecasterScoreEma)
        ? object.previousTopicQuantileForecasterScoreEma.map((e: any) => TopicIdAndDec.fromJSON(e))
        : [],
      previousTopicQuantileReputerScoreEma: globalThis.Array.isArray(object?.previousTopicQuantileReputerScoreEma)
        ? object.previousTopicQuantileReputerScoreEma.map((e: any) => TopicIdAndDec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    if (message.nextTopicId !== "0") {
      obj.nextTopicId = message.nextTopicId;
    }
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => TopicIdAndTopic.toJSON(e));
    }
    if (message.activeTopics?.length) {
      obj.activeTopics = message.activeTopics;
    }
    if (message.rewardableTopics?.length) {
      obj.rewardableTopics = message.rewardableTopics;
    }
    if (message.topicWorkers?.length) {
      obj.topicWorkers = message.topicWorkers.map((e) => TopicAndActorId.toJSON(e));
    }
    if (message.topicReputers?.length) {
      obj.topicReputers = message.topicReputers.map((e) => TopicAndActorId.toJSON(e));
    }
    if (message.topicRewardNonce?.length) {
      obj.topicRewardNonce = message.topicRewardNonce.map((e) => TopicIdAndBlockHeight.toJSON(e));
    }
    if (message.infererScoresByBlock?.length) {
      obj.infererScoresByBlock = message.infererScoresByBlock.map((e) => TopicIdBlockHeightScores.toJSON(e));
    }
    if (message.forecasterScoresByBlock?.length) {
      obj.forecasterScoresByBlock = message.forecasterScoresByBlock.map((e) => TopicIdBlockHeightScores.toJSON(e));
    }
    if (message.reputerScoresByBlock?.length) {
      obj.reputerScoresByBlock = message.reputerScoresByBlock.map((e) => TopicIdBlockHeightScores.toJSON(e));
    }
    if (message.infererScoreEmas?.length) {
      obj.infererScoreEmas = message.infererScoreEmas.map((e) => TopicIdActorIdScore.toJSON(e));
    }
    if (message.forecasterScoreEmas?.length) {
      obj.forecasterScoreEmas = message.forecasterScoreEmas.map((e) => TopicIdActorIdScore.toJSON(e));
    }
    if (message.reputerScoreEmas?.length) {
      obj.reputerScoreEmas = message.reputerScoreEmas.map((e) => TopicIdActorIdScore.toJSON(e));
    }
    if (message.reputerListeningCoefficient?.length) {
      obj.reputerListeningCoefficient = message.reputerListeningCoefficient.map((e) =>
        TopicIdActorIdListeningCoefficient.toJSON(e)
      );
    }
    if (message.previousReputerRewardFraction?.length) {
      obj.previousReputerRewardFraction = message.previousReputerRewardFraction.map((e) => TopicIdActorIdDec.toJSON(e));
    }
    if (message.previousInferenceRewardFraction?.length) {
      obj.previousInferenceRewardFraction = message.previousInferenceRewardFraction.map((e) =>
        TopicIdActorIdDec.toJSON(e)
      );
    }
    if (message.previousForecastRewardFraction?.length) {
      obj.previousForecastRewardFraction = message.previousForecastRewardFraction.map((e) =>
        TopicIdActorIdDec.toJSON(e)
      );
    }
    if (message.previousForecasterScoreRatio?.length) {
      obj.previousForecasterScoreRatio = message.previousForecasterScoreRatio.map((e) => TopicIdAndDec.toJSON(e));
    }
    if (message.totalStake !== "") {
      obj.totalStake = message.totalStake;
    }
    if (message.topicStake?.length) {
      obj.topicStake = message.topicStake.map((e) => TopicIdAndInt.toJSON(e));
    }
    if (message.stakeReputerAuthority?.length) {
      obj.stakeReputerAuthority = message.stakeReputerAuthority.map((e) => TopicIdActorIdInt.toJSON(e));
    }
    if (message.stakeSumFromDelegator?.length) {
      obj.stakeSumFromDelegator = message.stakeSumFromDelegator.map((e) => TopicIdActorIdInt.toJSON(e));
    }
    if (message.delegatedStakes?.length) {
      obj.delegatedStakes = message.delegatedStakes.map((e) => TopicIdDelegatorReputerDelegatorInfo.toJSON(e));
    }
    if (message.stakeFromDelegatorsUponReputer?.length) {
      obj.stakeFromDelegatorsUponReputer = message.stakeFromDelegatorsUponReputer.map((e) =>
        TopicIdActorIdInt.toJSON(e)
      );
    }
    if (message.delegateRewardPerShare?.length) {
      obj.delegateRewardPerShare = message.delegateRewardPerShare.map((e) => TopicIdActorIdDec.toJSON(e));
    }
    if (message.stakeRemovalsByBlock?.length) {
      obj.stakeRemovalsByBlock = message.stakeRemovalsByBlock.map((e) =>
        BlockHeightTopicIdReputerStakeRemovalInfo.toJSON(e)
      );
    }
    if (message.stakeRemovalsByActor?.length) {
      obj.stakeRemovalsByActor = message.stakeRemovalsByActor.map((e) => ActorIdTopicIdBlockHeight.toJSON(e));
    }
    if (message.delegateStakeRemovalsByBlock?.length) {
      obj.delegateStakeRemovalsByBlock = message.delegateStakeRemovalsByBlock.map((e) =>
        BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo.toJSON(e)
      );
    }
    if (message.delegateStakeRemovalsByActor?.length) {
      obj.delegateStakeRemovalsByActor = message.delegateStakeRemovalsByActor.map((e) =>
        DelegatorReputerTopicIdBlockHeight.toJSON(e)
      );
    }
    if (message.inferences?.length) {
      obj.inferences = message.inferences.map((e) => TopicIdActorIdInference.toJSON(e));
    }
    if (message.forecasts?.length) {
      obj.forecasts = message.forecasts.map((e) => TopicIdActorIdForecast.toJSON(e));
    }
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => LibP2pKeyAndOffchainNode.toJSON(e));
    }
    if (message.reputers?.length) {
      obj.reputers = message.reputers.map((e) => LibP2pKeyAndOffchainNode.toJSON(e));
    }
    if (message.topicFeeRevenue?.length) {
      obj.topicFeeRevenue = message.topicFeeRevenue.map((e) => TopicIdAndInt.toJSON(e));
    }
    if (message.previousTopicWeight?.length) {
      obj.previousTopicWeight = message.previousTopicWeight.map((e) => TopicIdAndDec.toJSON(e));
    }
    if (message.allInferences?.length) {
      obj.allInferences = message.allInferences.map((e) => TopicIdBlockHeightInferences.toJSON(e));
    }
    if (message.allForecasts?.length) {
      obj.allForecasts = message.allForecasts.map((e) => TopicIdBlockHeightForecasts.toJSON(e));
    }
    if (message.allLossBundles?.length) {
      obj.allLossBundles = message.allLossBundles.map((e) => TopicIdBlockHeightReputerValueBundles.toJSON(e));
    }
    if (message.networkLossBundles?.length) {
      obj.networkLossBundles = message.networkLossBundles.map((e) => TopicIdBlockHeightValueBundles.toJSON(e));
    }
    if (message.previousPercentageRewardToStakedReputers !== "") {
      obj.previousPercentageRewardToStakedReputers = message.previousPercentageRewardToStakedReputers;
    }
    if (message.openWorkerWindows?.length) {
      obj.openWorkerWindows = message.openWorkerWindows.map((e) => BlockHeightAndTopicIds.toJSON(e));
    }
    if (message.unfulfilledWorkerNonces?.length) {
      obj.unfulfilledWorkerNonces = message.unfulfilledWorkerNonces.map((e) => TopicIdAndNonces.toJSON(e));
    }
    if (message.unfulfilledReputerNonces?.length) {
      obj.unfulfilledReputerNonces = message.unfulfilledReputerNonces.map((e) =>
        TopicIdAndReputerRequestNonces.toJSON(e)
      );
    }
    if (message.lastDripBlock?.length) {
      obj.lastDripBlock = message.lastDripBlock.map((e) => TopicIdAndBlockHeight.toJSON(e));
    }
    if (message.latestInfererNetworkRegrets?.length) {
      obj.latestInfererNetworkRegrets = message.latestInfererNetworkRegrets.map((e) =>
        TopicIdActorIdTimeStampedValue.toJSON(e)
      );
    }
    if (message.latestForecasterNetworkRegrets?.length) {
      obj.latestForecasterNetworkRegrets = message.latestForecasterNetworkRegrets.map((e) =>
        TopicIdActorIdTimeStampedValue.toJSON(e)
      );
    }
    if (message.latestOneInForecasterNetworkRegrets?.length) {
      obj.latestOneInForecasterNetworkRegrets = message.latestOneInForecasterNetworkRegrets.map((e) =>
        TopicIdActorIdActorIdTimeStampedValue.toJSON(e)
      );
    }
    if (message.latestNaiveInfererNetworkRegrets?.length) {
      obj.latestNaiveInfererNetworkRegrets = message.latestNaiveInfererNetworkRegrets.map((e) =>
        TopicIdActorIdTimeStampedValue.toJSON(e)
      );
    }
    if (message.latestOneOutInfererInfererNetworkRegrets?.length) {
      obj.latestOneOutInfererInfererNetworkRegrets = message.latestOneOutInfererInfererNetworkRegrets.map((e) =>
        TopicIdActorIdActorIdTimeStampedValue.toJSON(e)
      );
    }
    if (message.latestOneOutInfererForecasterNetworkRegrets?.length) {
      obj.latestOneOutInfererForecasterNetworkRegrets = message.latestOneOutInfererForecasterNetworkRegrets.map((e) =>
        TopicIdActorIdActorIdTimeStampedValue.toJSON(e)
      );
    }
    if (message.latestOneOutForecasterInfererNetworkRegrets?.length) {
      obj.latestOneOutForecasterInfererNetworkRegrets = message.latestOneOutForecasterInfererNetworkRegrets.map((e) =>
        TopicIdActorIdActorIdTimeStampedValue.toJSON(e)
      );
    }
    if (message.latestOneOutForecasterForecasterNetworkRegrets?.length) {
      obj.latestOneOutForecasterForecasterNetworkRegrets = message.latestOneOutForecasterForecasterNetworkRegrets.map(
        (e) => TopicIdActorIdActorIdTimeStampedValue.toJSON(e)
      );
    }
    if (message.coreTeamAddresses?.length) {
      obj.coreTeamAddresses = message.coreTeamAddresses;
    }
    if (message.topicLastWorkerCommit?.length) {
      obj.topicLastWorkerCommit = message.topicLastWorkerCommit.map((e) => TopicIdTimestampedActorNonce.toJSON(e));
    }
    if (message.topicLastReputerCommit?.length) {
      obj.topicLastReputerCommit = message.topicLastReputerCommit.map((e) => TopicIdTimestampedActorNonce.toJSON(e));
    }
    if (message.topicToNextPossibleChurningBlock?.length) {
      obj.topicToNextPossibleChurningBlock = message.topicToNextPossibleChurningBlock.map((e) =>
        TopicIdAndBlockHeight.toJSON(e)
      );
    }
    if (message.blockToActiveTopics?.length) {
      obj.blockToActiveTopics = message.blockToActiveTopics.map((e) => BlockHeightTopicIds.toJSON(e));
    }
    if (message.blockToLowestActiveTopicWeight?.length) {
      obj.blockToLowestActiveTopicWeight = message.blockToLowestActiveTopicWeight.map((e) =>
        BlockHeightTopicIdWeightPair.toJSON(e)
      );
    }
    if (message.previousTopicQuantileInfererScoreEma?.length) {
      obj.previousTopicQuantileInfererScoreEma = message.previousTopicQuantileInfererScoreEma.map((e) =>
        TopicIdAndDec.toJSON(e)
      );
    }
    if (message.previousTopicQuantileForecasterScoreEma?.length) {
      obj.previousTopicQuantileForecasterScoreEma = message.previousTopicQuantileForecasterScoreEma.map((e) =>
        TopicIdAndDec.toJSON(e)
      );
    }
    if (message.previousTopicQuantileReputerScoreEma?.length) {
      obj.previousTopicQuantileReputerScoreEma = message.previousTopicQuantileReputerScoreEma.map((e) =>
        TopicIdAndDec.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<GenesisState>): GenesisState {
    return GenesisState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenesisState>): GenesisState {
    const message = createBaseGenesisState();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    message.nextTopicId = object.nextTopicId ?? "0";
    message.topics = object.topics?.map((e) => TopicIdAndTopic.fromPartial(e)) || [];
    message.activeTopics = object.activeTopics?.map((e) => e) || [];
    message.rewardableTopics = object.rewardableTopics?.map((e) => e) || [];
    message.topicWorkers = object.topicWorkers?.map((e) => TopicAndActorId.fromPartial(e)) || [];
    message.topicReputers = object.topicReputers?.map((e) => TopicAndActorId.fromPartial(e)) || [];
    message.topicRewardNonce = object.topicRewardNonce?.map((e) => TopicIdAndBlockHeight.fromPartial(e)) || [];
    message.infererScoresByBlock = object.infererScoresByBlock?.map((e) => TopicIdBlockHeightScores.fromPartial(e)) ||
      [];
    message.forecasterScoresByBlock =
      object.forecasterScoresByBlock?.map((e) => TopicIdBlockHeightScores.fromPartial(e)) || [];
    message.reputerScoresByBlock = object.reputerScoresByBlock?.map((e) => TopicIdBlockHeightScores.fromPartial(e)) ||
      [];
    message.infererScoreEmas = object.infererScoreEmas?.map((e) => TopicIdActorIdScore.fromPartial(e)) || [];
    message.forecasterScoreEmas = object.forecasterScoreEmas?.map((e) => TopicIdActorIdScore.fromPartial(e)) || [];
    message.reputerScoreEmas = object.reputerScoreEmas?.map((e) => TopicIdActorIdScore.fromPartial(e)) || [];
    message.reputerListeningCoefficient =
      object.reputerListeningCoefficient?.map((e) => TopicIdActorIdListeningCoefficient.fromPartial(e)) || [];
    message.previousReputerRewardFraction =
      object.previousReputerRewardFraction?.map((e) => TopicIdActorIdDec.fromPartial(e)) || [];
    message.previousInferenceRewardFraction =
      object.previousInferenceRewardFraction?.map((e) => TopicIdActorIdDec.fromPartial(e)) || [];
    message.previousForecastRewardFraction =
      object.previousForecastRewardFraction?.map((e) => TopicIdActorIdDec.fromPartial(e)) || [];
    message.previousForecasterScoreRatio =
      object.previousForecasterScoreRatio?.map((e) => TopicIdAndDec.fromPartial(e)) || [];
    message.totalStake = object.totalStake ?? "";
    message.topicStake = object.topicStake?.map((e) => TopicIdAndInt.fromPartial(e)) || [];
    message.stakeReputerAuthority = object.stakeReputerAuthority?.map((e) => TopicIdActorIdInt.fromPartial(e)) || [];
    message.stakeSumFromDelegator = object.stakeSumFromDelegator?.map((e) => TopicIdActorIdInt.fromPartial(e)) || [];
    message.delegatedStakes = object.delegatedStakes?.map((e) => TopicIdDelegatorReputerDelegatorInfo.fromPartial(e)) ||
      [];
    message.stakeFromDelegatorsUponReputer =
      object.stakeFromDelegatorsUponReputer?.map((e) => TopicIdActorIdInt.fromPartial(e)) || [];
    message.delegateRewardPerShare = object.delegateRewardPerShare?.map((e) => TopicIdActorIdDec.fromPartial(e)) || [];
    message.stakeRemovalsByBlock =
      object.stakeRemovalsByBlock?.map((e) => BlockHeightTopicIdReputerStakeRemovalInfo.fromPartial(e)) || [];
    message.stakeRemovalsByActor = object.stakeRemovalsByActor?.map((e) => ActorIdTopicIdBlockHeight.fromPartial(e)) ||
      [];
    message.delegateStakeRemovalsByBlock =
      object.delegateStakeRemovalsByBlock?.map((e) =>
        BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo.fromPartial(e)
      ) || [];
    message.delegateStakeRemovalsByActor =
      object.delegateStakeRemovalsByActor?.map((e) => DelegatorReputerTopicIdBlockHeight.fromPartial(e)) || [];
    message.inferences = object.inferences?.map((e) => TopicIdActorIdInference.fromPartial(e)) || [];
    message.forecasts = object.forecasts?.map((e) => TopicIdActorIdForecast.fromPartial(e)) || [];
    message.workers = object.workers?.map((e) => LibP2pKeyAndOffchainNode.fromPartial(e)) || [];
    message.reputers = object.reputers?.map((e) => LibP2pKeyAndOffchainNode.fromPartial(e)) || [];
    message.topicFeeRevenue = object.topicFeeRevenue?.map((e) => TopicIdAndInt.fromPartial(e)) || [];
    message.previousTopicWeight = object.previousTopicWeight?.map((e) => TopicIdAndDec.fromPartial(e)) || [];
    message.allInferences = object.allInferences?.map((e) => TopicIdBlockHeightInferences.fromPartial(e)) || [];
    message.allForecasts = object.allForecasts?.map((e) => TopicIdBlockHeightForecasts.fromPartial(e)) || [];
    message.allLossBundles = object.allLossBundles?.map((e) => TopicIdBlockHeightReputerValueBundles.fromPartial(e)) ||
      [];
    message.networkLossBundles = object.networkLossBundles?.map((e) => TopicIdBlockHeightValueBundles.fromPartial(e)) ||
      [];
    message.previousPercentageRewardToStakedReputers = object.previousPercentageRewardToStakedReputers ?? "";
    message.openWorkerWindows = object.openWorkerWindows?.map((e) => BlockHeightAndTopicIds.fromPartial(e)) || [];
    message.unfulfilledWorkerNonces = object.unfulfilledWorkerNonces?.map((e) => TopicIdAndNonces.fromPartial(e)) || [];
    message.unfulfilledReputerNonces =
      object.unfulfilledReputerNonces?.map((e) => TopicIdAndReputerRequestNonces.fromPartial(e)) || [];
    message.lastDripBlock = object.lastDripBlock?.map((e) => TopicIdAndBlockHeight.fromPartial(e)) || [];
    message.latestInfererNetworkRegrets =
      object.latestInfererNetworkRegrets?.map((e) => TopicIdActorIdTimeStampedValue.fromPartial(e)) || [];
    message.latestForecasterNetworkRegrets =
      object.latestForecasterNetworkRegrets?.map((e) => TopicIdActorIdTimeStampedValue.fromPartial(e)) || [];
    message.latestOneInForecasterNetworkRegrets =
      object.latestOneInForecasterNetworkRegrets?.map((e) => TopicIdActorIdActorIdTimeStampedValue.fromPartial(e)) ||
      [];
    message.latestNaiveInfererNetworkRegrets =
      object.latestNaiveInfererNetworkRegrets?.map((e) => TopicIdActorIdTimeStampedValue.fromPartial(e)) || [];
    message.latestOneOutInfererInfererNetworkRegrets =
      object.latestOneOutInfererInfererNetworkRegrets?.map((e) =>
        TopicIdActorIdActorIdTimeStampedValue.fromPartial(e)
      ) || [];
    message.latestOneOutInfererForecasterNetworkRegrets =
      object.latestOneOutInfererForecasterNetworkRegrets?.map((e) =>
        TopicIdActorIdActorIdTimeStampedValue.fromPartial(e)
      ) || [];
    message.latestOneOutForecasterInfererNetworkRegrets =
      object.latestOneOutForecasterInfererNetworkRegrets?.map((e) =>
        TopicIdActorIdActorIdTimeStampedValue.fromPartial(e)
      ) || [];
    message.latestOneOutForecasterForecasterNetworkRegrets =
      object.latestOneOutForecasterForecasterNetworkRegrets?.map((e) =>
        TopicIdActorIdActorIdTimeStampedValue.fromPartial(e)
      ) || [];
    message.coreTeamAddresses = object.coreTeamAddresses?.map((e) => e) || [];
    message.topicLastWorkerCommit =
      object.topicLastWorkerCommit?.map((e) => TopicIdTimestampedActorNonce.fromPartial(e)) || [];
    message.topicLastReputerCommit =
      object.topicLastReputerCommit?.map((e) => TopicIdTimestampedActorNonce.fromPartial(e)) || [];
    message.topicToNextPossibleChurningBlock =
      object.topicToNextPossibleChurningBlock?.map((e) => TopicIdAndBlockHeight.fromPartial(e)) || [];
    message.blockToActiveTopics = object.blockToActiveTopics?.map((e) => BlockHeightTopicIds.fromPartial(e)) || [];
    message.blockToLowestActiveTopicWeight =
      object.blockToLowestActiveTopicWeight?.map((e) => BlockHeightTopicIdWeightPair.fromPartial(e)) || [];
    message.previousTopicQuantileInfererScoreEma =
      object.previousTopicQuantileInfererScoreEma?.map((e) => TopicIdAndDec.fromPartial(e)) || [];
    message.previousTopicQuantileForecasterScoreEma =
      object.previousTopicQuantileForecasterScoreEma?.map((e) => TopicIdAndDec.fromPartial(e)) || [];
    message.previousTopicQuantileReputerScoreEma =
      object.previousTopicQuantileReputerScoreEma?.map((e) => TopicIdAndDec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTopicIdAndTopic(): TopicIdAndTopic {
  return { TopicId: "0", Topic: undefined };
}

export const TopicIdAndTopic: MessageFns<TopicIdAndTopic> = {
  encode(message: TopicIdAndTopic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.Topic !== undefined) {
      Topic.encode(message.Topic, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdAndTopic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdAndTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Topic = Topic.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdAndTopic {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      Topic: isSet(object.Topic) ? Topic.fromJSON(object.Topic) : undefined,
    };
  },

  toJSON(message: TopicIdAndTopic): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.Topic !== undefined) {
      obj.Topic = Topic.toJSON(message.Topic);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdAndTopic>): TopicIdAndTopic {
    return TopicIdAndTopic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdAndTopic>): TopicIdAndTopic {
    const message = createBaseTopicIdAndTopic();
    message.TopicId = object.TopicId ?? "0";
    message.Topic = (object.Topic !== undefined && object.Topic !== null) ? Topic.fromPartial(object.Topic) : undefined;
    return message;
  },
};

function createBaseTopicAndActorId(): TopicAndActorId {
  return { TopicId: "0", ActorId: "" };
}

export const TopicAndActorId: MessageFns<TopicAndActorId> = {
  encode(message: TopicAndActorId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId !== "") {
      writer.uint32(18).string(message.ActorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicAndActorId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicAndActorId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicAndActorId {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
    };
  },

  toJSON(message: TopicAndActorId): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicAndActorId>): TopicAndActorId {
    return TopicAndActorId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicAndActorId>): TopicAndActorId {
    const message = createBaseTopicAndActorId();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId = object.ActorId ?? "";
    return message;
  },
};

function createBaseTopicIdAndBlockHeight(): TopicIdAndBlockHeight {
  return { TopicId: "0", BlockHeight: "0" };
}

export const TopicIdAndBlockHeight: MessageFns<TopicIdAndBlockHeight> = {
  encode(message: TopicIdAndBlockHeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.BlockHeight !== "0") {
      writer.uint32(16).int64(message.BlockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdAndBlockHeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdAndBlockHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdAndBlockHeight {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
    };
  },

  toJSON(message: TopicIdAndBlockHeight): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdAndBlockHeight>): TopicIdAndBlockHeight {
    return TopicIdAndBlockHeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdAndBlockHeight>): TopicIdAndBlockHeight {
    const message = createBaseTopicIdAndBlockHeight();
    message.TopicId = object.TopicId ?? "0";
    message.BlockHeight = object.BlockHeight ?? "0";
    return message;
  },
};

function createBaseBlockHeightAndTopicIds(): BlockHeightAndTopicIds {
  return { BlockHeight: "0", TopicIds: [] };
}

export const BlockHeightAndTopicIds: MessageFns<BlockHeightAndTopicIds> = {
  encode(message: BlockHeightAndTopicIds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.BlockHeight !== "0") {
      writer.uint32(8).int64(message.BlockHeight);
    }
    writer.uint32(18).fork();
    for (const v of message.TopicIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeightAndTopicIds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeightAndTopicIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.TopicIds.push(reader.uint64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.TopicIds.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeightAndTopicIds {
    return {
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      TopicIds: globalThis.Array.isArray(object?.TopicIds) ? object.TopicIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BlockHeightAndTopicIds): unknown {
    const obj: any = {};
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.TopicIds?.length) {
      obj.TopicIds = message.TopicIds;
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeightAndTopicIds>): BlockHeightAndTopicIds {
    return BlockHeightAndTopicIds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeightAndTopicIds>): BlockHeightAndTopicIds {
    const message = createBaseBlockHeightAndTopicIds();
    message.BlockHeight = object.BlockHeight ?? "0";
    message.TopicIds = object.TopicIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseTopicIdBlockHeightScores(): TopicIdBlockHeightScores {
  return { TopicId: "0", BlockHeight: "0", Scores: undefined };
}

export const TopicIdBlockHeightScores: MessageFns<TopicIdBlockHeightScores> = {
  encode(message: TopicIdBlockHeightScores, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.BlockHeight !== "0") {
      writer.uint32(16).int64(message.BlockHeight);
    }
    if (message.Scores !== undefined) {
      Scores.encode(message.Scores, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdBlockHeightScores {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdBlockHeightScores();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Scores = Scores.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdBlockHeightScores {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      Scores: isSet(object.Scores) ? Scores.fromJSON(object.Scores) : undefined,
    };
  },

  toJSON(message: TopicIdBlockHeightScores): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.Scores !== undefined) {
      obj.Scores = Scores.toJSON(message.Scores);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdBlockHeightScores>): TopicIdBlockHeightScores {
    return TopicIdBlockHeightScores.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdBlockHeightScores>): TopicIdBlockHeightScores {
    const message = createBaseTopicIdBlockHeightScores();
    message.TopicId = object.TopicId ?? "0";
    message.BlockHeight = object.BlockHeight ?? "0";
    message.Scores = (object.Scores !== undefined && object.Scores !== null)
      ? Scores.fromPartial(object.Scores)
      : undefined;
    return message;
  },
};

function createBaseTopicIdActorIdScore(): TopicIdActorIdScore {
  return { TopicId: "0", ActorId: "", Score: undefined };
}

export const TopicIdActorIdScore: MessageFns<TopicIdActorIdScore> = {
  encode(message: TopicIdActorIdScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId !== "") {
      writer.uint32(18).string(message.ActorId);
    }
    if (message.Score !== undefined) {
      Score.encode(message.Score, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdActorIdScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdActorIdScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Score = Score.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdActorIdScore {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
      Score: isSet(object.Score) ? Score.fromJSON(object.Score) : undefined,
    };
  },

  toJSON(message: TopicIdActorIdScore): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    if (message.Score !== undefined) {
      obj.Score = Score.toJSON(message.Score);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdActorIdScore>): TopicIdActorIdScore {
    return TopicIdActorIdScore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdActorIdScore>): TopicIdActorIdScore {
    const message = createBaseTopicIdActorIdScore();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId = object.ActorId ?? "";
    message.Score = (object.Score !== undefined && object.Score !== null) ? Score.fromPartial(object.Score) : undefined;
    return message;
  },
};

function createBaseTopicIdActorIdListeningCoefficient(): TopicIdActorIdListeningCoefficient {
  return { TopicId: "0", ActorId: "", ListeningCoefficient: undefined };
}

export const TopicIdActorIdListeningCoefficient: MessageFns<TopicIdActorIdListeningCoefficient> = {
  encode(message: TopicIdActorIdListeningCoefficient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId !== "") {
      writer.uint32(18).string(message.ActorId);
    }
    if (message.ListeningCoefficient !== undefined) {
      ListeningCoefficient.encode(message.ListeningCoefficient, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdActorIdListeningCoefficient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdActorIdListeningCoefficient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ListeningCoefficient = ListeningCoefficient.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdActorIdListeningCoefficient {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
      ListeningCoefficient: isSet(object.ListeningCoefficient)
        ? ListeningCoefficient.fromJSON(object.ListeningCoefficient)
        : undefined,
    };
  },

  toJSON(message: TopicIdActorIdListeningCoefficient): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    if (message.ListeningCoefficient !== undefined) {
      obj.ListeningCoefficient = ListeningCoefficient.toJSON(message.ListeningCoefficient);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdActorIdListeningCoefficient>): TopicIdActorIdListeningCoefficient {
    return TopicIdActorIdListeningCoefficient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdActorIdListeningCoefficient>): TopicIdActorIdListeningCoefficient {
    const message = createBaseTopicIdActorIdListeningCoefficient();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId = object.ActorId ?? "";
    message.ListeningCoefficient = (object.ListeningCoefficient !== undefined && object.ListeningCoefficient !== null)
      ? ListeningCoefficient.fromPartial(object.ListeningCoefficient)
      : undefined;
    return message;
  },
};

function createBaseTopicIdActorIdDec(): TopicIdActorIdDec {
  return { TopicId: "0", ActorId: "", Dec: "" };
}

export const TopicIdActorIdDec: MessageFns<TopicIdActorIdDec> = {
  encode(message: TopicIdActorIdDec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId !== "") {
      writer.uint32(18).string(message.ActorId);
    }
    if (message.Dec !== "") {
      writer.uint32(26).string(message.Dec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdActorIdDec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdActorIdDec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Dec = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdActorIdDec {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
      Dec: isSet(object.Dec) ? globalThis.String(object.Dec) : "",
    };
  },

  toJSON(message: TopicIdActorIdDec): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    if (message.Dec !== "") {
      obj.Dec = message.Dec;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdActorIdDec>): TopicIdActorIdDec {
    return TopicIdActorIdDec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdActorIdDec>): TopicIdActorIdDec {
    const message = createBaseTopicIdActorIdDec();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId = object.ActorId ?? "";
    message.Dec = object.Dec ?? "";
    return message;
  },
};

function createBaseTopicIdAndInt(): TopicIdAndInt {
  return { TopicId: "0", Int: "" };
}

export const TopicIdAndInt: MessageFns<TopicIdAndInt> = {
  encode(message: TopicIdAndInt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.Int !== "") {
      writer.uint32(18).string(message.Int);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdAndInt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdAndInt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Int = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdAndInt {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      Int: isSet(object.Int) ? globalThis.String(object.Int) : "",
    };
  },

  toJSON(message: TopicIdAndInt): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.Int !== "") {
      obj.Int = message.Int;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdAndInt>): TopicIdAndInt {
    return TopicIdAndInt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdAndInt>): TopicIdAndInt {
    const message = createBaseTopicIdAndInt();
    message.TopicId = object.TopicId ?? "0";
    message.Int = object.Int ?? "";
    return message;
  },
};

function createBaseTopicIdActorIdInt(): TopicIdActorIdInt {
  return { TopicId: "0", ActorId: "", Int: "" };
}

export const TopicIdActorIdInt: MessageFns<TopicIdActorIdInt> = {
  encode(message: TopicIdActorIdInt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId !== "") {
      writer.uint32(18).string(message.ActorId);
    }
    if (message.Int !== "") {
      writer.uint32(26).string(message.Int);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdActorIdInt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdActorIdInt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Int = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdActorIdInt {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
      Int: isSet(object.Int) ? globalThis.String(object.Int) : "",
    };
  },

  toJSON(message: TopicIdActorIdInt): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    if (message.Int !== "") {
      obj.Int = message.Int;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdActorIdInt>): TopicIdActorIdInt {
    return TopicIdActorIdInt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdActorIdInt>): TopicIdActorIdInt {
    const message = createBaseTopicIdActorIdInt();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId = object.ActorId ?? "";
    message.Int = object.Int ?? "";
    return message;
  },
};

function createBaseTopicIdDelegatorReputerDelegatorInfo(): TopicIdDelegatorReputerDelegatorInfo {
  return { TopicId: "0", Delegator: "", Reputer: "", DelegatorInfo: undefined };
}

export const TopicIdDelegatorReputerDelegatorInfo: MessageFns<TopicIdDelegatorReputerDelegatorInfo> = {
  encode(message: TopicIdDelegatorReputerDelegatorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.Delegator !== "") {
      writer.uint32(18).string(message.Delegator);
    }
    if (message.Reputer !== "") {
      writer.uint32(26).string(message.Reputer);
    }
    if (message.DelegatorInfo !== undefined) {
      DelegatorInfo.encode(message.DelegatorInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdDelegatorReputerDelegatorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdDelegatorReputerDelegatorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Delegator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Reputer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.DelegatorInfo = DelegatorInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdDelegatorReputerDelegatorInfo {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      Delegator: isSet(object.Delegator) ? globalThis.String(object.Delegator) : "",
      Reputer: isSet(object.Reputer) ? globalThis.String(object.Reputer) : "",
      DelegatorInfo: isSet(object.DelegatorInfo) ? DelegatorInfo.fromJSON(object.DelegatorInfo) : undefined,
    };
  },

  toJSON(message: TopicIdDelegatorReputerDelegatorInfo): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.Delegator !== "") {
      obj.Delegator = message.Delegator;
    }
    if (message.Reputer !== "") {
      obj.Reputer = message.Reputer;
    }
    if (message.DelegatorInfo !== undefined) {
      obj.DelegatorInfo = DelegatorInfo.toJSON(message.DelegatorInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdDelegatorReputerDelegatorInfo>): TopicIdDelegatorReputerDelegatorInfo {
    return TopicIdDelegatorReputerDelegatorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdDelegatorReputerDelegatorInfo>): TopicIdDelegatorReputerDelegatorInfo {
    const message = createBaseTopicIdDelegatorReputerDelegatorInfo();
    message.TopicId = object.TopicId ?? "0";
    message.Delegator = object.Delegator ?? "";
    message.Reputer = object.Reputer ?? "";
    message.DelegatorInfo = (object.DelegatorInfo !== undefined && object.DelegatorInfo !== null)
      ? DelegatorInfo.fromPartial(object.DelegatorInfo)
      : undefined;
    return message;
  },
};

function createBaseBlockHeightTopicIdReputerStakeRemovalInfo(): BlockHeightTopicIdReputerStakeRemovalInfo {
  return { BlockHeight: "0", TopicId: "0", Reputer: "", StakeRemovalInfo: undefined };
}

export const BlockHeightTopicIdReputerStakeRemovalInfo: MessageFns<BlockHeightTopicIdReputerStakeRemovalInfo> = {
  encode(message: BlockHeightTopicIdReputerStakeRemovalInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.BlockHeight !== "0") {
      writer.uint32(8).int64(message.BlockHeight);
    }
    if (message.TopicId !== "0") {
      writer.uint32(16).uint64(message.TopicId);
    }
    if (message.Reputer !== "") {
      writer.uint32(26).string(message.Reputer);
    }
    if (message.StakeRemovalInfo !== undefined) {
      StakeRemovalInfo.encode(message.StakeRemovalInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeightTopicIdReputerStakeRemovalInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeightTopicIdReputerStakeRemovalInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Reputer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.StakeRemovalInfo = StakeRemovalInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeightTopicIdReputerStakeRemovalInfo {
    return {
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      Reputer: isSet(object.Reputer) ? globalThis.String(object.Reputer) : "",
      StakeRemovalInfo: isSet(object.StakeRemovalInfo) ? StakeRemovalInfo.fromJSON(object.StakeRemovalInfo) : undefined,
    };
  },

  toJSON(message: BlockHeightTopicIdReputerStakeRemovalInfo): unknown {
    const obj: any = {};
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.Reputer !== "") {
      obj.Reputer = message.Reputer;
    }
    if (message.StakeRemovalInfo !== undefined) {
      obj.StakeRemovalInfo = StakeRemovalInfo.toJSON(message.StakeRemovalInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeightTopicIdReputerStakeRemovalInfo>): BlockHeightTopicIdReputerStakeRemovalInfo {
    return BlockHeightTopicIdReputerStakeRemovalInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BlockHeightTopicIdReputerStakeRemovalInfo>,
  ): BlockHeightTopicIdReputerStakeRemovalInfo {
    const message = createBaseBlockHeightTopicIdReputerStakeRemovalInfo();
    message.BlockHeight = object.BlockHeight ?? "0";
    message.TopicId = object.TopicId ?? "0";
    message.Reputer = object.Reputer ?? "";
    message.StakeRemovalInfo = (object.StakeRemovalInfo !== undefined && object.StakeRemovalInfo !== null)
      ? StakeRemovalInfo.fromPartial(object.StakeRemovalInfo)
      : undefined;
    return message;
  },
};

function createBaseActorIdTopicIdBlockHeight(): ActorIdTopicIdBlockHeight {
  return { ActorId: "", TopicId: "0", BlockHeight: "0" };
}

export const ActorIdTopicIdBlockHeight: MessageFns<ActorIdTopicIdBlockHeight> = {
  encode(message: ActorIdTopicIdBlockHeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ActorId !== "") {
      writer.uint32(10).string(message.ActorId);
    }
    if (message.TopicId !== "0") {
      writer.uint32(16).uint64(message.TopicId);
    }
    if (message.BlockHeight !== "0") {
      writer.uint32(24).int64(message.BlockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActorIdTopicIdBlockHeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActorIdTopicIdBlockHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActorIdTopicIdBlockHeight {
    return {
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
    };
  },

  toJSON(message: ActorIdTopicIdBlockHeight): unknown {
    const obj: any = {};
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<ActorIdTopicIdBlockHeight>): ActorIdTopicIdBlockHeight {
    return ActorIdTopicIdBlockHeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActorIdTopicIdBlockHeight>): ActorIdTopicIdBlockHeight {
    const message = createBaseActorIdTopicIdBlockHeight();
    message.ActorId = object.ActorId ?? "";
    message.TopicId = object.TopicId ?? "0";
    message.BlockHeight = object.BlockHeight ?? "0";
    return message;
  },
};

function createBaseBlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo(): BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo {
  return { BlockHeight: "0", TopicId: "0", Delegator: "", Reputer: "", DelegateStakeRemovalInfo: undefined };
}

export const BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo: MessageFns<
  BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo
> = {
  encode(
    message: BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.BlockHeight !== "0") {
      writer.uint32(8).int64(message.BlockHeight);
    }
    if (message.TopicId !== "0") {
      writer.uint32(16).uint64(message.TopicId);
    }
    if (message.Delegator !== "") {
      writer.uint32(26).string(message.Delegator);
    }
    if (message.Reputer !== "") {
      writer.uint32(34).string(message.Reputer);
    }
    if (message.DelegateStakeRemovalInfo !== undefined) {
      DelegateStakeRemovalInfo.encode(message.DelegateStakeRemovalInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Delegator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.Reputer = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.DelegateStakeRemovalInfo = DelegateStakeRemovalInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo {
    return {
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      Delegator: isSet(object.Delegator) ? globalThis.String(object.Delegator) : "",
      Reputer: isSet(object.Reputer) ? globalThis.String(object.Reputer) : "",
      DelegateStakeRemovalInfo: isSet(object.DelegateStakeRemovalInfo)
        ? DelegateStakeRemovalInfo.fromJSON(object.DelegateStakeRemovalInfo)
        : undefined,
    };
  },

  toJSON(message: BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo): unknown {
    const obj: any = {};
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.Delegator !== "") {
      obj.Delegator = message.Delegator;
    }
    if (message.Reputer !== "") {
      obj.Reputer = message.Reputer;
    }
    if (message.DelegateStakeRemovalInfo !== undefined) {
      obj.DelegateStakeRemovalInfo = DelegateStakeRemovalInfo.toJSON(message.DelegateStakeRemovalInfo);
    }
    return obj;
  },

  create(
    base?: DeepPartial<BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo>,
  ): BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo {
    return BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo>,
  ): BlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo {
    const message = createBaseBlockHeightTopicIdDelegatorReputerDelegateStakeRemovalInfo();
    message.BlockHeight = object.BlockHeight ?? "0";
    message.TopicId = object.TopicId ?? "0";
    message.Delegator = object.Delegator ?? "";
    message.Reputer = object.Reputer ?? "";
    message.DelegateStakeRemovalInfo =
      (object.DelegateStakeRemovalInfo !== undefined && object.DelegateStakeRemovalInfo !== null)
        ? DelegateStakeRemovalInfo.fromPartial(object.DelegateStakeRemovalInfo)
        : undefined;
    return message;
  },
};

function createBaseDelegatorReputerTopicIdBlockHeight(): DelegatorReputerTopicIdBlockHeight {
  return { Delegator: "", Reputer: "", TopicId: "0", BlockHeight: "0" };
}

export const DelegatorReputerTopicIdBlockHeight: MessageFns<DelegatorReputerTopicIdBlockHeight> = {
  encode(message: DelegatorReputerTopicIdBlockHeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Delegator !== "") {
      writer.uint32(10).string(message.Delegator);
    }
    if (message.Reputer !== "") {
      writer.uint32(18).string(message.Reputer);
    }
    if (message.TopicId !== "0") {
      writer.uint32(24).uint64(message.TopicId);
    }
    if (message.BlockHeight !== "0") {
      writer.uint32(32).int64(message.BlockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegatorReputerTopicIdBlockHeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatorReputerTopicIdBlockHeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Delegator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Reputer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DelegatorReputerTopicIdBlockHeight {
    return {
      Delegator: isSet(object.Delegator) ? globalThis.String(object.Delegator) : "",
      Reputer: isSet(object.Reputer) ? globalThis.String(object.Reputer) : "",
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
    };
  },

  toJSON(message: DelegatorReputerTopicIdBlockHeight): unknown {
    const obj: any = {};
    if (message.Delegator !== "") {
      obj.Delegator = message.Delegator;
    }
    if (message.Reputer !== "") {
      obj.Reputer = message.Reputer;
    }
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<DelegatorReputerTopicIdBlockHeight>): DelegatorReputerTopicIdBlockHeight {
    return DelegatorReputerTopicIdBlockHeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DelegatorReputerTopicIdBlockHeight>): DelegatorReputerTopicIdBlockHeight {
    const message = createBaseDelegatorReputerTopicIdBlockHeight();
    message.Delegator = object.Delegator ?? "";
    message.Reputer = object.Reputer ?? "";
    message.TopicId = object.TopicId ?? "0";
    message.BlockHeight = object.BlockHeight ?? "0";
    return message;
  },
};

function createBaseTopicIdActorIdInference(): TopicIdActorIdInference {
  return { TopicId: "0", ActorId: "", Inference: undefined };
}

export const TopicIdActorIdInference: MessageFns<TopicIdActorIdInference> = {
  encode(message: TopicIdActorIdInference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId !== "") {
      writer.uint32(18).string(message.ActorId);
    }
    if (message.Inference !== undefined) {
      Inference.encode(message.Inference, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdActorIdInference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdActorIdInference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Inference = Inference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdActorIdInference {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
      Inference: isSet(object.Inference) ? Inference.fromJSON(object.Inference) : undefined,
    };
  },

  toJSON(message: TopicIdActorIdInference): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    if (message.Inference !== undefined) {
      obj.Inference = Inference.toJSON(message.Inference);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdActorIdInference>): TopicIdActorIdInference {
    return TopicIdActorIdInference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdActorIdInference>): TopicIdActorIdInference {
    const message = createBaseTopicIdActorIdInference();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId = object.ActorId ?? "";
    message.Inference = (object.Inference !== undefined && object.Inference !== null)
      ? Inference.fromPartial(object.Inference)
      : undefined;
    return message;
  },
};

function createBaseTopicIdActorIdForecast(): TopicIdActorIdForecast {
  return { TopicId: "0", ActorId: "", Forecast: undefined };
}

export const TopicIdActorIdForecast: MessageFns<TopicIdActorIdForecast> = {
  encode(message: TopicIdActorIdForecast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId !== "") {
      writer.uint32(18).string(message.ActorId);
    }
    if (message.Forecast !== undefined) {
      Forecast.encode(message.Forecast, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdActorIdForecast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdActorIdForecast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Forecast = Forecast.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdActorIdForecast {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
      Forecast: isSet(object.Forecast) ? Forecast.fromJSON(object.Forecast) : undefined,
    };
  },

  toJSON(message: TopicIdActorIdForecast): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    if (message.Forecast !== undefined) {
      obj.Forecast = Forecast.toJSON(message.Forecast);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdActorIdForecast>): TopicIdActorIdForecast {
    return TopicIdActorIdForecast.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdActorIdForecast>): TopicIdActorIdForecast {
    const message = createBaseTopicIdActorIdForecast();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId = object.ActorId ?? "";
    message.Forecast = (object.Forecast !== undefined && object.Forecast !== null)
      ? Forecast.fromPartial(object.Forecast)
      : undefined;
    return message;
  },
};

function createBaseLibP2pKeyAndOffchainNode(): LibP2pKeyAndOffchainNode {
  return { LibP2pKey: "", OffchainNode: undefined };
}

export const LibP2pKeyAndOffchainNode: MessageFns<LibP2pKeyAndOffchainNode> = {
  encode(message: LibP2pKeyAndOffchainNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.LibP2pKey !== "") {
      writer.uint32(10).string(message.LibP2pKey);
    }
    if (message.OffchainNode !== undefined) {
      OffchainNode.encode(message.OffchainNode, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LibP2pKeyAndOffchainNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLibP2pKeyAndOffchainNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.LibP2pKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.OffchainNode = OffchainNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LibP2pKeyAndOffchainNode {
    return {
      LibP2pKey: isSet(object.LibP2pKey) ? globalThis.String(object.LibP2pKey) : "",
      OffchainNode: isSet(object.OffchainNode) ? OffchainNode.fromJSON(object.OffchainNode) : undefined,
    };
  },

  toJSON(message: LibP2pKeyAndOffchainNode): unknown {
    const obj: any = {};
    if (message.LibP2pKey !== "") {
      obj.LibP2pKey = message.LibP2pKey;
    }
    if (message.OffchainNode !== undefined) {
      obj.OffchainNode = OffchainNode.toJSON(message.OffchainNode);
    }
    return obj;
  },

  create(base?: DeepPartial<LibP2pKeyAndOffchainNode>): LibP2pKeyAndOffchainNode {
    return LibP2pKeyAndOffchainNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LibP2pKeyAndOffchainNode>): LibP2pKeyAndOffchainNode {
    const message = createBaseLibP2pKeyAndOffchainNode();
    message.LibP2pKey = object.LibP2pKey ?? "";
    message.OffchainNode = (object.OffchainNode !== undefined && object.OffchainNode !== null)
      ? OffchainNode.fromPartial(object.OffchainNode)
      : undefined;
    return message;
  },
};

function createBaseTopicIdAndDec(): TopicIdAndDec {
  return { TopicId: "0", Dec: "" };
}

export const TopicIdAndDec: MessageFns<TopicIdAndDec> = {
  encode(message: TopicIdAndDec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.Dec !== "") {
      writer.uint32(18).string(message.Dec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdAndDec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdAndDec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Dec = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdAndDec {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      Dec: isSet(object.Dec) ? globalThis.String(object.Dec) : "",
    };
  },

  toJSON(message: TopicIdAndDec): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.Dec !== "") {
      obj.Dec = message.Dec;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdAndDec>): TopicIdAndDec {
    return TopicIdAndDec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdAndDec>): TopicIdAndDec {
    const message = createBaseTopicIdAndDec();
    message.TopicId = object.TopicId ?? "0";
    message.Dec = object.Dec ?? "";
    return message;
  },
};

function createBaseTopicIdBlockHeightInferences(): TopicIdBlockHeightInferences {
  return { TopicId: "0", BlockHeight: "0", Inferences: undefined };
}

export const TopicIdBlockHeightInferences: MessageFns<TopicIdBlockHeightInferences> = {
  encode(message: TopicIdBlockHeightInferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.BlockHeight !== "0") {
      writer.uint32(16).int64(message.BlockHeight);
    }
    if (message.Inferences !== undefined) {
      Inferences.encode(message.Inferences, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdBlockHeightInferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdBlockHeightInferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Inferences = Inferences.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdBlockHeightInferences {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      Inferences: isSet(object.Inferences) ? Inferences.fromJSON(object.Inferences) : undefined,
    };
  },

  toJSON(message: TopicIdBlockHeightInferences): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.Inferences !== undefined) {
      obj.Inferences = Inferences.toJSON(message.Inferences);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdBlockHeightInferences>): TopicIdBlockHeightInferences {
    return TopicIdBlockHeightInferences.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdBlockHeightInferences>): TopicIdBlockHeightInferences {
    const message = createBaseTopicIdBlockHeightInferences();
    message.TopicId = object.TopicId ?? "0";
    message.BlockHeight = object.BlockHeight ?? "0";
    message.Inferences = (object.Inferences !== undefined && object.Inferences !== null)
      ? Inferences.fromPartial(object.Inferences)
      : undefined;
    return message;
  },
};

function createBaseTopicIdBlockHeightForecasts(): TopicIdBlockHeightForecasts {
  return { TopicId: "0", BlockHeight: "0", Forecasts: undefined };
}

export const TopicIdBlockHeightForecasts: MessageFns<TopicIdBlockHeightForecasts> = {
  encode(message: TopicIdBlockHeightForecasts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.BlockHeight !== "0") {
      writer.uint32(16).int64(message.BlockHeight);
    }
    if (message.Forecasts !== undefined) {
      Forecasts.encode(message.Forecasts, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdBlockHeightForecasts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdBlockHeightForecasts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Forecasts = Forecasts.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdBlockHeightForecasts {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      Forecasts: isSet(object.Forecasts) ? Forecasts.fromJSON(object.Forecasts) : undefined,
    };
  },

  toJSON(message: TopicIdBlockHeightForecasts): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.Forecasts !== undefined) {
      obj.Forecasts = Forecasts.toJSON(message.Forecasts);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdBlockHeightForecasts>): TopicIdBlockHeightForecasts {
    return TopicIdBlockHeightForecasts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdBlockHeightForecasts>): TopicIdBlockHeightForecasts {
    const message = createBaseTopicIdBlockHeightForecasts();
    message.TopicId = object.TopicId ?? "0";
    message.BlockHeight = object.BlockHeight ?? "0";
    message.Forecasts = (object.Forecasts !== undefined && object.Forecasts !== null)
      ? Forecasts.fromPartial(object.Forecasts)
      : undefined;
    return message;
  },
};

function createBaseTopicIdBlockHeightReputerValueBundles(): TopicIdBlockHeightReputerValueBundles {
  return { TopicId: "0", BlockHeight: "0", ReputerValueBundles: undefined };
}

export const TopicIdBlockHeightReputerValueBundles: MessageFns<TopicIdBlockHeightReputerValueBundles> = {
  encode(message: TopicIdBlockHeightReputerValueBundles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.BlockHeight !== "0") {
      writer.uint32(16).int64(message.BlockHeight);
    }
    if (message.ReputerValueBundles !== undefined) {
      ReputerValueBundles.encode(message.ReputerValueBundles, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdBlockHeightReputerValueBundles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdBlockHeightReputerValueBundles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ReputerValueBundles = ReputerValueBundles.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdBlockHeightReputerValueBundles {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      ReputerValueBundles: isSet(object.ReputerValueBundles)
        ? ReputerValueBundles.fromJSON(object.ReputerValueBundles)
        : undefined,
    };
  },

  toJSON(message: TopicIdBlockHeightReputerValueBundles): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.ReputerValueBundles !== undefined) {
      obj.ReputerValueBundles = ReputerValueBundles.toJSON(message.ReputerValueBundles);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdBlockHeightReputerValueBundles>): TopicIdBlockHeightReputerValueBundles {
    return TopicIdBlockHeightReputerValueBundles.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdBlockHeightReputerValueBundles>): TopicIdBlockHeightReputerValueBundles {
    const message = createBaseTopicIdBlockHeightReputerValueBundles();
    message.TopicId = object.TopicId ?? "0";
    message.BlockHeight = object.BlockHeight ?? "0";
    message.ReputerValueBundles = (object.ReputerValueBundles !== undefined && object.ReputerValueBundles !== null)
      ? ReputerValueBundles.fromPartial(object.ReputerValueBundles)
      : undefined;
    return message;
  },
};

function createBaseTopicIdBlockHeightValueBundles(): TopicIdBlockHeightValueBundles {
  return { TopicId: "0", BlockHeight: "0", ValueBundle: undefined };
}

export const TopicIdBlockHeightValueBundles: MessageFns<TopicIdBlockHeightValueBundles> = {
  encode(message: TopicIdBlockHeightValueBundles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.BlockHeight !== "0") {
      writer.uint32(16).int64(message.BlockHeight);
    }
    if (message.ValueBundle !== undefined) {
      ValueBundle.encode(message.ValueBundle, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdBlockHeightValueBundles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdBlockHeightValueBundles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ValueBundle = ValueBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdBlockHeightValueBundles {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      ValueBundle: isSet(object.ValueBundle) ? ValueBundle.fromJSON(object.ValueBundle) : undefined,
    };
  },

  toJSON(message: TopicIdBlockHeightValueBundles): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.ValueBundle !== undefined) {
      obj.ValueBundle = ValueBundle.toJSON(message.ValueBundle);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdBlockHeightValueBundles>): TopicIdBlockHeightValueBundles {
    return TopicIdBlockHeightValueBundles.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdBlockHeightValueBundles>): TopicIdBlockHeightValueBundles {
    const message = createBaseTopicIdBlockHeightValueBundles();
    message.TopicId = object.TopicId ?? "0";
    message.BlockHeight = object.BlockHeight ?? "0";
    message.ValueBundle = (object.ValueBundle !== undefined && object.ValueBundle !== null)
      ? ValueBundle.fromPartial(object.ValueBundle)
      : undefined;
    return message;
  },
};

function createBaseTopicIdAndNonces(): TopicIdAndNonces {
  return { TopicId: "0", Nonces: undefined };
}

export const TopicIdAndNonces: MessageFns<TopicIdAndNonces> = {
  encode(message: TopicIdAndNonces, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.Nonces !== undefined) {
      Nonces.encode(message.Nonces, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdAndNonces {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdAndNonces();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Nonces = Nonces.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdAndNonces {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      Nonces: isSet(object.Nonces) ? Nonces.fromJSON(object.Nonces) : undefined,
    };
  },

  toJSON(message: TopicIdAndNonces): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.Nonces !== undefined) {
      obj.Nonces = Nonces.toJSON(message.Nonces);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdAndNonces>): TopicIdAndNonces {
    return TopicIdAndNonces.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdAndNonces>): TopicIdAndNonces {
    const message = createBaseTopicIdAndNonces();
    message.TopicId = object.TopicId ?? "0";
    message.Nonces = (object.Nonces !== undefined && object.Nonces !== null)
      ? Nonces.fromPartial(object.Nonces)
      : undefined;
    return message;
  },
};

function createBaseTopicIdAndReputerRequestNonces(): TopicIdAndReputerRequestNonces {
  return { TopicId: "0", ReputerRequestNonces: undefined };
}

export const TopicIdAndReputerRequestNonces: MessageFns<TopicIdAndReputerRequestNonces> = {
  encode(message: TopicIdAndReputerRequestNonces, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ReputerRequestNonces !== undefined) {
      ReputerRequestNonces.encode(message.ReputerRequestNonces, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdAndReputerRequestNonces {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdAndReputerRequestNonces();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ReputerRequestNonces = ReputerRequestNonces.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdAndReputerRequestNonces {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ReputerRequestNonces: isSet(object.ReputerRequestNonces)
        ? ReputerRequestNonces.fromJSON(object.ReputerRequestNonces)
        : undefined,
    };
  },

  toJSON(message: TopicIdAndReputerRequestNonces): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ReputerRequestNonces !== undefined) {
      obj.ReputerRequestNonces = ReputerRequestNonces.toJSON(message.ReputerRequestNonces);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdAndReputerRequestNonces>): TopicIdAndReputerRequestNonces {
    return TopicIdAndReputerRequestNonces.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdAndReputerRequestNonces>): TopicIdAndReputerRequestNonces {
    const message = createBaseTopicIdAndReputerRequestNonces();
    message.TopicId = object.TopicId ?? "0";
    message.ReputerRequestNonces = (object.ReputerRequestNonces !== undefined && object.ReputerRequestNonces !== null)
      ? ReputerRequestNonces.fromPartial(object.ReputerRequestNonces)
      : undefined;
    return message;
  },
};

function createBaseTopicIdActorIdTimeStampedValue(): TopicIdActorIdTimeStampedValue {
  return { TopicId: "0", ActorId: "", TimestampedValue: undefined };
}

export const TopicIdActorIdTimeStampedValue: MessageFns<TopicIdActorIdTimeStampedValue> = {
  encode(message: TopicIdActorIdTimeStampedValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId !== "") {
      writer.uint32(18).string(message.ActorId);
    }
    if (message.TimestampedValue !== undefined) {
      TimestampedValue.encode(message.TimestampedValue, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdActorIdTimeStampedValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdActorIdTimeStampedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.TimestampedValue = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdActorIdTimeStampedValue {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId: isSet(object.ActorId) ? globalThis.String(object.ActorId) : "",
      TimestampedValue: isSet(object.TimestampedValue) ? TimestampedValue.fromJSON(object.TimestampedValue) : undefined,
    };
  },

  toJSON(message: TopicIdActorIdTimeStampedValue): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId !== "") {
      obj.ActorId = message.ActorId;
    }
    if (message.TimestampedValue !== undefined) {
      obj.TimestampedValue = TimestampedValue.toJSON(message.TimestampedValue);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdActorIdTimeStampedValue>): TopicIdActorIdTimeStampedValue {
    return TopicIdActorIdTimeStampedValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdActorIdTimeStampedValue>): TopicIdActorIdTimeStampedValue {
    const message = createBaseTopicIdActorIdTimeStampedValue();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId = object.ActorId ?? "";
    message.TimestampedValue = (object.TimestampedValue !== undefined && object.TimestampedValue !== null)
      ? TimestampedValue.fromPartial(object.TimestampedValue)
      : undefined;
    return message;
  },
};

function createBaseTopicIdActorIdActorIdTimeStampedValue(): TopicIdActorIdActorIdTimeStampedValue {
  return { TopicId: "0", ActorId1: "", ActorId2: "", TimestampedValue: undefined };
}

export const TopicIdActorIdActorIdTimeStampedValue: MessageFns<TopicIdActorIdActorIdTimeStampedValue> = {
  encode(message: TopicIdActorIdActorIdTimeStampedValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.ActorId1 !== "") {
      writer.uint32(18).string(message.ActorId1);
    }
    if (message.ActorId2 !== "") {
      writer.uint32(26).string(message.ActorId2);
    }
    if (message.TimestampedValue !== undefined) {
      TimestampedValue.encode(message.TimestampedValue, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdActorIdActorIdTimeStampedValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdActorIdActorIdTimeStampedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ActorId1 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ActorId2 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.TimestampedValue = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdActorIdActorIdTimeStampedValue {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      ActorId1: isSet(object.ActorId1) ? globalThis.String(object.ActorId1) : "",
      ActorId2: isSet(object.ActorId2) ? globalThis.String(object.ActorId2) : "",
      TimestampedValue: isSet(object.TimestampedValue) ? TimestampedValue.fromJSON(object.TimestampedValue) : undefined,
    };
  },

  toJSON(message: TopicIdActorIdActorIdTimeStampedValue): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.ActorId1 !== "") {
      obj.ActorId1 = message.ActorId1;
    }
    if (message.ActorId2 !== "") {
      obj.ActorId2 = message.ActorId2;
    }
    if (message.TimestampedValue !== undefined) {
      obj.TimestampedValue = TimestampedValue.toJSON(message.TimestampedValue);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdActorIdActorIdTimeStampedValue>): TopicIdActorIdActorIdTimeStampedValue {
    return TopicIdActorIdActorIdTimeStampedValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdActorIdActorIdTimeStampedValue>): TopicIdActorIdActorIdTimeStampedValue {
    const message = createBaseTopicIdActorIdActorIdTimeStampedValue();
    message.TopicId = object.TopicId ?? "0";
    message.ActorId1 = object.ActorId1 ?? "";
    message.ActorId2 = object.ActorId2 ?? "";
    message.TimestampedValue = (object.TimestampedValue !== undefined && object.TimestampedValue !== null)
      ? TimestampedValue.fromPartial(object.TimestampedValue)
      : undefined;
    return message;
  },
};

function createBaseTopicIdTimestampedActorNonce(): TopicIdTimestampedActorNonce {
  return { TopicId: "0", TimestampedActorNonce: undefined };
}

export const TopicIdTimestampedActorNonce: MessageFns<TopicIdTimestampedActorNonce> = {
  encode(message: TopicIdTimestampedActorNonce, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.TopicId !== "0") {
      writer.uint32(8).uint64(message.TopicId);
    }
    if (message.TimestampedActorNonce !== undefined) {
      TimestampedActorNonce.encode(message.TimestampedActorNonce, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicIdTimestampedActorNonce {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicIdTimestampedActorNonce();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.TopicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.TimestampedActorNonce = TimestampedActorNonce.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicIdTimestampedActorNonce {
    return {
      TopicId: isSet(object.TopicId) ? globalThis.String(object.TopicId) : "0",
      TimestampedActorNonce: isSet(object.TimestampedActorNonce)
        ? TimestampedActorNonce.fromJSON(object.TimestampedActorNonce)
        : undefined,
    };
  },

  toJSON(message: TopicIdTimestampedActorNonce): unknown {
    const obj: any = {};
    if (message.TopicId !== "0") {
      obj.TopicId = message.TopicId;
    }
    if (message.TimestampedActorNonce !== undefined) {
      obj.TimestampedActorNonce = TimestampedActorNonce.toJSON(message.TimestampedActorNonce);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicIdTimestampedActorNonce>): TopicIdTimestampedActorNonce {
    return TopicIdTimestampedActorNonce.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicIdTimestampedActorNonce>): TopicIdTimestampedActorNonce {
    const message = createBaseTopicIdTimestampedActorNonce();
    message.TopicId = object.TopicId ?? "0";
    message.TimestampedActorNonce =
      (object.TimestampedActorNonce !== undefined && object.TimestampedActorNonce !== null)
        ? TimestampedActorNonce.fromPartial(object.TimestampedActorNonce)
        : undefined;
    return message;
  },
};

function createBaseBlockHeightTopicIds(): BlockHeightTopicIds {
  return { BlockHeight: "0", TopicIds: undefined };
}

export const BlockHeightTopicIds: MessageFns<BlockHeightTopicIds> = {
  encode(message: BlockHeightTopicIds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.BlockHeight !== "0") {
      writer.uint32(8).int64(message.BlockHeight);
    }
    if (message.TopicIds !== undefined) {
      TopicIds.encode(message.TopicIds, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeightTopicIds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeightTopicIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.TopicIds = TopicIds.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeightTopicIds {
    return {
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      TopicIds: isSet(object.TopicIds) ? TopicIds.fromJSON(object.TopicIds) : undefined,
    };
  },

  toJSON(message: BlockHeightTopicIds): unknown {
    const obj: any = {};
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.TopicIds !== undefined) {
      obj.TopicIds = TopicIds.toJSON(message.TopicIds);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeightTopicIds>): BlockHeightTopicIds {
    return BlockHeightTopicIds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeightTopicIds>): BlockHeightTopicIds {
    const message = createBaseBlockHeightTopicIds();
    message.BlockHeight = object.BlockHeight ?? "0";
    message.TopicIds = (object.TopicIds !== undefined && object.TopicIds !== null)
      ? TopicIds.fromPartial(object.TopicIds)
      : undefined;
    return message;
  },
};

function createBaseBlockHeightTopicIdWeightPair(): BlockHeightTopicIdWeightPair {
  return { BlockHeight: "0", TopicWeight: undefined };
}

export const BlockHeightTopicIdWeightPair: MessageFns<BlockHeightTopicIdWeightPair> = {
  encode(message: BlockHeightTopicIdWeightPair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.BlockHeight !== "0") {
      writer.uint32(8).int64(message.BlockHeight);
    }
    if (message.TopicWeight !== undefined) {
      TopicIdWeightPair.encode(message.TopicWeight, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockHeightTopicIdWeightPair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeightTopicIdWeightPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.BlockHeight = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.TopicWeight = TopicIdWeightPair.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockHeightTopicIdWeightPair {
    return {
      BlockHeight: isSet(object.BlockHeight) ? globalThis.String(object.BlockHeight) : "0",
      TopicWeight: isSet(object.TopicWeight) ? TopicIdWeightPair.fromJSON(object.TopicWeight) : undefined,
    };
  },

  toJSON(message: BlockHeightTopicIdWeightPair): unknown {
    const obj: any = {};
    if (message.BlockHeight !== "0") {
      obj.BlockHeight = message.BlockHeight;
    }
    if (message.TopicWeight !== undefined) {
      obj.TopicWeight = TopicIdWeightPair.toJSON(message.TopicWeight);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockHeightTopicIdWeightPair>): BlockHeightTopicIdWeightPair {
    return BlockHeightTopicIdWeightPair.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockHeightTopicIdWeightPair>): BlockHeightTopicIdWeightPair {
    const message = createBaseBlockHeightTopicIdWeightPair();
    message.BlockHeight = object.BlockHeight ?? "0";
    message.TopicWeight = (object.TopicWeight !== undefined && object.TopicWeight !== null)
      ? TopicIdWeightPair.fromPartial(object.TopicWeight)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
