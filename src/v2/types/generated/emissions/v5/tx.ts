// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: emissions/v5/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ReputerValueBundle } from "../v3/reputer";
import { WorkerDataBundle } from "../v3/worker";

export const protobufPackage = "emissions.v5";

/**
 * Because gocosmos, grpc-gateway, and go-pulsar do not support optional fields
 * and including google themselves
 * https://cloud.google.com/apis/design/design_patterns.md#optional_primitive_fields
 * we instead use a repeated field with a single element to represent an
 * optional field and if the repeated field is empty, it is considered to be the
 * same as if the field was not set
 */
export interface OptionalParams {
  version: string[];
  maxSerializedMsgLength: string[];
  minTopicWeight: string[];
  requiredMinimumStake: string[];
  removeStakeDelayWindow: string[];
  minEpochLength: string[];
  betaEntropy: string[];
  learningRate: string[];
  maxGradientThreshold: string[];
  minStakeFraction: string[];
  maxUnfulfilledWorkerRequests: string[];
  maxUnfulfilledReputerRequests: string[];
  topicRewardStakeImportance: string[];
  topicRewardFeeRevenueImportance: string[];
  topicRewardAlpha: string[];
  taskRewardAlpha: string[];
  validatorsVsAlloraPercentReward: string[];
  maxSamplesToScaleScores: string[];
  maxTopInferersToReward: string[];
  maxTopForecastersToReward: string[];
  maxTopReputersToReward: string[];
  createTopicFee: string[];
  gradientDescentMaxIters: string[];
  registrationFee: string[];
  defaultPageLimit: string[];
  maxPageLimit: string[];
  minEpochLengthRecordLimit: string[];
  blocksPerMonth: string[];
  pRewardInference: string[];
  pRewardForecast: string[];
  pRewardReputer: string[];
  cRewardInference: string[];
  cRewardForecast: string[];
  cNorm: string[];
  epsilonReputer: string[];
  halfMaxProcessStakeRemovalsEndBlock: string[];
  dataSendingFee: string[];
  epsilonSafeDiv: string[];
  maxElementsPerForecast: string[];
  maxActiveTopicsPerBlock: string[];
  maxStringLength: string[];
  initialRegretQuantile: string[];
  pNormSafeDiv: string[];
}

export interface UpdateParamsRequest {
  sender: string;
  params?: OptionalParams | undefined;
}

export interface UpdateParamsResponse {
}

export interface CreateNewTopicRequest {
  /** creator is the message sender. */
  creator: string;
  metadata: string;
  lossMethod: string;
  epochLength: string;
  groundTruthLag: string;
  pNorm: string;
  alphaRegret: string;
  allowNegative: boolean;
  epsilon: string;
  workerSubmissionWindow: string;
  meritSortitionAlpha: string;
  activeInfererQuantile: string;
  activeForecasterQuantile: string;
  activeReputerQuantile: string;
}

export interface CreateNewTopicResponse {
  topicId: string;
}

export interface InsertReputerPayloadRequest {
  sender: string;
  reputerValueBundle?: ReputerValueBundle | undefined;
}

export interface InsertReputerPayloadResponse {
}

export interface InsertWorkerPayloadRequest {
  sender: string;
  workerDataBundle?: WorkerDataBundle | undefined;
}

export interface InsertWorkerPayloadResponse {
}

export interface RegisterRequest {
  sender: string;
  topicId: string;
  owner: string;
  isReputer: boolean;
}

export interface RegisterResponse {
  success: boolean;
  message: string;
}

export interface RemoveRegistrationRequest {
  sender: string;
  topicId: string;
  isReputer: boolean;
}

export interface RemoveRegistrationResponse {
  success: boolean;
  message: string;
}

export interface AddStakeRequest {
  sender: string;
  topicId: string;
  amount: string;
}

export interface AddStakeResponse {
}

export interface RemoveStakeRequest {
  sender: string;
  topicId: string;
  amount: string;
}

export interface RemoveStakeResponse {
}

export interface CancelRemoveStakeRequest {
  sender: string;
  topicId: string;
}

export interface CancelRemoveStakeResponse {
}

export interface DelegateStakeRequest {
  sender: string;
  topicId: string;
  reputer: string;
  amount: string;
}

export interface DelegateStakeResponse {
}

export interface RemoveDelegateStakeRequest {
  sender: string;
  reputer: string;
  topicId: string;
  amount: string;
}

export interface RemoveDelegateStakeResponse {
}

export interface CancelRemoveDelegateStakeRequest {
  sender: string;
  topicId: string;
  delegator: string;
  reputer: string;
}

export interface CancelRemoveDelegateStakeResponse {
}

export interface RewardDelegateStakeRequest {
  sender: string;
  topicId: string;
  reputer: string;
}

export interface RewardDelegateStakeResponse {
}

/**
 * Inferences are requested by consumers who fund topics by sending ALLO to
 * ecosystem account via TopicFund messages
 */
export interface FundTopicRequest {
  sender: string;
  topicId: string;
  /** how many funds to send from alice with this Inference Request */
  amount: string;
}

export interface FundTopicResponse {
}

export interface AddToWhitelistAdminRequest {
  sender: string;
  address: string;
}

export interface AddToWhitelistAdminResponse {
}

export interface RemoveFromWhitelistAdminRequest {
  sender: string;
  address: string;
}

export interface RemoveFromWhitelistAdminResponse {
}

function createBaseOptionalParams(): OptionalParams {
  return {
    version: [],
    maxSerializedMsgLength: [],
    minTopicWeight: [],
    requiredMinimumStake: [],
    removeStakeDelayWindow: [],
    minEpochLength: [],
    betaEntropy: [],
    learningRate: [],
    maxGradientThreshold: [],
    minStakeFraction: [],
    maxUnfulfilledWorkerRequests: [],
    maxUnfulfilledReputerRequests: [],
    topicRewardStakeImportance: [],
    topicRewardFeeRevenueImportance: [],
    topicRewardAlpha: [],
    taskRewardAlpha: [],
    validatorsVsAlloraPercentReward: [],
    maxSamplesToScaleScores: [],
    maxTopInferersToReward: [],
    maxTopForecastersToReward: [],
    maxTopReputersToReward: [],
    createTopicFee: [],
    gradientDescentMaxIters: [],
    registrationFee: [],
    defaultPageLimit: [],
    maxPageLimit: [],
    minEpochLengthRecordLimit: [],
    blocksPerMonth: [],
    pRewardInference: [],
    pRewardForecast: [],
    pRewardReputer: [],
    cRewardInference: [],
    cRewardForecast: [],
    cNorm: [],
    epsilonReputer: [],
    halfMaxProcessStakeRemovalsEndBlock: [],
    dataSendingFee: [],
    epsilonSafeDiv: [],
    maxElementsPerForecast: [],
    maxActiveTopicsPerBlock: [],
    maxStringLength: [],
    initialRegretQuantile: [],
    pNormSafeDiv: [],
  };
}

export const OptionalParams: MessageFns<OptionalParams> = {
  encode(message: OptionalParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.version) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.maxSerializedMsgLength) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.minTopicWeight) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.requiredMinimumStake) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.removeStakeDelayWindow) {
      writer.int64(v);
    }
    writer.join();
    writer.uint32(58).fork();
    for (const v of message.minEpochLength) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.betaEntropy) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.learningRate) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.maxGradientThreshold) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.minStakeFraction) {
      writer.uint32(90).string(v!);
    }
    writer.uint32(106).fork();
    for (const v of message.maxUnfulfilledWorkerRequests) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(114).fork();
    for (const v of message.maxUnfulfilledReputerRequests) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.topicRewardStakeImportance) {
      writer.uint32(122).string(v!);
    }
    for (const v of message.topicRewardFeeRevenueImportance) {
      writer.uint32(130).string(v!);
    }
    for (const v of message.topicRewardAlpha) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.taskRewardAlpha) {
      writer.uint32(146).string(v!);
    }
    for (const v of message.validatorsVsAlloraPercentReward) {
      writer.uint32(154).string(v!);
    }
    writer.uint32(162).fork();
    for (const v of message.maxSamplesToScaleScores) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(170).fork();
    for (const v of message.maxTopInferersToReward) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(178).fork();
    for (const v of message.maxTopForecastersToReward) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(186).fork();
    for (const v of message.maxTopReputersToReward) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.createTopicFee) {
      writer.uint32(194).string(v!);
    }
    writer.uint32(202).fork();
    for (const v of message.gradientDescentMaxIters) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.registrationFee) {
      writer.uint32(226).string(v!);
    }
    writer.uint32(234).fork();
    for (const v of message.defaultPageLimit) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(242).fork();
    for (const v of message.maxPageLimit) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(250).fork();
    for (const v of message.minEpochLengthRecordLimit) {
      writer.int64(v);
    }
    writer.join();
    writer.uint32(258).fork();
    for (const v of message.blocksPerMonth) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.pRewardInference) {
      writer.uint32(266).string(v!);
    }
    for (const v of message.pRewardForecast) {
      writer.uint32(274).string(v!);
    }
    for (const v of message.pRewardReputer) {
      writer.uint32(282).string(v!);
    }
    for (const v of message.cRewardInference) {
      writer.uint32(290).string(v!);
    }
    for (const v of message.cRewardForecast) {
      writer.uint32(298).string(v!);
    }
    for (const v of message.cNorm) {
      writer.uint32(306).string(v!);
    }
    for (const v of message.epsilonReputer) {
      writer.uint32(322).string(v!);
    }
    writer.uint32(338).fork();
    for (const v of message.halfMaxProcessStakeRemovalsEndBlock) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.dataSendingFee) {
      writer.uint32(346).string(v!);
    }
    for (const v of message.epsilonSafeDiv) {
      writer.uint32(354).string(v!);
    }
    writer.uint32(362).fork();
    for (const v of message.maxElementsPerForecast) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(370).fork();
    for (const v of message.maxActiveTopicsPerBlock) {
      writer.uint64(v);
    }
    writer.join();
    writer.uint32(378).fork();
    for (const v of message.maxStringLength) {
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.initialRegretQuantile) {
      writer.uint32(386).string(v!);
    }
    for (const v of message.pNormSafeDiv) {
      writer.uint32(394).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionalParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionalParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version.push(reader.string());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.maxSerializedMsgLength.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxSerializedMsgLength.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minTopicWeight.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requiredMinimumStake.push(reader.string());
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.removeStakeDelayWindow.push(reader.int64().toString());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.removeStakeDelayWindow.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag === 56) {
            message.minEpochLength.push(reader.int64().toString());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.minEpochLength.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.betaEntropy.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.learningRate.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.maxGradientThreshold.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.minStakeFraction.push(reader.string());
          continue;
        }
        case 13: {
          if (tag === 104) {
            message.maxUnfulfilledWorkerRequests.push(reader.uint64().toString());

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxUnfulfilledWorkerRequests.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 14: {
          if (tag === 112) {
            message.maxUnfulfilledReputerRequests.push(reader.uint64().toString());

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxUnfulfilledReputerRequests.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.topicRewardStakeImportance.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.topicRewardFeeRevenueImportance.push(reader.string());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.topicRewardAlpha.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.taskRewardAlpha.push(reader.string());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.validatorsVsAlloraPercentReward.push(reader.string());
          continue;
        }
        case 20: {
          if (tag === 160) {
            message.maxSamplesToScaleScores.push(reader.uint64().toString());

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxSamplesToScaleScores.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 21: {
          if (tag === 168) {
            message.maxTopInferersToReward.push(reader.uint64().toString());

            continue;
          }

          if (tag === 170) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxTopInferersToReward.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 22: {
          if (tag === 176) {
            message.maxTopForecastersToReward.push(reader.uint64().toString());

            continue;
          }

          if (tag === 178) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxTopForecastersToReward.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 23: {
          if (tag === 184) {
            message.maxTopReputersToReward.push(reader.uint64().toString());

            continue;
          }

          if (tag === 186) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxTopReputersToReward.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.createTopicFee.push(reader.string());
          continue;
        }
        case 25: {
          if (tag === 200) {
            message.gradientDescentMaxIters.push(reader.uint64().toString());

            continue;
          }

          if (tag === 202) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.gradientDescentMaxIters.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.registrationFee.push(reader.string());
          continue;
        }
        case 29: {
          if (tag === 232) {
            message.defaultPageLimit.push(reader.uint64().toString());

            continue;
          }

          if (tag === 234) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.defaultPageLimit.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 30: {
          if (tag === 240) {
            message.maxPageLimit.push(reader.uint64().toString());

            continue;
          }

          if (tag === 242) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxPageLimit.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 31: {
          if (tag === 248) {
            message.minEpochLengthRecordLimit.push(reader.int64().toString());

            continue;
          }

          if (tag === 250) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.minEpochLengthRecordLimit.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 32: {
          if (tag === 256) {
            message.blocksPerMonth.push(reader.uint64().toString());

            continue;
          }

          if (tag === 258) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.blocksPerMonth.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.pRewardInference.push(reader.string());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.pRewardForecast.push(reader.string());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.pRewardReputer.push(reader.string());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.cRewardInference.push(reader.string());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.cRewardForecast.push(reader.string());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.cNorm.push(reader.string());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.epsilonReputer.push(reader.string());
          continue;
        }
        case 42: {
          if (tag === 336) {
            message.halfMaxProcessStakeRemovalsEndBlock.push(reader.uint64().toString());

            continue;
          }

          if (tag === 338) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.halfMaxProcessStakeRemovalsEndBlock.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.dataSendingFee.push(reader.string());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.epsilonSafeDiv.push(reader.string());
          continue;
        }
        case 45: {
          if (tag === 360) {
            message.maxElementsPerForecast.push(reader.uint64().toString());

            continue;
          }

          if (tag === 362) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxElementsPerForecast.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 46: {
          if (tag === 368) {
            message.maxActiveTopicsPerBlock.push(reader.uint64().toString());

            continue;
          }

          if (tag === 370) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxActiveTopicsPerBlock.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 47: {
          if (tag === 376) {
            message.maxStringLength.push(reader.uint64().toString());

            continue;
          }

          if (tag === 378) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.maxStringLength.push(reader.uint64().toString());
            }

            continue;
          }

          break;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.initialRegretQuantile.push(reader.string());
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.pNormSafeDiv.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionalParams {
    return {
      version: globalThis.Array.isArray(object?.version) ? object.version.map((e: any) => globalThis.String(e)) : [],
      maxSerializedMsgLength: globalThis.Array.isArray(object?.maxSerializedMsgLength)
        ? object.maxSerializedMsgLength.map((e: any) => globalThis.String(e))
        : [],
      minTopicWeight: globalThis.Array.isArray(object?.minTopicWeight)
        ? object.minTopicWeight.map((e: any) => globalThis.String(e))
        : [],
      requiredMinimumStake: globalThis.Array.isArray(object?.requiredMinimumStake)
        ? object.requiredMinimumStake.map((e: any) => globalThis.String(e))
        : [],
      removeStakeDelayWindow: globalThis.Array.isArray(object?.removeStakeDelayWindow)
        ? object.removeStakeDelayWindow.map((e: any) => globalThis.String(e))
        : [],
      minEpochLength: globalThis.Array.isArray(object?.minEpochLength)
        ? object.minEpochLength.map((e: any) => globalThis.String(e))
        : [],
      betaEntropy: globalThis.Array.isArray(object?.betaEntropy)
        ? object.betaEntropy.map((e: any) => globalThis.String(e))
        : [],
      learningRate: globalThis.Array.isArray(object?.learningRate)
        ? object.learningRate.map((e: any) => globalThis.String(e))
        : [],
      maxGradientThreshold: globalThis.Array.isArray(object?.maxGradientThreshold)
        ? object.maxGradientThreshold.map((e: any) => globalThis.String(e))
        : [],
      minStakeFraction: globalThis.Array.isArray(object?.minStakeFraction)
        ? object.minStakeFraction.map((e: any) => globalThis.String(e))
        : [],
      maxUnfulfilledWorkerRequests: globalThis.Array.isArray(object?.maxUnfulfilledWorkerRequests)
        ? object.maxUnfulfilledWorkerRequests.map((e: any) => globalThis.String(e))
        : [],
      maxUnfulfilledReputerRequests: globalThis.Array.isArray(object?.maxUnfulfilledReputerRequests)
        ? object.maxUnfulfilledReputerRequests.map((e: any) => globalThis.String(e))
        : [],
      topicRewardStakeImportance: globalThis.Array.isArray(object?.topicRewardStakeImportance)
        ? object.topicRewardStakeImportance.map((e: any) => globalThis.String(e))
        : [],
      topicRewardFeeRevenueImportance: globalThis.Array.isArray(object?.topicRewardFeeRevenueImportance)
        ? object.topicRewardFeeRevenueImportance.map((e: any) => globalThis.String(e))
        : [],
      topicRewardAlpha: globalThis.Array.isArray(object?.topicRewardAlpha)
        ? object.topicRewardAlpha.map((e: any) => globalThis.String(e))
        : [],
      taskRewardAlpha: globalThis.Array.isArray(object?.taskRewardAlpha)
        ? object.taskRewardAlpha.map((e: any) => globalThis.String(e))
        : [],
      validatorsVsAlloraPercentReward: globalThis.Array.isArray(object?.validatorsVsAlloraPercentReward)
        ? object.validatorsVsAlloraPercentReward.map((e: any) => globalThis.String(e))
        : [],
      maxSamplesToScaleScores: globalThis.Array.isArray(object?.maxSamplesToScaleScores)
        ? object.maxSamplesToScaleScores.map((e: any) => globalThis.String(e))
        : [],
      maxTopInferersToReward: globalThis.Array.isArray(object?.maxTopInferersToReward)
        ? object.maxTopInferersToReward.map((e: any) => globalThis.String(e))
        : [],
      maxTopForecastersToReward: globalThis.Array.isArray(object?.maxTopForecastersToReward)
        ? object.maxTopForecastersToReward.map((e: any) => globalThis.String(e))
        : [],
      maxTopReputersToReward: globalThis.Array.isArray(object?.maxTopReputersToReward)
        ? object.maxTopReputersToReward.map((e: any) => globalThis.String(e))
        : [],
      createTopicFee: globalThis.Array.isArray(object?.createTopicFee)
        ? object.createTopicFee.map((e: any) => globalThis.String(e))
        : [],
      gradientDescentMaxIters: globalThis.Array.isArray(object?.gradientDescentMaxIters)
        ? object.gradientDescentMaxIters.map((e: any) => globalThis.String(e))
        : [],
      registrationFee: globalThis.Array.isArray(object?.registrationFee)
        ? object.registrationFee.map((e: any) => globalThis.String(e))
        : [],
      defaultPageLimit: globalThis.Array.isArray(object?.defaultPageLimit)
        ? object.defaultPageLimit.map((e: any) => globalThis.String(e))
        : [],
      maxPageLimit: globalThis.Array.isArray(object?.maxPageLimit)
        ? object.maxPageLimit.map((e: any) => globalThis.String(e))
        : [],
      minEpochLengthRecordLimit: globalThis.Array.isArray(object?.minEpochLengthRecordLimit)
        ? object.minEpochLengthRecordLimit.map((e: any) => globalThis.String(e))
        : [],
      blocksPerMonth: globalThis.Array.isArray(object?.blocksPerMonth)
        ? object.blocksPerMonth.map((e: any) => globalThis.String(e))
        : [],
      pRewardInference: globalThis.Array.isArray(object?.pRewardInference)
        ? object.pRewardInference.map((e: any) => globalThis.String(e))
        : [],
      pRewardForecast: globalThis.Array.isArray(object?.pRewardForecast)
        ? object.pRewardForecast.map((e: any) => globalThis.String(e))
        : [],
      pRewardReputer: globalThis.Array.isArray(object?.pRewardReputer)
        ? object.pRewardReputer.map((e: any) => globalThis.String(e))
        : [],
      cRewardInference: globalThis.Array.isArray(object?.cRewardInference)
        ? object.cRewardInference.map((e: any) => globalThis.String(e))
        : [],
      cRewardForecast: globalThis.Array.isArray(object?.cRewardForecast)
        ? object.cRewardForecast.map((e: any) => globalThis.String(e))
        : [],
      cNorm: globalThis.Array.isArray(object?.cNorm) ? object.cNorm.map((e: any) => globalThis.String(e)) : [],
      epsilonReputer: globalThis.Array.isArray(object?.epsilonReputer)
        ? object.epsilonReputer.map((e: any) => globalThis.String(e))
        : [],
      halfMaxProcessStakeRemovalsEndBlock: globalThis.Array.isArray(object?.halfMaxProcessStakeRemovalsEndBlock)
        ? object.halfMaxProcessStakeRemovalsEndBlock.map((e: any) => globalThis.String(e))
        : [],
      dataSendingFee: globalThis.Array.isArray(object?.dataSendingFee)
        ? object.dataSendingFee.map((e: any) => globalThis.String(e))
        : [],
      epsilonSafeDiv: globalThis.Array.isArray(object?.epsilonSafeDiv)
        ? object.epsilonSafeDiv.map((e: any) => globalThis.String(e))
        : [],
      maxElementsPerForecast: globalThis.Array.isArray(object?.maxElementsPerForecast)
        ? object.maxElementsPerForecast.map((e: any) => globalThis.String(e))
        : [],
      maxActiveTopicsPerBlock: globalThis.Array.isArray(object?.maxActiveTopicsPerBlock)
        ? object.maxActiveTopicsPerBlock.map((e: any) => globalThis.String(e))
        : [],
      maxStringLength: globalThis.Array.isArray(object?.maxStringLength)
        ? object.maxStringLength.map((e: any) => globalThis.String(e))
        : [],
      initialRegretQuantile: globalThis.Array.isArray(object?.initialRegretQuantile)
        ? object.initialRegretQuantile.map((e: any) => globalThis.String(e))
        : [],
      pNormSafeDiv: globalThis.Array.isArray(object?.pNormSafeDiv)
        ? object.pNormSafeDiv.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OptionalParams): unknown {
    const obj: any = {};
    if (message.version?.length) {
      obj.version = message.version;
    }
    if (message.maxSerializedMsgLength?.length) {
      obj.maxSerializedMsgLength = message.maxSerializedMsgLength;
    }
    if (message.minTopicWeight?.length) {
      obj.minTopicWeight = message.minTopicWeight;
    }
    if (message.requiredMinimumStake?.length) {
      obj.requiredMinimumStake = message.requiredMinimumStake;
    }
    if (message.removeStakeDelayWindow?.length) {
      obj.removeStakeDelayWindow = message.removeStakeDelayWindow;
    }
    if (message.minEpochLength?.length) {
      obj.minEpochLength = message.minEpochLength;
    }
    if (message.betaEntropy?.length) {
      obj.betaEntropy = message.betaEntropy;
    }
    if (message.learningRate?.length) {
      obj.learningRate = message.learningRate;
    }
    if (message.maxGradientThreshold?.length) {
      obj.maxGradientThreshold = message.maxGradientThreshold;
    }
    if (message.minStakeFraction?.length) {
      obj.minStakeFraction = message.minStakeFraction;
    }
    if (message.maxUnfulfilledWorkerRequests?.length) {
      obj.maxUnfulfilledWorkerRequests = message.maxUnfulfilledWorkerRequests;
    }
    if (message.maxUnfulfilledReputerRequests?.length) {
      obj.maxUnfulfilledReputerRequests = message.maxUnfulfilledReputerRequests;
    }
    if (message.topicRewardStakeImportance?.length) {
      obj.topicRewardStakeImportance = message.topicRewardStakeImportance;
    }
    if (message.topicRewardFeeRevenueImportance?.length) {
      obj.topicRewardFeeRevenueImportance = message.topicRewardFeeRevenueImportance;
    }
    if (message.topicRewardAlpha?.length) {
      obj.topicRewardAlpha = message.topicRewardAlpha;
    }
    if (message.taskRewardAlpha?.length) {
      obj.taskRewardAlpha = message.taskRewardAlpha;
    }
    if (message.validatorsVsAlloraPercentReward?.length) {
      obj.validatorsVsAlloraPercentReward = message.validatorsVsAlloraPercentReward;
    }
    if (message.maxSamplesToScaleScores?.length) {
      obj.maxSamplesToScaleScores = message.maxSamplesToScaleScores;
    }
    if (message.maxTopInferersToReward?.length) {
      obj.maxTopInferersToReward = message.maxTopInferersToReward;
    }
    if (message.maxTopForecastersToReward?.length) {
      obj.maxTopForecastersToReward = message.maxTopForecastersToReward;
    }
    if (message.maxTopReputersToReward?.length) {
      obj.maxTopReputersToReward = message.maxTopReputersToReward;
    }
    if (message.createTopicFee?.length) {
      obj.createTopicFee = message.createTopicFee;
    }
    if (message.gradientDescentMaxIters?.length) {
      obj.gradientDescentMaxIters = message.gradientDescentMaxIters;
    }
    if (message.registrationFee?.length) {
      obj.registrationFee = message.registrationFee;
    }
    if (message.defaultPageLimit?.length) {
      obj.defaultPageLimit = message.defaultPageLimit;
    }
    if (message.maxPageLimit?.length) {
      obj.maxPageLimit = message.maxPageLimit;
    }
    if (message.minEpochLengthRecordLimit?.length) {
      obj.minEpochLengthRecordLimit = message.minEpochLengthRecordLimit;
    }
    if (message.blocksPerMonth?.length) {
      obj.blocksPerMonth = message.blocksPerMonth;
    }
    if (message.pRewardInference?.length) {
      obj.pRewardInference = message.pRewardInference;
    }
    if (message.pRewardForecast?.length) {
      obj.pRewardForecast = message.pRewardForecast;
    }
    if (message.pRewardReputer?.length) {
      obj.pRewardReputer = message.pRewardReputer;
    }
    if (message.cRewardInference?.length) {
      obj.cRewardInference = message.cRewardInference;
    }
    if (message.cRewardForecast?.length) {
      obj.cRewardForecast = message.cRewardForecast;
    }
    if (message.cNorm?.length) {
      obj.cNorm = message.cNorm;
    }
    if (message.epsilonReputer?.length) {
      obj.epsilonReputer = message.epsilonReputer;
    }
    if (message.halfMaxProcessStakeRemovalsEndBlock?.length) {
      obj.halfMaxProcessStakeRemovalsEndBlock = message.halfMaxProcessStakeRemovalsEndBlock;
    }
    if (message.dataSendingFee?.length) {
      obj.dataSendingFee = message.dataSendingFee;
    }
    if (message.epsilonSafeDiv?.length) {
      obj.epsilonSafeDiv = message.epsilonSafeDiv;
    }
    if (message.maxElementsPerForecast?.length) {
      obj.maxElementsPerForecast = message.maxElementsPerForecast;
    }
    if (message.maxActiveTopicsPerBlock?.length) {
      obj.maxActiveTopicsPerBlock = message.maxActiveTopicsPerBlock;
    }
    if (message.maxStringLength?.length) {
      obj.maxStringLength = message.maxStringLength;
    }
    if (message.initialRegretQuantile?.length) {
      obj.initialRegretQuantile = message.initialRegretQuantile;
    }
    if (message.pNormSafeDiv?.length) {
      obj.pNormSafeDiv = message.pNormSafeDiv;
    }
    return obj;
  },

  create(base?: DeepPartial<OptionalParams>): OptionalParams {
    return OptionalParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OptionalParams>): OptionalParams {
    const message = createBaseOptionalParams();
    message.version = object.version?.map((e) => e) || [];
    message.maxSerializedMsgLength = object.maxSerializedMsgLength?.map((e) => e) || [];
    message.minTopicWeight = object.minTopicWeight?.map((e) => e) || [];
    message.requiredMinimumStake = object.requiredMinimumStake?.map((e) => e) || [];
    message.removeStakeDelayWindow = object.removeStakeDelayWindow?.map((e) => e) || [];
    message.minEpochLength = object.minEpochLength?.map((e) => e) || [];
    message.betaEntropy = object.betaEntropy?.map((e) => e) || [];
    message.learningRate = object.learningRate?.map((e) => e) || [];
    message.maxGradientThreshold = object.maxGradientThreshold?.map((e) => e) || [];
    message.minStakeFraction = object.minStakeFraction?.map((e) => e) || [];
    message.maxUnfulfilledWorkerRequests = object.maxUnfulfilledWorkerRequests?.map((e) => e) || [];
    message.maxUnfulfilledReputerRequests = object.maxUnfulfilledReputerRequests?.map((e) => e) || [];
    message.topicRewardStakeImportance = object.topicRewardStakeImportance?.map((e) => e) || [];
    message.topicRewardFeeRevenueImportance = object.topicRewardFeeRevenueImportance?.map((e) => e) || [];
    message.topicRewardAlpha = object.topicRewardAlpha?.map((e) => e) || [];
    message.taskRewardAlpha = object.taskRewardAlpha?.map((e) => e) || [];
    message.validatorsVsAlloraPercentReward = object.validatorsVsAlloraPercentReward?.map((e) => e) || [];
    message.maxSamplesToScaleScores = object.maxSamplesToScaleScores?.map((e) => e) || [];
    message.maxTopInferersToReward = object.maxTopInferersToReward?.map((e) => e) || [];
    message.maxTopForecastersToReward = object.maxTopForecastersToReward?.map((e) => e) || [];
    message.maxTopReputersToReward = object.maxTopReputersToReward?.map((e) => e) || [];
    message.createTopicFee = object.createTopicFee?.map((e) => e) || [];
    message.gradientDescentMaxIters = object.gradientDescentMaxIters?.map((e) => e) || [];
    message.registrationFee = object.registrationFee?.map((e) => e) || [];
    message.defaultPageLimit = object.defaultPageLimit?.map((e) => e) || [];
    message.maxPageLimit = object.maxPageLimit?.map((e) => e) || [];
    message.minEpochLengthRecordLimit = object.minEpochLengthRecordLimit?.map((e) => e) || [];
    message.blocksPerMonth = object.blocksPerMonth?.map((e) => e) || [];
    message.pRewardInference = object.pRewardInference?.map((e) => e) || [];
    message.pRewardForecast = object.pRewardForecast?.map((e) => e) || [];
    message.pRewardReputer = object.pRewardReputer?.map((e) => e) || [];
    message.cRewardInference = object.cRewardInference?.map((e) => e) || [];
    message.cRewardForecast = object.cRewardForecast?.map((e) => e) || [];
    message.cNorm = object.cNorm?.map((e) => e) || [];
    message.epsilonReputer = object.epsilonReputer?.map((e) => e) || [];
    message.halfMaxProcessStakeRemovalsEndBlock = object.halfMaxProcessStakeRemovalsEndBlock?.map((e) => e) || [];
    message.dataSendingFee = object.dataSendingFee?.map((e) => e) || [];
    message.epsilonSafeDiv = object.epsilonSafeDiv?.map((e) => e) || [];
    message.maxElementsPerForecast = object.maxElementsPerForecast?.map((e) => e) || [];
    message.maxActiveTopicsPerBlock = object.maxActiveTopicsPerBlock?.map((e) => e) || [];
    message.maxStringLength = object.maxStringLength?.map((e) => e) || [];
    message.initialRegretQuantile = object.initialRegretQuantile?.map((e) => e) || [];
    message.pNormSafeDiv = object.pNormSafeDiv?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateParamsRequest(): UpdateParamsRequest {
  return { sender: "", params: undefined };
}

export const UpdateParamsRequest: MessageFns<UpdateParamsRequest> = {
  encode(message: UpdateParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.params !== undefined) {
      OptionalParams.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = OptionalParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParamsRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      params: isSet(object.params) ? OptionalParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: UpdateParamsRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.params !== undefined) {
      obj.params = OptionalParams.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateParamsRequest>): UpdateParamsRequest {
    return UpdateParamsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateParamsRequest>): UpdateParamsRequest {
    const message = createBaseUpdateParamsRequest();
    message.sender = object.sender ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? OptionalParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseUpdateParamsResponse(): UpdateParamsResponse {
  return {};
}

export const UpdateParamsResponse: MessageFns<UpdateParamsResponse> = {
  encode(_: UpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateParamsResponse {
    return {};
  },

  toJSON(_: UpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpdateParamsResponse>): UpdateParamsResponse {
    return UpdateParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpdateParamsResponse>): UpdateParamsResponse {
    const message = createBaseUpdateParamsResponse();
    return message;
  },
};

function createBaseCreateNewTopicRequest(): CreateNewTopicRequest {
  return {
    creator: "",
    metadata: "",
    lossMethod: "",
    epochLength: "0",
    groundTruthLag: "0",
    pNorm: "",
    alphaRegret: "",
    allowNegative: false,
    epsilon: "",
    workerSubmissionWindow: "0",
    meritSortitionAlpha: "",
    activeInfererQuantile: "",
    activeForecasterQuantile: "",
    activeReputerQuantile: "",
  };
}

export const CreateNewTopicRequest: MessageFns<CreateNewTopicRequest> = {
  encode(message: CreateNewTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.metadata !== "") {
      writer.uint32(18).string(message.metadata);
    }
    if (message.lossMethod !== "") {
      writer.uint32(34).string(message.lossMethod);
    }
    if (message.epochLength !== "0") {
      writer.uint32(56).int64(message.epochLength);
    }
    if (message.groundTruthLag !== "0") {
      writer.uint32(64).int64(message.groundTruthLag);
    }
    if (message.pNorm !== "") {
      writer.uint32(82).string(message.pNorm);
    }
    if (message.alphaRegret !== "") {
      writer.uint32(90).string(message.alphaRegret);
    }
    if (message.allowNegative !== false) {
      writer.uint32(96).bool(message.allowNegative);
    }
    if (message.epsilon !== "") {
      writer.uint32(106).string(message.epsilon);
    }
    if (message.workerSubmissionWindow !== "0") {
      writer.uint32(112).int64(message.workerSubmissionWindow);
    }
    if (message.meritSortitionAlpha !== "") {
      writer.uint32(122).string(message.meritSortitionAlpha);
    }
    if (message.activeInfererQuantile !== "") {
      writer.uint32(130).string(message.activeInfererQuantile);
    }
    if (message.activeForecasterQuantile !== "") {
      writer.uint32(138).string(message.activeForecasterQuantile);
    }
    if (message.activeReputerQuantile !== "") {
      writer.uint32(146).string(message.activeReputerQuantile);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNewTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNewTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lossMethod = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.epochLength = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.groundTruthLag = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pNorm = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.alphaRegret = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.allowNegative = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.epsilon = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.workerSubmissionWindow = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.meritSortitionAlpha = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.activeInfererQuantile = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.activeForecasterQuantile = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.activeReputerQuantile = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNewTopicRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      lossMethod: isSet(object.lossMethod) ? globalThis.String(object.lossMethod) : "",
      epochLength: isSet(object.epochLength) ? globalThis.String(object.epochLength) : "0",
      groundTruthLag: isSet(object.groundTruthLag) ? globalThis.String(object.groundTruthLag) : "0",
      pNorm: isSet(object.pNorm) ? globalThis.String(object.pNorm) : "",
      alphaRegret: isSet(object.alphaRegret) ? globalThis.String(object.alphaRegret) : "",
      allowNegative: isSet(object.allowNegative) ? globalThis.Boolean(object.allowNegative) : false,
      epsilon: isSet(object.epsilon) ? globalThis.String(object.epsilon) : "",
      workerSubmissionWindow: isSet(object.workerSubmissionWindow)
        ? globalThis.String(object.workerSubmissionWindow)
        : "0",
      meritSortitionAlpha: isSet(object.meritSortitionAlpha) ? globalThis.String(object.meritSortitionAlpha) : "",
      activeInfererQuantile: isSet(object.activeInfererQuantile) ? globalThis.String(object.activeInfererQuantile) : "",
      activeForecasterQuantile: isSet(object.activeForecasterQuantile)
        ? globalThis.String(object.activeForecasterQuantile)
        : "",
      activeReputerQuantile: isSet(object.activeReputerQuantile) ? globalThis.String(object.activeReputerQuantile) : "",
    };
  },

  toJSON(message: CreateNewTopicRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.lossMethod !== "") {
      obj.lossMethod = message.lossMethod;
    }
    if (message.epochLength !== "0") {
      obj.epochLength = message.epochLength;
    }
    if (message.groundTruthLag !== "0") {
      obj.groundTruthLag = message.groundTruthLag;
    }
    if (message.pNorm !== "") {
      obj.pNorm = message.pNorm;
    }
    if (message.alphaRegret !== "") {
      obj.alphaRegret = message.alphaRegret;
    }
    if (message.allowNegative !== false) {
      obj.allowNegative = message.allowNegative;
    }
    if (message.epsilon !== "") {
      obj.epsilon = message.epsilon;
    }
    if (message.workerSubmissionWindow !== "0") {
      obj.workerSubmissionWindow = message.workerSubmissionWindow;
    }
    if (message.meritSortitionAlpha !== "") {
      obj.meritSortitionAlpha = message.meritSortitionAlpha;
    }
    if (message.activeInfererQuantile !== "") {
      obj.activeInfererQuantile = message.activeInfererQuantile;
    }
    if (message.activeForecasterQuantile !== "") {
      obj.activeForecasterQuantile = message.activeForecasterQuantile;
    }
    if (message.activeReputerQuantile !== "") {
      obj.activeReputerQuantile = message.activeReputerQuantile;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNewTopicRequest>): CreateNewTopicRequest {
    return CreateNewTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNewTopicRequest>): CreateNewTopicRequest {
    const message = createBaseCreateNewTopicRequest();
    message.creator = object.creator ?? "";
    message.metadata = object.metadata ?? "";
    message.lossMethod = object.lossMethod ?? "";
    message.epochLength = object.epochLength ?? "0";
    message.groundTruthLag = object.groundTruthLag ?? "0";
    message.pNorm = object.pNorm ?? "";
    message.alphaRegret = object.alphaRegret ?? "";
    message.allowNegative = object.allowNegative ?? false;
    message.epsilon = object.epsilon ?? "";
    message.workerSubmissionWindow = object.workerSubmissionWindow ?? "0";
    message.meritSortitionAlpha = object.meritSortitionAlpha ?? "";
    message.activeInfererQuantile = object.activeInfererQuantile ?? "";
    message.activeForecasterQuantile = object.activeForecasterQuantile ?? "";
    message.activeReputerQuantile = object.activeReputerQuantile ?? "";
    return message;
  },
};

function createBaseCreateNewTopicResponse(): CreateNewTopicResponse {
  return { topicId: "0" };
}

export const CreateNewTopicResponse: MessageFns<CreateNewTopicResponse> = {
  encode(message: CreateNewTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNewTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNewTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNewTopicResponse {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: CreateNewTopicResponse): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNewTopicResponse>): CreateNewTopicResponse {
    return CreateNewTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNewTopicResponse>): CreateNewTopicResponse {
    const message = createBaseCreateNewTopicResponse();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseInsertReputerPayloadRequest(): InsertReputerPayloadRequest {
  return { sender: "", reputerValueBundle: undefined };
}

export const InsertReputerPayloadRequest: MessageFns<InsertReputerPayloadRequest> = {
  encode(message: InsertReputerPayloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.reputerValueBundle !== undefined) {
      ReputerValueBundle.encode(message.reputerValueBundle, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertReputerPayloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertReputerPayloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputerValueBundle = ReputerValueBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertReputerPayloadRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      reputerValueBundle: isSet(object.reputerValueBundle)
        ? ReputerValueBundle.fromJSON(object.reputerValueBundle)
        : undefined,
    };
  },

  toJSON(message: InsertReputerPayloadRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.reputerValueBundle !== undefined) {
      obj.reputerValueBundle = ReputerValueBundle.toJSON(message.reputerValueBundle);
    }
    return obj;
  },

  create(base?: DeepPartial<InsertReputerPayloadRequest>): InsertReputerPayloadRequest {
    return InsertReputerPayloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertReputerPayloadRequest>): InsertReputerPayloadRequest {
    const message = createBaseInsertReputerPayloadRequest();
    message.sender = object.sender ?? "";
    message.reputerValueBundle = (object.reputerValueBundle !== undefined && object.reputerValueBundle !== null)
      ? ReputerValueBundle.fromPartial(object.reputerValueBundle)
      : undefined;
    return message;
  },
};

function createBaseInsertReputerPayloadResponse(): InsertReputerPayloadResponse {
  return {};
}

export const InsertReputerPayloadResponse: MessageFns<InsertReputerPayloadResponse> = {
  encode(_: InsertReputerPayloadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertReputerPayloadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertReputerPayloadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InsertReputerPayloadResponse {
    return {};
  },

  toJSON(_: InsertReputerPayloadResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InsertReputerPayloadResponse>): InsertReputerPayloadResponse {
    return InsertReputerPayloadResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InsertReputerPayloadResponse>): InsertReputerPayloadResponse {
    const message = createBaseInsertReputerPayloadResponse();
    return message;
  },
};

function createBaseInsertWorkerPayloadRequest(): InsertWorkerPayloadRequest {
  return { sender: "", workerDataBundle: undefined };
}

export const InsertWorkerPayloadRequest: MessageFns<InsertWorkerPayloadRequest> = {
  encode(message: InsertWorkerPayloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.workerDataBundle !== undefined) {
      WorkerDataBundle.encode(message.workerDataBundle, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertWorkerPayloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertWorkerPayloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerDataBundle = WorkerDataBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertWorkerPayloadRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      workerDataBundle: isSet(object.workerDataBundle) ? WorkerDataBundle.fromJSON(object.workerDataBundle) : undefined,
    };
  },

  toJSON(message: InsertWorkerPayloadRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.workerDataBundle !== undefined) {
      obj.workerDataBundle = WorkerDataBundle.toJSON(message.workerDataBundle);
    }
    return obj;
  },

  create(base?: DeepPartial<InsertWorkerPayloadRequest>): InsertWorkerPayloadRequest {
    return InsertWorkerPayloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertWorkerPayloadRequest>): InsertWorkerPayloadRequest {
    const message = createBaseInsertWorkerPayloadRequest();
    message.sender = object.sender ?? "";
    message.workerDataBundle = (object.workerDataBundle !== undefined && object.workerDataBundle !== null)
      ? WorkerDataBundle.fromPartial(object.workerDataBundle)
      : undefined;
    return message;
  },
};

function createBaseInsertWorkerPayloadResponse(): InsertWorkerPayloadResponse {
  return {};
}

export const InsertWorkerPayloadResponse: MessageFns<InsertWorkerPayloadResponse> = {
  encode(_: InsertWorkerPayloadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertWorkerPayloadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertWorkerPayloadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InsertWorkerPayloadResponse {
    return {};
  },

  toJSON(_: InsertWorkerPayloadResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InsertWorkerPayloadResponse>): InsertWorkerPayloadResponse {
    return InsertWorkerPayloadResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InsertWorkerPayloadResponse>): InsertWorkerPayloadResponse {
    const message = createBaseInsertWorkerPayloadResponse();
    return message;
  },
};

function createBaseRegisterRequest(): RegisterRequest {
  return { sender: "", topicId: "0", owner: "", isReputer: false };
}

export const RegisterRequest: MessageFns<RegisterRequest> = {
  encode(message: RegisterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(32).uint64(message.topicId);
    }
    if (message.owner !== "") {
      writer.uint32(42).string(message.owner);
    }
    if (message.isReputer !== false) {
      writer.uint32(48).bool(message.isReputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isReputer = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      isReputer: isSet(object.isReputer) ? globalThis.Boolean(object.isReputer) : false,
    };
  },

  toJSON(message: RegisterRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.isReputer !== false) {
      obj.isReputer = message.isReputer;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterRequest>): RegisterRequest {
    return RegisterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterRequest>): RegisterRequest {
    const message = createBaseRegisterRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.owner = object.owner ?? "";
    message.isReputer = object.isReputer ?? false;
    return message;
  },
};

function createBaseRegisterResponse(): RegisterResponse {
  return { success: false, message: "" };
}

export const RegisterResponse: MessageFns<RegisterResponse> = {
  encode(message: RegisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RegisterResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterResponse>): RegisterResponse {
    return RegisterResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterResponse>): RegisterResponse {
    const message = createBaseRegisterResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRemoveRegistrationRequest(): RemoveRegistrationRequest {
  return { sender: "", topicId: "0", isReputer: false };
}

export const RemoveRegistrationRequest: MessageFns<RemoveRegistrationRequest> = {
  encode(message: RemoveRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.isReputer !== false) {
      writer.uint32(24).bool(message.isReputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isReputer = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveRegistrationRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      isReputer: isSet(object.isReputer) ? globalThis.Boolean(object.isReputer) : false,
    };
  },

  toJSON(message: RemoveRegistrationRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.isReputer !== false) {
      obj.isReputer = message.isReputer;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveRegistrationRequest>): RemoveRegistrationRequest {
    return RemoveRegistrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveRegistrationRequest>): RemoveRegistrationRequest {
    const message = createBaseRemoveRegistrationRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.isReputer = object.isReputer ?? false;
    return message;
  },
};

function createBaseRemoveRegistrationResponse(): RemoveRegistrationResponse {
  return { success: false, message: "" };
}

export const RemoveRegistrationResponse: MessageFns<RemoveRegistrationResponse> = {
  encode(message: RemoveRegistrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveRegistrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveRegistrationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RemoveRegistrationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveRegistrationResponse>): RemoveRegistrationResponse {
    return RemoveRegistrationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveRegistrationResponse>): RemoveRegistrationResponse {
    const message = createBaseRemoveRegistrationResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAddStakeRequest(): AddStakeRequest {
  return { sender: "", topicId: "0", amount: "" };
}

export const AddStakeRequest: MessageFns<AddStakeRequest> = {
  encode(message: AddStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddStakeRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: AddStakeRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<AddStakeRequest>): AddStakeRequest {
    return AddStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddStakeRequest>): AddStakeRequest {
    const message = createBaseAddStakeRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseAddStakeResponse(): AddStakeResponse {
  return {};
}

export const AddStakeResponse: MessageFns<AddStakeResponse> = {
  encode(_: AddStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddStakeResponse {
    return {};
  },

  toJSON(_: AddStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AddStakeResponse>): AddStakeResponse {
    return AddStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AddStakeResponse>): AddStakeResponse {
    const message = createBaseAddStakeResponse();
    return message;
  },
};

function createBaseRemoveStakeRequest(): RemoveStakeRequest {
  return { sender: "", topicId: "0", amount: "" };
}

export const RemoveStakeRequest: MessageFns<RemoveStakeRequest> = {
  encode(message: RemoveStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveStakeRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: RemoveStakeRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveStakeRequest>): RemoveStakeRequest {
    return RemoveStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveStakeRequest>): RemoveStakeRequest {
    const message = createBaseRemoveStakeRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseRemoveStakeResponse(): RemoveStakeResponse {
  return {};
}

export const RemoveStakeResponse: MessageFns<RemoveStakeResponse> = {
  encode(_: RemoveStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveStakeResponse {
    return {};
  },

  toJSON(_: RemoveStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoveStakeResponse>): RemoveStakeResponse {
    return RemoveStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoveStakeResponse>): RemoveStakeResponse {
    const message = createBaseRemoveStakeResponse();
    return message;
  },
};

function createBaseCancelRemoveStakeRequest(): CancelRemoveStakeRequest {
  return { sender: "", topicId: "0" };
}

export const CancelRemoveStakeRequest: MessageFns<CancelRemoveStakeRequest> = {
  encode(message: CancelRemoveStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelRemoveStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelRemoveStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelRemoveStakeRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: CancelRemoveStakeRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelRemoveStakeRequest>): CancelRemoveStakeRequest {
    return CancelRemoveStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelRemoveStakeRequest>): CancelRemoveStakeRequest {
    const message = createBaseCancelRemoveStakeRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseCancelRemoveStakeResponse(): CancelRemoveStakeResponse {
  return {};
}

export const CancelRemoveStakeResponse: MessageFns<CancelRemoveStakeResponse> = {
  encode(_: CancelRemoveStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelRemoveStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelRemoveStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelRemoveStakeResponse {
    return {};
  },

  toJSON(_: CancelRemoveStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CancelRemoveStakeResponse>): CancelRemoveStakeResponse {
    return CancelRemoveStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CancelRemoveStakeResponse>): CancelRemoveStakeResponse {
    const message = createBaseCancelRemoveStakeResponse();
    return message;
  },
};

function createBaseDelegateStakeRequest(): DelegateStakeRequest {
  return { sender: "", topicId: "0", reputer: "", amount: "" };
}

export const DelegateStakeRequest: MessageFns<DelegateStakeRequest> = {
  encode(message: DelegateStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(26).string(message.reputer);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegateStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegateStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DelegateStakeRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: DelegateStakeRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<DelegateStakeRequest>): DelegateStakeRequest {
    return DelegateStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DelegateStakeRequest>): DelegateStakeRequest {
    const message = createBaseDelegateStakeRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseDelegateStakeResponse(): DelegateStakeResponse {
  return {};
}

export const DelegateStakeResponse: MessageFns<DelegateStakeResponse> = {
  encode(_: DelegateStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegateStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegateStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DelegateStakeResponse {
    return {};
  },

  toJSON(_: DelegateStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DelegateStakeResponse>): DelegateStakeResponse {
    return DelegateStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DelegateStakeResponse>): DelegateStakeResponse {
    const message = createBaseDelegateStakeResponse();
    return message;
  },
};

function createBaseRemoveDelegateStakeRequest(): RemoveDelegateStakeRequest {
  return { sender: "", reputer: "", topicId: "0", amount: "" };
}

export const RemoveDelegateStakeRequest: MessageFns<RemoveDelegateStakeRequest> = {
  encode(message: RemoveDelegateStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.reputer !== "") {
      writer.uint32(18).string(message.reputer);
    }
    if (message.topicId !== "0") {
      writer.uint32(24).uint64(message.topicId);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDelegateStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveDelegateStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveDelegateStakeRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: RemoveDelegateStakeRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveDelegateStakeRequest>): RemoveDelegateStakeRequest {
    return RemoveDelegateStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveDelegateStakeRequest>): RemoveDelegateStakeRequest {
    const message = createBaseRemoveDelegateStakeRequest();
    message.sender = object.sender ?? "";
    message.reputer = object.reputer ?? "";
    message.topicId = object.topicId ?? "0";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseRemoveDelegateStakeResponse(): RemoveDelegateStakeResponse {
  return {};
}

export const RemoveDelegateStakeResponse: MessageFns<RemoveDelegateStakeResponse> = {
  encode(_: RemoveDelegateStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDelegateStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveDelegateStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveDelegateStakeResponse {
    return {};
  },

  toJSON(_: RemoveDelegateStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoveDelegateStakeResponse>): RemoveDelegateStakeResponse {
    return RemoveDelegateStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoveDelegateStakeResponse>): RemoveDelegateStakeResponse {
    const message = createBaseRemoveDelegateStakeResponse();
    return message;
  },
};

function createBaseCancelRemoveDelegateStakeRequest(): CancelRemoveDelegateStakeRequest {
  return { sender: "", topicId: "0", delegator: "", reputer: "" };
}

export const CancelRemoveDelegateStakeRequest: MessageFns<CancelRemoveDelegateStakeRequest> = {
  encode(message: CancelRemoveDelegateStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.delegator !== "") {
      writer.uint32(26).string(message.delegator);
    }
    if (message.reputer !== "") {
      writer.uint32(34).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelRemoveDelegateStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelRemoveDelegateStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delegator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelRemoveDelegateStakeRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      delegator: isSet(object.delegator) ? globalThis.String(object.delegator) : "",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: CancelRemoveDelegateStakeRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.delegator !== "") {
      obj.delegator = message.delegator;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelRemoveDelegateStakeRequest>): CancelRemoveDelegateStakeRequest {
    return CancelRemoveDelegateStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelRemoveDelegateStakeRequest>): CancelRemoveDelegateStakeRequest {
    const message = createBaseCancelRemoveDelegateStakeRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.delegator = object.delegator ?? "";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseCancelRemoveDelegateStakeResponse(): CancelRemoveDelegateStakeResponse {
  return {};
}

export const CancelRemoveDelegateStakeResponse: MessageFns<CancelRemoveDelegateStakeResponse> = {
  encode(_: CancelRemoveDelegateStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelRemoveDelegateStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelRemoveDelegateStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelRemoveDelegateStakeResponse {
    return {};
  },

  toJSON(_: CancelRemoveDelegateStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CancelRemoveDelegateStakeResponse>): CancelRemoveDelegateStakeResponse {
    return CancelRemoveDelegateStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CancelRemoveDelegateStakeResponse>): CancelRemoveDelegateStakeResponse {
    const message = createBaseCancelRemoveDelegateStakeResponse();
    return message;
  },
};

function createBaseRewardDelegateStakeRequest(): RewardDelegateStakeRequest {
  return { sender: "", topicId: "0", reputer: "" };
}

export const RewardDelegateStakeRequest: MessageFns<RewardDelegateStakeRequest> = {
  encode(message: RewardDelegateStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(26).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RewardDelegateStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardDelegateStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RewardDelegateStakeRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: RewardDelegateStakeRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<RewardDelegateStakeRequest>): RewardDelegateStakeRequest {
    return RewardDelegateStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RewardDelegateStakeRequest>): RewardDelegateStakeRequest {
    const message = createBaseRewardDelegateStakeRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseRewardDelegateStakeResponse(): RewardDelegateStakeResponse {
  return {};
}

export const RewardDelegateStakeResponse: MessageFns<RewardDelegateStakeResponse> = {
  encode(_: RewardDelegateStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RewardDelegateStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardDelegateStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RewardDelegateStakeResponse {
    return {};
  },

  toJSON(_: RewardDelegateStakeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RewardDelegateStakeResponse>): RewardDelegateStakeResponse {
    return RewardDelegateStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RewardDelegateStakeResponse>): RewardDelegateStakeResponse {
    const message = createBaseRewardDelegateStakeResponse();
    return message;
  },
};

function createBaseFundTopicRequest(): FundTopicRequest {
  return { sender: "", topicId: "0", amount: "" };
}

export const FundTopicRequest: MessageFns<FundTopicRequest> = {
  encode(message: FundTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FundTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FundTopicRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: FundTopicRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<FundTopicRequest>): FundTopicRequest {
    return FundTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FundTopicRequest>): FundTopicRequest {
    const message = createBaseFundTopicRequest();
    message.sender = object.sender ?? "";
    message.topicId = object.topicId ?? "0";
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseFundTopicResponse(): FundTopicResponse {
  return {};
}

export const FundTopicResponse: MessageFns<FundTopicResponse> = {
  encode(_: FundTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FundTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFundTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FundTopicResponse {
    return {};
  },

  toJSON(_: FundTopicResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FundTopicResponse>): FundTopicResponse {
    return FundTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<FundTopicResponse>): FundTopicResponse {
    const message = createBaseFundTopicResponse();
    return message;
  },
};

function createBaseAddToWhitelistAdminRequest(): AddToWhitelistAdminRequest {
  return { sender: "", address: "" };
}

export const AddToWhitelistAdminRequest: MessageFns<AddToWhitelistAdminRequest> = {
  encode(message: AddToWhitelistAdminRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddToWhitelistAdminRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddToWhitelistAdminRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddToWhitelistAdminRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: AddToWhitelistAdminRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<AddToWhitelistAdminRequest>): AddToWhitelistAdminRequest {
    return AddToWhitelistAdminRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddToWhitelistAdminRequest>): AddToWhitelistAdminRequest {
    const message = createBaseAddToWhitelistAdminRequest();
    message.sender = object.sender ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseAddToWhitelistAdminResponse(): AddToWhitelistAdminResponse {
  return {};
}

export const AddToWhitelistAdminResponse: MessageFns<AddToWhitelistAdminResponse> = {
  encode(_: AddToWhitelistAdminResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddToWhitelistAdminResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddToWhitelistAdminResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddToWhitelistAdminResponse {
    return {};
  },

  toJSON(_: AddToWhitelistAdminResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AddToWhitelistAdminResponse>): AddToWhitelistAdminResponse {
    return AddToWhitelistAdminResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AddToWhitelistAdminResponse>): AddToWhitelistAdminResponse {
    const message = createBaseAddToWhitelistAdminResponse();
    return message;
  },
};

function createBaseRemoveFromWhitelistAdminRequest(): RemoveFromWhitelistAdminRequest {
  return { sender: "", address: "" };
}

export const RemoveFromWhitelistAdminRequest: MessageFns<RemoveFromWhitelistAdminRequest> = {
  encode(message: RemoveFromWhitelistAdminRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFromWhitelistAdminRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFromWhitelistAdminRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFromWhitelistAdminRequest {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: RemoveFromWhitelistAdminRequest): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveFromWhitelistAdminRequest>): RemoveFromWhitelistAdminRequest {
    return RemoveFromWhitelistAdminRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveFromWhitelistAdminRequest>): RemoveFromWhitelistAdminRequest {
    const message = createBaseRemoveFromWhitelistAdminRequest();
    message.sender = object.sender ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseRemoveFromWhitelistAdminResponse(): RemoveFromWhitelistAdminResponse {
  return {};
}

export const RemoveFromWhitelistAdminResponse: MessageFns<RemoveFromWhitelistAdminResponse> = {
  encode(_: RemoveFromWhitelistAdminResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFromWhitelistAdminResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFromWhitelistAdminResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveFromWhitelistAdminResponse {
    return {};
  },

  toJSON(_: RemoveFromWhitelistAdminResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoveFromWhitelistAdminResponse>): RemoveFromWhitelistAdminResponse {
    return RemoveFromWhitelistAdminResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoveFromWhitelistAdminResponse>): RemoveFromWhitelistAdminResponse {
    const message = createBaseRemoveFromWhitelistAdminResponse();
    return message;
  },
};

/** Msg defines the module Msg service. */
export interface MsgService {
  UpdateParams(request: UpdateParamsRequest): Promise<UpdateParamsResponse>;
  CreateNewTopic(request: CreateNewTopicRequest): Promise<CreateNewTopicResponse>;
  Register(request: RegisterRequest): Promise<RegisterResponse>;
  RemoveRegistration(request: RemoveRegistrationRequest): Promise<RemoveRegistrationResponse>;
  AddStake(request: AddStakeRequest): Promise<AddStakeResponse>;
  RemoveStake(request: RemoveStakeRequest): Promise<RemoveStakeResponse>;
  CancelRemoveStake(request: CancelRemoveStakeRequest): Promise<CancelRemoveStakeResponse>;
  DelegateStake(request: DelegateStakeRequest): Promise<DelegateStakeResponse>;
  RewardDelegateStake(request: RewardDelegateStakeRequest): Promise<RewardDelegateStakeResponse>;
  RemoveDelegateStake(request: RemoveDelegateStakeRequest): Promise<RemoveDelegateStakeResponse>;
  CancelRemoveDelegateStake(request: CancelRemoveDelegateStakeRequest): Promise<CancelRemoveDelegateStakeResponse>;
  FundTopic(request: FundTopicRequest): Promise<FundTopicResponse>;
  AddToWhitelistAdmin(request: AddToWhitelistAdminRequest): Promise<AddToWhitelistAdminResponse>;
  RemoveFromWhitelistAdmin(request: RemoveFromWhitelistAdminRequest): Promise<RemoveFromWhitelistAdminResponse>;
  InsertWorkerPayload(request: InsertWorkerPayloadRequest): Promise<InsertWorkerPayloadResponse>;
  InsertReputerPayload(request: InsertReputerPayloadRequest): Promise<InsertReputerPayloadResponse>;
}

export const MsgServiceServiceName = "emissions.v5.MsgService";
export class MsgServiceClientImpl implements MsgService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.CreateNewTopic = this.CreateNewTopic.bind(this);
    this.Register = this.Register.bind(this);
    this.RemoveRegistration = this.RemoveRegistration.bind(this);
    this.AddStake = this.AddStake.bind(this);
    this.RemoveStake = this.RemoveStake.bind(this);
    this.CancelRemoveStake = this.CancelRemoveStake.bind(this);
    this.DelegateStake = this.DelegateStake.bind(this);
    this.RewardDelegateStake = this.RewardDelegateStake.bind(this);
    this.RemoveDelegateStake = this.RemoveDelegateStake.bind(this);
    this.CancelRemoveDelegateStake = this.CancelRemoveDelegateStake.bind(this);
    this.FundTopic = this.FundTopic.bind(this);
    this.AddToWhitelistAdmin = this.AddToWhitelistAdmin.bind(this);
    this.RemoveFromWhitelistAdmin = this.RemoveFromWhitelistAdmin.bind(this);
    this.InsertWorkerPayload = this.InsertWorkerPayload.bind(this);
    this.InsertReputerPayload = this.InsertReputerPayload.bind(this);
  }
  UpdateParams(request: UpdateParamsRequest): Promise<UpdateParamsResponse> {
    const data = UpdateParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => UpdateParamsResponse.decode(new BinaryReader(data)));
  }

  CreateNewTopic(request: CreateNewTopicRequest): Promise<CreateNewTopicResponse> {
    const data = CreateNewTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateNewTopic", data);
    return promise.then((data) => CreateNewTopicResponse.decode(new BinaryReader(data)));
  }

  Register(request: RegisterRequest): Promise<RegisterResponse> {
    const data = RegisterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Register", data);
    return promise.then((data) => RegisterResponse.decode(new BinaryReader(data)));
  }

  RemoveRegistration(request: RemoveRegistrationRequest): Promise<RemoveRegistrationResponse> {
    const data = RemoveRegistrationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveRegistration", data);
    return promise.then((data) => RemoveRegistrationResponse.decode(new BinaryReader(data)));
  }

  AddStake(request: AddStakeRequest): Promise<AddStakeResponse> {
    const data = AddStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddStake", data);
    return promise.then((data) => AddStakeResponse.decode(new BinaryReader(data)));
  }

  RemoveStake(request: RemoveStakeRequest): Promise<RemoveStakeResponse> {
    const data = RemoveStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveStake", data);
    return promise.then((data) => RemoveStakeResponse.decode(new BinaryReader(data)));
  }

  CancelRemoveStake(request: CancelRemoveStakeRequest): Promise<CancelRemoveStakeResponse> {
    const data = CancelRemoveStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelRemoveStake", data);
    return promise.then((data) => CancelRemoveStakeResponse.decode(new BinaryReader(data)));
  }

  DelegateStake(request: DelegateStakeRequest): Promise<DelegateStakeResponse> {
    const data = DelegateStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DelegateStake", data);
    return promise.then((data) => DelegateStakeResponse.decode(new BinaryReader(data)));
  }

  RewardDelegateStake(request: RewardDelegateStakeRequest): Promise<RewardDelegateStakeResponse> {
    const data = RewardDelegateStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RewardDelegateStake", data);
    return promise.then((data) => RewardDelegateStakeResponse.decode(new BinaryReader(data)));
  }

  RemoveDelegateStake(request: RemoveDelegateStakeRequest): Promise<RemoveDelegateStakeResponse> {
    const data = RemoveDelegateStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveDelegateStake", data);
    return promise.then((data) => RemoveDelegateStakeResponse.decode(new BinaryReader(data)));
  }

  CancelRemoveDelegateStake(request: CancelRemoveDelegateStakeRequest): Promise<CancelRemoveDelegateStakeResponse> {
    const data = CancelRemoveDelegateStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelRemoveDelegateStake", data);
    return promise.then((data) => CancelRemoveDelegateStakeResponse.decode(new BinaryReader(data)));
  }

  FundTopic(request: FundTopicRequest): Promise<FundTopicResponse> {
    const data = FundTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FundTopic", data);
    return promise.then((data) => FundTopicResponse.decode(new BinaryReader(data)));
  }

  AddToWhitelistAdmin(request: AddToWhitelistAdminRequest): Promise<AddToWhitelistAdminResponse> {
    const data = AddToWhitelistAdminRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddToWhitelistAdmin", data);
    return promise.then((data) => AddToWhitelistAdminResponse.decode(new BinaryReader(data)));
  }

  RemoveFromWhitelistAdmin(request: RemoveFromWhitelistAdminRequest): Promise<RemoveFromWhitelistAdminResponse> {
    const data = RemoveFromWhitelistAdminRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveFromWhitelistAdmin", data);
    return promise.then((data) => RemoveFromWhitelistAdminResponse.decode(new BinaryReader(data)));
  }

  InsertWorkerPayload(request: InsertWorkerPayloadRequest): Promise<InsertWorkerPayloadResponse> {
    const data = InsertWorkerPayloadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InsertWorkerPayload", data);
    return promise.then((data) => InsertWorkerPayloadResponse.decode(new BinaryReader(data)));
  }

  InsertReputerPayload(request: InsertReputerPayloadRequest): Promise<InsertReputerPayloadResponse> {
    const data = InsertReputerPayloadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InsertReputerPayload", data);
    return promise.then((data) => InsertReputerPayloadResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
