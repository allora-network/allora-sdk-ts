// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: emissions/v5/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { RegretInformedWeight } from "../v3/inference";
import { OffchainNode } from "../v3/node";
import { Nonces, ReputerRequestNonces } from "../v3/nonce";
import { ReputerValueBundles, ValueBundle } from "../v3/reputer";
import { Score, Scores } from "../v3/score";
import { DelegateStakeRemovalInfo, DelegatorInfo, StakeInfo, StakeRemovalInfo } from "../v3/stake";
import { TimestampedActorNonce, Topic } from "../v3/topic";
import { ListeningCoefficient, SimpleCursorPaginationRequest, SimpleCursorPaginationResponse } from "../v3/types";
import { Forecasts, Inference, Inferences, TimestampedValue } from "../v3/worker";
import { Params } from "./params";

export const protobufPackage = "emissions.v5";

export interface GetCountInfererInclusionsInTopicRequest {
  topicId: string;
  inferer: string;
}

export interface GetCountInfererInclusionsInTopicResponse {
  count: string;
}

export interface GetCountForecasterInclusionsInTopicRequest {
  topicId: string;
  forecaster: string;
}

export interface GetCountForecasterInclusionsInTopicResponse {
  count: string;
}

export interface GetNaiveInfererNetworkRegretRequest {
  topicId: string;
  inferer: string;
}

export interface GetNaiveInfererNetworkRegretResponse {
  regret?: TimestampedValue | undefined;
}

export interface GetOneOutInfererInfererNetworkRegretRequest {
  topicId: string;
  oneOutInferer: string;
  inferer: string;
}

export interface GetOneOutInfererInfererNetworkRegretResponse {
  regret?: TimestampedValue | undefined;
}

export interface GetOneOutInfererForecasterNetworkRegretRequest {
  topicId: string;
  oneOutInferer: string;
  forecaster: string;
}

export interface GetOneOutInfererForecasterNetworkRegretResponse {
  regret?: TimestampedValue | undefined;
}

export interface GetOneOutForecasterInfererNetworkRegretRequest {
  topicId: string;
  oneOutForecaster: string;
  inferer: string;
}

export interface GetOneOutForecasterInfererNetworkRegretResponse {
  regret?: TimestampedValue | undefined;
}

export interface GetOneOutForecasterForecasterNetworkRegretRequest {
  topicId: string;
  oneOutForecaster: string;
  forecaster: string;
}

export interface GetOneOutForecasterForecasterNetworkRegretResponse {
  regret?: TimestampedValue | undefined;
}

/** GetParamsRequest is the request type for the Get/Params RPC method. */
export interface GetParamsRequest {
}

/** GetParamsResponse is the response type for the Get/Params RPC method. */
export interface GetParamsResponse {
  /** params defines the parameters of the module. */
  params?: Params | undefined;
}

/** Total Stake returns the total amount of stake in the system */
export interface GetTotalStakeRequest {
}

/**
 * Total Stake returns the total amount of stake in the system
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
export interface GetTotalStakeResponse {
  amount: string;
}

export interface GetReputerStakeInTopicRequest {
  address: string;
  topicId: string;
}

export interface GetReputerStakeInTopicResponse {
  amount: string;
}

export interface GetMultiReputerStakeInTopicRequest {
  addresses: string[];
  topicId: string;
}

export interface GetMultiReputerStakeInTopicResponse {
  amounts: StakeInfo[];
}

export interface GetStakeFromReputerInTopicInSelfRequest {
  reputerAddress: string;
  topicId: string;
}

export interface GetStakeFromReputerInTopicInSelfResponse {
  amount: string;
}

export interface GetDelegateStakeInTopicInReputerRequest {
  reputerAddress: string;
  topicId: string;
}

export interface GetDelegateStakeInTopicInReputerResponse {
  amount: string;
}

export interface GetStakeFromDelegatorInTopicInReputerRequest {
  delegatorAddress: string;
  reputerAddress: string;
  topicId: string;
}

export interface GetStakeFromDelegatorInTopicInReputerResponse {
  amount: string;
}

export interface GetStakeFromDelegatorInTopicRequest {
  delegatorAddress: string;
  topicId: string;
}

export interface GetStakeFromDelegatorInTopicResponse {
  amount: string;
}

export interface GetTopicStakeRequest {
  topicId: string;
}

export interface GetTopicStakeResponse {
  amount: string;
}

export interface GetNetworkLossBundleAtBlockRequest {
  topicId: string;
  blockHeight: string;
}

export interface GetNetworkLossBundleAtBlockResponse {
  lossBundle?: ValueBundle | undefined;
}

export interface GetNextTopicIdRequest {
}

export interface GetNextTopicIdResponse {
  nextTopicId: string;
}

export interface GetTopicRequest {
  topicId: string;
}

export interface GetTopicResponse {
  topic?: Topic | undefined;
  weight: string;
  effectiveRevenue: string;
}

export interface GetActiveTopicsRequest {
  pagination?: SimpleCursorPaginationRequest | undefined;
}

export interface GetActiveTopicsResponse {
  topics: Topic[];
  pagination?: SimpleCursorPaginationResponse | undefined;
}

/** Returns the inferences on a topic posted at a block height */
export interface GetInferencesAtBlockRequest {
  topicId: string;
  blockHeight: string;
}

/**
 * Returns the inferences on a topic posted at a block height
 *
 * NOTE: The amount field is a Uint which implements the custom method
 * signatures required by gogoproto.
 */
export interface GetInferencesAtBlockResponse {
  inferences?: Inferences | undefined;
}

export interface GetLatestTopicInferencesRequest {
  topicId: string;
}

export interface GetLatestTopicInferencesResponse {
  inferences?: Inferences | undefined;
  blockHeight: string;
}

/** Returns the forecasts on a topic posted at a block height */
export interface GetForecastsAtBlockRequest {
  topicId: string;
  blockHeight: string;
}

/**
 * Returns the forecasts on a topic posted at a block height
 *
 * NOTE: The amount field is a Uint which implements the custom method
 * signatures required by gogoproto.
 */
export interface GetForecastsAtBlockResponse {
  forecasts?: Forecasts | undefined;
}

export interface GetWorkerLatestInferenceByTopicIdRequest {
  topicId: string;
  workerAddress: string;
}

export interface GetWorkerLatestInferenceByTopicIdResponse {
  latestInference?: Inference | undefined;
}

export interface GetWorkerNodeInfoRequest {
  address: string;
}

export interface GetWorkerNodeInfoResponse {
  nodeInfo?: OffchainNode | undefined;
}

export interface GetReputerNodeInfoRequest {
  address: string;
}

export interface GetReputerNodeInfoResponse {
  nodeInfo?: OffchainNode | undefined;
}

export interface GetNetworkInferencesAtBlockRequest {
  topicId: string;
  blockHeightLastInference: string;
}

export interface GetLatestNetworkInferencesRequest {
  topicId: string;
}

export interface GetLatestAvailableNetworkInferencesRequest {
  topicId: string;
}

export interface IsWorkerNonceUnfulfilledRequest {
  topicId: string;
  blockHeight: string;
}

export interface IsWorkerNonceUnfulfilledResponse {
  isWorkerNonceUnfulfilled: boolean;
}

export interface GetUnfulfilledReputerNoncesRequest {
  topicId: string;
}

export interface GetUnfulfilledReputerNoncesResponse {
  nonces?: ReputerRequestNonces | undefined;
}

export interface GetUnfulfilledWorkerNoncesRequest {
  topicId: string;
}

export interface GetUnfulfilledWorkerNoncesResponse {
  nonces?: Nonces | undefined;
}

export interface GetInfererNetworkRegretRequest {
  topicId: string;
  actorId: string;
}

export interface GetInfererNetworkRegretResponse {
  regret?: TimestampedValue | undefined;
}

export interface GetForecasterNetworkRegretRequest {
  topicId: string;
  worker: string;
}

export interface GetForecasterNetworkRegretResponse {
  regret?: TimestampedValue | undefined;
}

export interface GetOneInForecasterNetworkRegretRequest {
  topicId: string;
  forecaster: string;
  inferer: string;
}

export interface GetOneInForecasterNetworkRegretResponse {
  regret?: TimestampedValue | undefined;
}

export interface IsReputerNonceUnfulfilledRequest {
  topicId: string;
  blockHeight: string;
}

export interface IsReputerNonceUnfulfilledResponse {
  isReputerNonceUnfulfilled: boolean;
}

export interface GetNetworkInferencesAtBlockResponse {
  networkInferences?: ValueBundle | undefined;
}

export interface GetLatestNetworkInferencesResponse {
  networkInferences?: ValueBundle | undefined;
  infererWeights: RegretInformedWeight[];
  forecasterWeights: RegretInformedWeight[];
  inferenceBlockHeight: string;
  lossBlockHeight: string;
  confidenceIntervalRawPercentiles: string[];
  confidenceIntervalValues: string[];
}

export interface GetLatestAvailableNetworkInferencesResponse {
  networkInferences?: ValueBundle | undefined;
  infererWeights: RegretInformedWeight[];
  forecasterWeights: RegretInformedWeight[];
  inferenceBlockHeight: string;
  lossBlockHeight: string;
  confidenceIntervalRawPercentiles: string[];
  confidenceIntervalValues: string[];
}

export interface IsWorkerRegisteredInTopicIdRequest {
  topicId: string;
  address: string;
}

export interface IsWorkerRegisteredInTopicIdResponse {
  isRegistered: boolean;
}

export interface IsReputerRegisteredInTopicIdRequest {
  topicId: string;
  address: string;
}

export interface IsReputerRegisteredInTopicIdResponse {
  isRegistered: boolean;
}

export interface IsWhitelistAdminRequest {
  address: string;
}

export interface IsWhitelistAdminResponse {
  isAdmin: boolean;
}

export interface GetStakeRemovalsUpUntilBlockRequest {
  blockHeight: string;
}

export interface GetStakeRemovalsUpUntilBlockResponse {
  removals: StakeRemovalInfo[];
}

export interface GetDelegateStakeRemovalsUpUntilBlockRequest {
  blockHeight: string;
}

export interface GetDelegateStakeRemovalsUpUntilBlockResponse {
  removals: DelegateStakeRemovalInfo[];
}

export interface GetStakeRemovalInfoRequest {
  topicId: string;
  reputer: string;
}

export interface GetStakeRemovalInfoResponse {
  removal?: StakeRemovalInfo | undefined;
}

export interface GetDelegateStakeRemovalInfoRequest {
  topicId: string;
  delegator: string;
  reputer: string;
}

export interface GetDelegateStakeRemovalInfoResponse {
  removal?: DelegateStakeRemovalInfo | undefined;
}

export interface GetTopicLastWorkerCommitInfoRequest {
  topicId: string;
}

export interface GetTopicLastWorkerCommitInfoResponse {
  lastCommit?: TimestampedActorNonce | undefined;
}

export interface GetTopicLastReputerCommitInfoRequest {
  topicId: string;
}

export interface GetTopicLastReputerCommitInfoResponse {
  lastCommit?: TimestampedActorNonce | undefined;
}

export interface GetTopicRewardNonceRequest {
  topicId: string;
}

export interface GetTopicRewardNonceResponse {
  nonce: string;
}

export interface GetReputerLossBundlesAtBlockRequest {
  topicId: string;
  blockHeight: string;
}

export interface GetReputerLossBundlesAtBlockResponse {
  lossBundles?: ReputerValueBundles | undefined;
}

export interface GetStakeReputerAuthorityRequest {
  topicId: string;
  reputer: string;
}

export interface GetStakeReputerAuthorityResponse {
  authority: string;
}

export interface GetDelegateStakePlacementRequest {
  topicId: string;
  delegator: string;
  target: string;
}

export interface GetDelegateStakePlacementResponse {
  delegatorInfo?: DelegatorInfo | undefined;
}

export interface GetDelegateStakeUponReputerRequest {
  topicId: string;
  target: string;
}

export interface GetDelegateStakeUponReputerResponse {
  stake: string;
}

export interface GetDelegateRewardPerShareRequest {
  topicId: string;
  reputer: string;
}

export interface GetDelegateRewardPerShareResponse {
  rewardPerShare: string;
}

export interface GetStakeRemovalForReputerAndTopicIdRequest {
  reputer: string;
  topicId: string;
}

export interface GetStakeRemovalForReputerAndTopicIdResponse {
  stakeRemovalInfo?: StakeRemovalInfo | undefined;
}

export interface GetDelegateStakeRemovalRequest {
  blockHeight: string;
  topicId: string;
  delegator: string;
  reputer: string;
}

export interface GetDelegateStakeRemovalResponse {
  stakeRemovalInfo?: DelegateStakeRemovalInfo | undefined;
}

export interface GetPreviousTopicWeightRequest {
  topicId: string;
}

export interface GetPreviousTopicWeightResponse {
  weight: string;
  notFound: boolean;
}

export interface GetTotalSumPreviousTopicWeightsRequest {
}

export interface GetTotalSumPreviousTopicWeightsResponse {
  weight: string;
}

export interface TopicExistsRequest {
  topicId: string;
}

export interface TopicExistsResponse {
  exists: boolean;
}

export interface IsTopicActiveRequest {
  topicId: string;
}

export interface IsTopicActiveResponse {
  isActive: boolean;
}

export interface GetTopicFeeRevenueRequest {
  topicId: string;
}

export interface GetTopicFeeRevenueResponse {
  feeRevenue: string;
}

export interface GetInfererScoreEmaRequest {
  topicId: string;
  inferer: string;
}

export interface GetInfererScoreEmaResponse {
  score?: Score | undefined;
}

export interface GetForecasterScoreEmaRequest {
  topicId: string;
  forecaster: string;
}

export interface GetForecasterScoreEmaResponse {
  score?: Score | undefined;
}

export interface GetReputerScoreEmaRequest {
  topicId: string;
  reputer: string;
}

export interface GetReputerScoreEmaResponse {
  score?: Score | undefined;
}

export interface GetInferenceScoresUntilBlockRequest {
  topicId: string;
  blockHeight: string;
}

export interface GetInferenceScoresUntilBlockResponse {
  scores: Score[];
}

export interface GetPreviousTopicQuantileForecasterScoreEmaRequest {
  topicId: string;
}

export interface GetPreviousTopicQuantileForecasterScoreEmaResponse {
  value: string;
}

export interface GetPreviousTopicQuantileInfererScoreEmaRequest {
  topicId: string;
}

export interface GetPreviousTopicQuantileInfererScoreEmaResponse {
  value: string;
}

export interface GetPreviousTopicQuantileReputerScoreEmaRequest {
  topicId: string;
}

export interface GetPreviousTopicQuantileReputerScoreEmaResponse {
  value: string;
}

export interface GetWorkerInferenceScoresAtBlockRequest {
  topicId: string;
  blockHeight: string;
}

export interface GetWorkerInferenceScoresAtBlockResponse {
  scores?: Scores | undefined;
}

export interface GetCurrentLowestInfererScoreRequest {
  topicId: string;
}

export interface GetCurrentLowestInfererScoreResponse {
  score?: Score | undefined;
}

export interface GetForecastScoresUntilBlockRequest {
  topicId: string;
  blockHeight: string;
}

export interface GetForecastScoresUntilBlockResponse {
  scores: Score[];
}

export interface GetWorkerForecastScoresAtBlockRequest {
  topicId: string;
  blockHeight: string;
}

export interface GetWorkerForecastScoresAtBlockResponse {
  scores?: Scores | undefined;
}

export interface GetCurrentLowestForecasterScoreRequest {
  topicId: string;
}

export interface GetCurrentLowestForecasterScoreResponse {
  score?: Score | undefined;
}

export interface GetReputersScoresAtBlockRequest {
  topicId: string;
  blockHeight: string;
}

export interface GetReputersScoresAtBlockResponse {
  scores?: Scores | undefined;
}

export interface GetCurrentLowestReputerScoreRequest {
  topicId: string;
}

export interface GetCurrentLowestReputerScoreResponse {
  score?: Score | undefined;
}

export interface GetListeningCoefficientRequest {
  topicId: string;
  reputer: string;
}

export interface GetListeningCoefficientResponse {
  listeningCoefficient?: ListeningCoefficient | undefined;
}

export interface GetPreviousReputerRewardFractionRequest {
  topicId: string;
  reputer: string;
}

export interface GetPreviousReputerRewardFractionResponse {
  rewardFraction: string;
  notFound: boolean;
}

export interface GetPreviousInferenceRewardFractionRequest {
  topicId: string;
  worker: string;
}

export interface GetPreviousInferenceRewardFractionResponse {
  rewardFraction: string;
  notFound: boolean;
}

export interface GetPreviousForecastRewardFractionRequest {
  topicId: string;
  worker: string;
}

export interface GetPreviousForecastRewardFractionResponse {
  rewardFraction: string;
  notFound: boolean;
}

export interface GetPreviousPercentageRewardToStakedReputersRequest {
}

export interface GetPreviousPercentageRewardToStakedReputersResponse {
  percentageReward: string;
}

export interface GetTotalRewardToDistributeRequest {
}

export interface GetTotalRewardToDistributeResponse {
  totalReward: string;
}

export interface GetActiveTopicsAtBlockRequest {
  blockHeight: string;
}

export interface GetActiveTopicsAtBlockResponse {
  topics: Topic[];
  pagination?: SimpleCursorPaginationResponse | undefined;
}

export interface GetNextChurningBlockByTopicIdRequest {
  topicId: string;
}

export interface GetNextChurningBlockByTopicIdResponse {
  blockHeight: string;
}

export interface GetActiveReputersForTopicRequest {
  topicId: string;
}

export interface GetActiveReputersForTopicResponse {
  reputers: string[];
}

export interface GetActiveForecastersForTopicRequest {
  topicId: string;
}

export interface GetActiveForecastersForTopicResponse {
  forecasters: string[];
}

export interface GetActiveInferersForTopicRequest {
  topicId: string;
}

export interface GetActiveInferersForTopicResponse {
  inferers: string[];
}

function createBaseGetCountInfererInclusionsInTopicRequest(): GetCountInfererInclusionsInTopicRequest {
  return { topicId: "0", inferer: "" };
}

export const GetCountInfererInclusionsInTopicRequest: MessageFns<GetCountInfererInclusionsInTopicRequest> = {
  encode(message: GetCountInfererInclusionsInTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.inferer !== "") {
      writer.uint32(18).string(message.inferer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCountInfererInclusionsInTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCountInfererInclusionsInTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inferer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCountInfererInclusionsInTopicRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      inferer: isSet(object.inferer) ? globalThis.String(object.inferer) : "",
    };
  },

  toJSON(message: GetCountInfererInclusionsInTopicRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.inferer !== "") {
      obj.inferer = message.inferer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCountInfererInclusionsInTopicRequest>): GetCountInfererInclusionsInTopicRequest {
    return GetCountInfererInclusionsInTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCountInfererInclusionsInTopicRequest>): GetCountInfererInclusionsInTopicRequest {
    const message = createBaseGetCountInfererInclusionsInTopicRequest();
    message.topicId = object.topicId ?? "0";
    message.inferer = object.inferer ?? "";
    return message;
  },
};

function createBaseGetCountInfererInclusionsInTopicResponse(): GetCountInfererInclusionsInTopicResponse {
  return { count: "0" };
}

export const GetCountInfererInclusionsInTopicResponse: MessageFns<GetCountInfererInclusionsInTopicResponse> = {
  encode(message: GetCountInfererInclusionsInTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== "0") {
      writer.uint32(8).uint64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCountInfererInclusionsInTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCountInfererInclusionsInTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCountInfererInclusionsInTopicResponse {
    return { count: isSet(object.count) ? globalThis.String(object.count) : "0" };
  },

  toJSON(message: GetCountInfererInclusionsInTopicResponse): unknown {
    const obj: any = {};
    if (message.count !== "0") {
      obj.count = message.count;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCountInfererInclusionsInTopicResponse>): GetCountInfererInclusionsInTopicResponse {
    return GetCountInfererInclusionsInTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCountInfererInclusionsInTopicResponse>): GetCountInfererInclusionsInTopicResponse {
    const message = createBaseGetCountInfererInclusionsInTopicResponse();
    message.count = object.count ?? "0";
    return message;
  },
};

function createBaseGetCountForecasterInclusionsInTopicRequest(): GetCountForecasterInclusionsInTopicRequest {
  return { topicId: "0", forecaster: "" };
}

export const GetCountForecasterInclusionsInTopicRequest: MessageFns<GetCountForecasterInclusionsInTopicRequest> = {
  encode(message: GetCountForecasterInclusionsInTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.forecaster !== "") {
      writer.uint32(18).string(message.forecaster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCountForecasterInclusionsInTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCountForecasterInclusionsInTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.forecaster = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCountForecasterInclusionsInTopicRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      forecaster: isSet(object.forecaster) ? globalThis.String(object.forecaster) : "",
    };
  },

  toJSON(message: GetCountForecasterInclusionsInTopicRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.forecaster !== "") {
      obj.forecaster = message.forecaster;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCountForecasterInclusionsInTopicRequest>): GetCountForecasterInclusionsInTopicRequest {
    return GetCountForecasterInclusionsInTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetCountForecasterInclusionsInTopicRequest>,
  ): GetCountForecasterInclusionsInTopicRequest {
    const message = createBaseGetCountForecasterInclusionsInTopicRequest();
    message.topicId = object.topicId ?? "0";
    message.forecaster = object.forecaster ?? "";
    return message;
  },
};

function createBaseGetCountForecasterInclusionsInTopicResponse(): GetCountForecasterInclusionsInTopicResponse {
  return { count: "0" };
}

export const GetCountForecasterInclusionsInTopicResponse: MessageFns<GetCountForecasterInclusionsInTopicResponse> = {
  encode(
    message: GetCountForecasterInclusionsInTopicResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.count !== "0") {
      writer.uint32(8).uint64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCountForecasterInclusionsInTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCountForecasterInclusionsInTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCountForecasterInclusionsInTopicResponse {
    return { count: isSet(object.count) ? globalThis.String(object.count) : "0" };
  },

  toJSON(message: GetCountForecasterInclusionsInTopicResponse): unknown {
    const obj: any = {};
    if (message.count !== "0") {
      obj.count = message.count;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCountForecasterInclusionsInTopicResponse>): GetCountForecasterInclusionsInTopicResponse {
    return GetCountForecasterInclusionsInTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetCountForecasterInclusionsInTopicResponse>,
  ): GetCountForecasterInclusionsInTopicResponse {
    const message = createBaseGetCountForecasterInclusionsInTopicResponse();
    message.count = object.count ?? "0";
    return message;
  },
};

function createBaseGetNaiveInfererNetworkRegretRequest(): GetNaiveInfererNetworkRegretRequest {
  return { topicId: "0", inferer: "" };
}

export const GetNaiveInfererNetworkRegretRequest: MessageFns<GetNaiveInfererNetworkRegretRequest> = {
  encode(message: GetNaiveInfererNetworkRegretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.inferer !== "") {
      writer.uint32(18).string(message.inferer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNaiveInfererNetworkRegretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNaiveInfererNetworkRegretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inferer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNaiveInfererNetworkRegretRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      inferer: isSet(object.inferer) ? globalThis.String(object.inferer) : "",
    };
  },

  toJSON(message: GetNaiveInfererNetworkRegretRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.inferer !== "") {
      obj.inferer = message.inferer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNaiveInfererNetworkRegretRequest>): GetNaiveInfererNetworkRegretRequest {
    return GetNaiveInfererNetworkRegretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNaiveInfererNetworkRegretRequest>): GetNaiveInfererNetworkRegretRequest {
    const message = createBaseGetNaiveInfererNetworkRegretRequest();
    message.topicId = object.topicId ?? "0";
    message.inferer = object.inferer ?? "";
    return message;
  },
};

function createBaseGetNaiveInfererNetworkRegretResponse(): GetNaiveInfererNetworkRegretResponse {
  return { regret: undefined };
}

export const GetNaiveInfererNetworkRegretResponse: MessageFns<GetNaiveInfererNetworkRegretResponse> = {
  encode(message: GetNaiveInfererNetworkRegretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regret !== undefined) {
      TimestampedValue.encode(message.regret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNaiveInfererNetworkRegretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNaiveInfererNetworkRegretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regret = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNaiveInfererNetworkRegretResponse {
    return { regret: isSet(object.regret) ? TimestampedValue.fromJSON(object.regret) : undefined };
  },

  toJSON(message: GetNaiveInfererNetworkRegretResponse): unknown {
    const obj: any = {};
    if (message.regret !== undefined) {
      obj.regret = TimestampedValue.toJSON(message.regret);
    }
    return obj;
  },

  create(base?: DeepPartial<GetNaiveInfererNetworkRegretResponse>): GetNaiveInfererNetworkRegretResponse {
    return GetNaiveInfererNetworkRegretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNaiveInfererNetworkRegretResponse>): GetNaiveInfererNetworkRegretResponse {
    const message = createBaseGetNaiveInfererNetworkRegretResponse();
    message.regret = (object.regret !== undefined && object.regret !== null)
      ? TimestampedValue.fromPartial(object.regret)
      : undefined;
    return message;
  },
};

function createBaseGetOneOutInfererInfererNetworkRegretRequest(): GetOneOutInfererInfererNetworkRegretRequest {
  return { topicId: "0", oneOutInferer: "", inferer: "" };
}

export const GetOneOutInfererInfererNetworkRegretRequest: MessageFns<GetOneOutInfererInfererNetworkRegretRequest> = {
  encode(
    message: GetOneOutInfererInfererNetworkRegretRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.oneOutInferer !== "") {
      writer.uint32(18).string(message.oneOutInferer);
    }
    if (message.inferer !== "") {
      writer.uint32(26).string(message.inferer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneOutInfererInfererNetworkRegretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneOutInfererInfererNetworkRegretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneOutInferer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inferer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneOutInfererInfererNetworkRegretRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      oneOutInferer: isSet(object.oneOutInferer) ? globalThis.String(object.oneOutInferer) : "",
      inferer: isSet(object.inferer) ? globalThis.String(object.inferer) : "",
    };
  },

  toJSON(message: GetOneOutInfererInfererNetworkRegretRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.oneOutInferer !== "") {
      obj.oneOutInferer = message.oneOutInferer;
    }
    if (message.inferer !== "") {
      obj.inferer = message.inferer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOneOutInfererInfererNetworkRegretRequest>): GetOneOutInfererInfererNetworkRegretRequest {
    return GetOneOutInfererInfererNetworkRegretRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetOneOutInfererInfererNetworkRegretRequest>,
  ): GetOneOutInfererInfererNetworkRegretRequest {
    const message = createBaseGetOneOutInfererInfererNetworkRegretRequest();
    message.topicId = object.topicId ?? "0";
    message.oneOutInferer = object.oneOutInferer ?? "";
    message.inferer = object.inferer ?? "";
    return message;
  },
};

function createBaseGetOneOutInfererInfererNetworkRegretResponse(): GetOneOutInfererInfererNetworkRegretResponse {
  return { regret: undefined };
}

export const GetOneOutInfererInfererNetworkRegretResponse: MessageFns<GetOneOutInfererInfererNetworkRegretResponse> = {
  encode(
    message: GetOneOutInfererInfererNetworkRegretResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.regret !== undefined) {
      TimestampedValue.encode(message.regret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneOutInfererInfererNetworkRegretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneOutInfererInfererNetworkRegretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regret = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneOutInfererInfererNetworkRegretResponse {
    return { regret: isSet(object.regret) ? TimestampedValue.fromJSON(object.regret) : undefined };
  },

  toJSON(message: GetOneOutInfererInfererNetworkRegretResponse): unknown {
    const obj: any = {};
    if (message.regret !== undefined) {
      obj.regret = TimestampedValue.toJSON(message.regret);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetOneOutInfererInfererNetworkRegretResponse>,
  ): GetOneOutInfererInfererNetworkRegretResponse {
    return GetOneOutInfererInfererNetworkRegretResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetOneOutInfererInfererNetworkRegretResponse>,
  ): GetOneOutInfererInfererNetworkRegretResponse {
    const message = createBaseGetOneOutInfererInfererNetworkRegretResponse();
    message.regret = (object.regret !== undefined && object.regret !== null)
      ? TimestampedValue.fromPartial(object.regret)
      : undefined;
    return message;
  },
};

function createBaseGetOneOutInfererForecasterNetworkRegretRequest(): GetOneOutInfererForecasterNetworkRegretRequest {
  return { topicId: "0", oneOutInferer: "", forecaster: "" };
}

export const GetOneOutInfererForecasterNetworkRegretRequest: MessageFns<
  GetOneOutInfererForecasterNetworkRegretRequest
> = {
  encode(
    message: GetOneOutInfererForecasterNetworkRegretRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.oneOutInferer !== "") {
      writer.uint32(18).string(message.oneOutInferer);
    }
    if (message.forecaster !== "") {
      writer.uint32(26).string(message.forecaster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneOutInfererForecasterNetworkRegretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneOutInfererForecasterNetworkRegretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneOutInferer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.forecaster = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneOutInfererForecasterNetworkRegretRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      oneOutInferer: isSet(object.oneOutInferer) ? globalThis.String(object.oneOutInferer) : "",
      forecaster: isSet(object.forecaster) ? globalThis.String(object.forecaster) : "",
    };
  },

  toJSON(message: GetOneOutInfererForecasterNetworkRegretRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.oneOutInferer !== "") {
      obj.oneOutInferer = message.oneOutInferer;
    }
    if (message.forecaster !== "") {
      obj.forecaster = message.forecaster;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetOneOutInfererForecasterNetworkRegretRequest>,
  ): GetOneOutInfererForecasterNetworkRegretRequest {
    return GetOneOutInfererForecasterNetworkRegretRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetOneOutInfererForecasterNetworkRegretRequest>,
  ): GetOneOutInfererForecasterNetworkRegretRequest {
    const message = createBaseGetOneOutInfererForecasterNetworkRegretRequest();
    message.topicId = object.topicId ?? "0";
    message.oneOutInferer = object.oneOutInferer ?? "";
    message.forecaster = object.forecaster ?? "";
    return message;
  },
};

function createBaseGetOneOutInfererForecasterNetworkRegretResponse(): GetOneOutInfererForecasterNetworkRegretResponse {
  return { regret: undefined };
}

export const GetOneOutInfererForecasterNetworkRegretResponse: MessageFns<
  GetOneOutInfererForecasterNetworkRegretResponse
> = {
  encode(
    message: GetOneOutInfererForecasterNetworkRegretResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.regret !== undefined) {
      TimestampedValue.encode(message.regret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneOutInfererForecasterNetworkRegretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneOutInfererForecasterNetworkRegretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regret = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneOutInfererForecasterNetworkRegretResponse {
    return { regret: isSet(object.regret) ? TimestampedValue.fromJSON(object.regret) : undefined };
  },

  toJSON(message: GetOneOutInfererForecasterNetworkRegretResponse): unknown {
    const obj: any = {};
    if (message.regret !== undefined) {
      obj.regret = TimestampedValue.toJSON(message.regret);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetOneOutInfererForecasterNetworkRegretResponse>,
  ): GetOneOutInfererForecasterNetworkRegretResponse {
    return GetOneOutInfererForecasterNetworkRegretResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetOneOutInfererForecasterNetworkRegretResponse>,
  ): GetOneOutInfererForecasterNetworkRegretResponse {
    const message = createBaseGetOneOutInfererForecasterNetworkRegretResponse();
    message.regret = (object.regret !== undefined && object.regret !== null)
      ? TimestampedValue.fromPartial(object.regret)
      : undefined;
    return message;
  },
};

function createBaseGetOneOutForecasterInfererNetworkRegretRequest(): GetOneOutForecasterInfererNetworkRegretRequest {
  return { topicId: "0", oneOutForecaster: "", inferer: "" };
}

export const GetOneOutForecasterInfererNetworkRegretRequest: MessageFns<
  GetOneOutForecasterInfererNetworkRegretRequest
> = {
  encode(
    message: GetOneOutForecasterInfererNetworkRegretRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.oneOutForecaster !== "") {
      writer.uint32(18).string(message.oneOutForecaster);
    }
    if (message.inferer !== "") {
      writer.uint32(26).string(message.inferer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneOutForecasterInfererNetworkRegretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneOutForecasterInfererNetworkRegretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneOutForecaster = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inferer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneOutForecasterInfererNetworkRegretRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      oneOutForecaster: isSet(object.oneOutForecaster) ? globalThis.String(object.oneOutForecaster) : "",
      inferer: isSet(object.inferer) ? globalThis.String(object.inferer) : "",
    };
  },

  toJSON(message: GetOneOutForecasterInfererNetworkRegretRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.oneOutForecaster !== "") {
      obj.oneOutForecaster = message.oneOutForecaster;
    }
    if (message.inferer !== "") {
      obj.inferer = message.inferer;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetOneOutForecasterInfererNetworkRegretRequest>,
  ): GetOneOutForecasterInfererNetworkRegretRequest {
    return GetOneOutForecasterInfererNetworkRegretRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetOneOutForecasterInfererNetworkRegretRequest>,
  ): GetOneOutForecasterInfererNetworkRegretRequest {
    const message = createBaseGetOneOutForecasterInfererNetworkRegretRequest();
    message.topicId = object.topicId ?? "0";
    message.oneOutForecaster = object.oneOutForecaster ?? "";
    message.inferer = object.inferer ?? "";
    return message;
  },
};

function createBaseGetOneOutForecasterInfererNetworkRegretResponse(): GetOneOutForecasterInfererNetworkRegretResponse {
  return { regret: undefined };
}

export const GetOneOutForecasterInfererNetworkRegretResponse: MessageFns<
  GetOneOutForecasterInfererNetworkRegretResponse
> = {
  encode(
    message: GetOneOutForecasterInfererNetworkRegretResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.regret !== undefined) {
      TimestampedValue.encode(message.regret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneOutForecasterInfererNetworkRegretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneOutForecasterInfererNetworkRegretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regret = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneOutForecasterInfererNetworkRegretResponse {
    return { regret: isSet(object.regret) ? TimestampedValue.fromJSON(object.regret) : undefined };
  },

  toJSON(message: GetOneOutForecasterInfererNetworkRegretResponse): unknown {
    const obj: any = {};
    if (message.regret !== undefined) {
      obj.regret = TimestampedValue.toJSON(message.regret);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetOneOutForecasterInfererNetworkRegretResponse>,
  ): GetOneOutForecasterInfererNetworkRegretResponse {
    return GetOneOutForecasterInfererNetworkRegretResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetOneOutForecasterInfererNetworkRegretResponse>,
  ): GetOneOutForecasterInfererNetworkRegretResponse {
    const message = createBaseGetOneOutForecasterInfererNetworkRegretResponse();
    message.regret = (object.regret !== undefined && object.regret !== null)
      ? TimestampedValue.fromPartial(object.regret)
      : undefined;
    return message;
  },
};

function createBaseGetOneOutForecasterForecasterNetworkRegretRequest(): GetOneOutForecasterForecasterNetworkRegretRequest {
  return { topicId: "0", oneOutForecaster: "", forecaster: "" };
}

export const GetOneOutForecasterForecasterNetworkRegretRequest: MessageFns<
  GetOneOutForecasterForecasterNetworkRegretRequest
> = {
  encode(
    message: GetOneOutForecasterForecasterNetworkRegretRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.oneOutForecaster !== "") {
      writer.uint32(18).string(message.oneOutForecaster);
    }
    if (message.forecaster !== "") {
      writer.uint32(26).string(message.forecaster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneOutForecasterForecasterNetworkRegretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneOutForecasterForecasterNetworkRegretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneOutForecaster = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.forecaster = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneOutForecasterForecasterNetworkRegretRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      oneOutForecaster: isSet(object.oneOutForecaster) ? globalThis.String(object.oneOutForecaster) : "",
      forecaster: isSet(object.forecaster) ? globalThis.String(object.forecaster) : "",
    };
  },

  toJSON(message: GetOneOutForecasterForecasterNetworkRegretRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.oneOutForecaster !== "") {
      obj.oneOutForecaster = message.oneOutForecaster;
    }
    if (message.forecaster !== "") {
      obj.forecaster = message.forecaster;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetOneOutForecasterForecasterNetworkRegretRequest>,
  ): GetOneOutForecasterForecasterNetworkRegretRequest {
    return GetOneOutForecasterForecasterNetworkRegretRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetOneOutForecasterForecasterNetworkRegretRequest>,
  ): GetOneOutForecasterForecasterNetworkRegretRequest {
    const message = createBaseGetOneOutForecasterForecasterNetworkRegretRequest();
    message.topicId = object.topicId ?? "0";
    message.oneOutForecaster = object.oneOutForecaster ?? "";
    message.forecaster = object.forecaster ?? "";
    return message;
  },
};

function createBaseGetOneOutForecasterForecasterNetworkRegretResponse(): GetOneOutForecasterForecasterNetworkRegretResponse {
  return { regret: undefined };
}

export const GetOneOutForecasterForecasterNetworkRegretResponse: MessageFns<
  GetOneOutForecasterForecasterNetworkRegretResponse
> = {
  encode(
    message: GetOneOutForecasterForecasterNetworkRegretResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.regret !== undefined) {
      TimestampedValue.encode(message.regret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneOutForecasterForecasterNetworkRegretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneOutForecasterForecasterNetworkRegretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regret = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneOutForecasterForecasterNetworkRegretResponse {
    return { regret: isSet(object.regret) ? TimestampedValue.fromJSON(object.regret) : undefined };
  },

  toJSON(message: GetOneOutForecasterForecasterNetworkRegretResponse): unknown {
    const obj: any = {};
    if (message.regret !== undefined) {
      obj.regret = TimestampedValue.toJSON(message.regret);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetOneOutForecasterForecasterNetworkRegretResponse>,
  ): GetOneOutForecasterForecasterNetworkRegretResponse {
    return GetOneOutForecasterForecasterNetworkRegretResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetOneOutForecasterForecasterNetworkRegretResponse>,
  ): GetOneOutForecasterForecasterNetworkRegretResponse {
    const message = createBaseGetOneOutForecasterForecasterNetworkRegretResponse();
    message.regret = (object.regret !== undefined && object.regret !== null)
      ? TimestampedValue.fromPartial(object.regret)
      : undefined;
    return message;
  },
};

function createBaseGetParamsRequest(): GetParamsRequest {
  return {};
}

export const GetParamsRequest: MessageFns<GetParamsRequest> = {
  encode(_: GetParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetParamsRequest {
    return {};
  },

  toJSON(_: GetParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetParamsRequest>): GetParamsRequest {
    return GetParamsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetParamsRequest>): GetParamsRequest {
    const message = createBaseGetParamsRequest();
    return message;
  },
};

function createBaseGetParamsResponse(): GetParamsResponse {
  return { params: undefined };
}

export const GetParamsResponse: MessageFns<GetParamsResponse> = {
  encode(message: GetParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: GetParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<GetParamsResponse>): GetParamsResponse {
    return GetParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetParamsResponse>): GetParamsResponse {
    const message = createBaseGetParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseGetTotalStakeRequest(): GetTotalStakeRequest {
  return {};
}

export const GetTotalStakeRequest: MessageFns<GetTotalStakeRequest> = {
  encode(_: GetTotalStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTotalStakeRequest {
    return {};
  },

  toJSON(_: GetTotalStakeRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetTotalStakeRequest>): GetTotalStakeRequest {
    return GetTotalStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetTotalStakeRequest>): GetTotalStakeRequest {
    const message = createBaseGetTotalStakeRequest();
    return message;
  },
};

function createBaseGetTotalStakeResponse(): GetTotalStakeResponse {
  return { amount: "" };
}

export const GetTotalStakeResponse: MessageFns<GetTotalStakeResponse> = {
  encode(message: GetTotalStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTotalStakeResponse {
    return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "" };
  },

  toJSON(message: GetTotalStakeResponse): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTotalStakeResponse>): GetTotalStakeResponse {
    return GetTotalStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTotalStakeResponse>): GetTotalStakeResponse {
    const message = createBaseGetTotalStakeResponse();
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseGetReputerStakeInTopicRequest(): GetReputerStakeInTopicRequest {
  return { address: "", topicId: "0" };
}

export const GetReputerStakeInTopicRequest: MessageFns<GetReputerStakeInTopicRequest> = {
  encode(message: GetReputerStakeInTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputerStakeInTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputerStakeInTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputerStakeInTopicRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: GetReputerStakeInTopicRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputerStakeInTopicRequest>): GetReputerStakeInTopicRequest {
    return GetReputerStakeInTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputerStakeInTopicRequest>): GetReputerStakeInTopicRequest {
    const message = createBaseGetReputerStakeInTopicRequest();
    message.address = object.address ?? "";
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetReputerStakeInTopicResponse(): GetReputerStakeInTopicResponse {
  return { amount: "" };
}

export const GetReputerStakeInTopicResponse: MessageFns<GetReputerStakeInTopicResponse> = {
  encode(message: GetReputerStakeInTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputerStakeInTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputerStakeInTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputerStakeInTopicResponse {
    return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "" };
  },

  toJSON(message: GetReputerStakeInTopicResponse): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputerStakeInTopicResponse>): GetReputerStakeInTopicResponse {
    return GetReputerStakeInTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputerStakeInTopicResponse>): GetReputerStakeInTopicResponse {
    const message = createBaseGetReputerStakeInTopicResponse();
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseGetMultiReputerStakeInTopicRequest(): GetMultiReputerStakeInTopicRequest {
  return { addresses: [], topicId: "0" };
}

export const GetMultiReputerStakeInTopicRequest: MessageFns<GetMultiReputerStakeInTopicRequest> = {
  encode(message: GetMultiReputerStakeInTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMultiReputerStakeInTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMultiReputerStakeInTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMultiReputerStakeInTopicRequest {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: GetMultiReputerStakeInTopicRequest): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMultiReputerStakeInTopicRequest>): GetMultiReputerStakeInTopicRequest {
    return GetMultiReputerStakeInTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMultiReputerStakeInTopicRequest>): GetMultiReputerStakeInTopicRequest {
    const message = createBaseGetMultiReputerStakeInTopicRequest();
    message.addresses = object.addresses?.map((e) => e) || [];
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetMultiReputerStakeInTopicResponse(): GetMultiReputerStakeInTopicResponse {
  return { amounts: [] };
}

export const GetMultiReputerStakeInTopicResponse: MessageFns<GetMultiReputerStakeInTopicResponse> = {
  encode(message: GetMultiReputerStakeInTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.amounts) {
      StakeInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMultiReputerStakeInTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMultiReputerStakeInTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amounts.push(StakeInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMultiReputerStakeInTopicResponse {
    return {
      amounts: globalThis.Array.isArray(object?.amounts) ? object.amounts.map((e: any) => StakeInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetMultiReputerStakeInTopicResponse): unknown {
    const obj: any = {};
    if (message.amounts?.length) {
      obj.amounts = message.amounts.map((e) => StakeInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetMultiReputerStakeInTopicResponse>): GetMultiReputerStakeInTopicResponse {
    return GetMultiReputerStakeInTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMultiReputerStakeInTopicResponse>): GetMultiReputerStakeInTopicResponse {
    const message = createBaseGetMultiReputerStakeInTopicResponse();
    message.amounts = object.amounts?.map((e) => StakeInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetStakeFromReputerInTopicInSelfRequest(): GetStakeFromReputerInTopicInSelfRequest {
  return { reputerAddress: "", topicId: "0" };
}

export const GetStakeFromReputerInTopicInSelfRequest: MessageFns<GetStakeFromReputerInTopicInSelfRequest> = {
  encode(message: GetStakeFromReputerInTopicInSelfRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reputerAddress !== "") {
      writer.uint32(10).string(message.reputerAddress);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeFromReputerInTopicInSelfRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeFromReputerInTopicInSelfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reputerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeFromReputerInTopicInSelfRequest {
    return {
      reputerAddress: isSet(object.reputerAddress) ? globalThis.String(object.reputerAddress) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: GetStakeFromReputerInTopicInSelfRequest): unknown {
    const obj: any = {};
    if (message.reputerAddress !== "") {
      obj.reputerAddress = message.reputerAddress;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeFromReputerInTopicInSelfRequest>): GetStakeFromReputerInTopicInSelfRequest {
    return GetStakeFromReputerInTopicInSelfRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeFromReputerInTopicInSelfRequest>): GetStakeFromReputerInTopicInSelfRequest {
    const message = createBaseGetStakeFromReputerInTopicInSelfRequest();
    message.reputerAddress = object.reputerAddress ?? "";
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetStakeFromReputerInTopicInSelfResponse(): GetStakeFromReputerInTopicInSelfResponse {
  return { amount: "" };
}

export const GetStakeFromReputerInTopicInSelfResponse: MessageFns<GetStakeFromReputerInTopicInSelfResponse> = {
  encode(message: GetStakeFromReputerInTopicInSelfResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeFromReputerInTopicInSelfResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeFromReputerInTopicInSelfResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeFromReputerInTopicInSelfResponse {
    return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "" };
  },

  toJSON(message: GetStakeFromReputerInTopicInSelfResponse): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeFromReputerInTopicInSelfResponse>): GetStakeFromReputerInTopicInSelfResponse {
    return GetStakeFromReputerInTopicInSelfResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeFromReputerInTopicInSelfResponse>): GetStakeFromReputerInTopicInSelfResponse {
    const message = createBaseGetStakeFromReputerInTopicInSelfResponse();
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseGetDelegateStakeInTopicInReputerRequest(): GetDelegateStakeInTopicInReputerRequest {
  return { reputerAddress: "", topicId: "0" };
}

export const GetDelegateStakeInTopicInReputerRequest: MessageFns<GetDelegateStakeInTopicInReputerRequest> = {
  encode(message: GetDelegateStakeInTopicInReputerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reputerAddress !== "") {
      writer.uint32(10).string(message.reputerAddress);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeInTopicInReputerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeInTopicInReputerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reputerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeInTopicInReputerRequest {
    return {
      reputerAddress: isSet(object.reputerAddress) ? globalThis.String(object.reputerAddress) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: GetDelegateStakeInTopicInReputerRequest): unknown {
    const obj: any = {};
    if (message.reputerAddress !== "") {
      obj.reputerAddress = message.reputerAddress;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeInTopicInReputerRequest>): GetDelegateStakeInTopicInReputerRequest {
    return GetDelegateStakeInTopicInReputerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakeInTopicInReputerRequest>): GetDelegateStakeInTopicInReputerRequest {
    const message = createBaseGetDelegateStakeInTopicInReputerRequest();
    message.reputerAddress = object.reputerAddress ?? "";
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetDelegateStakeInTopicInReputerResponse(): GetDelegateStakeInTopicInReputerResponse {
  return { amount: "" };
}

export const GetDelegateStakeInTopicInReputerResponse: MessageFns<GetDelegateStakeInTopicInReputerResponse> = {
  encode(message: GetDelegateStakeInTopicInReputerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeInTopicInReputerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeInTopicInReputerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeInTopicInReputerResponse {
    return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "" };
  },

  toJSON(message: GetDelegateStakeInTopicInReputerResponse): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeInTopicInReputerResponse>): GetDelegateStakeInTopicInReputerResponse {
    return GetDelegateStakeInTopicInReputerResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakeInTopicInReputerResponse>): GetDelegateStakeInTopicInReputerResponse {
    const message = createBaseGetDelegateStakeInTopicInReputerResponse();
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseGetStakeFromDelegatorInTopicInReputerRequest(): GetStakeFromDelegatorInTopicInReputerRequest {
  return { delegatorAddress: "", reputerAddress: "", topicId: "0" };
}

export const GetStakeFromDelegatorInTopicInReputerRequest: MessageFns<GetStakeFromDelegatorInTopicInReputerRequest> = {
  encode(
    message: GetStakeFromDelegatorInTopicInReputerRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.delegatorAddress !== "") {
      writer.uint32(10).string(message.delegatorAddress);
    }
    if (message.reputerAddress !== "") {
      writer.uint32(18).string(message.reputerAddress);
    }
    if (message.topicId !== "0") {
      writer.uint32(24).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeFromDelegatorInTopicInReputerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeFromDelegatorInTopicInReputerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputerAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeFromDelegatorInTopicInReputerRequest {
    return {
      delegatorAddress: isSet(object.delegatorAddress) ? globalThis.String(object.delegatorAddress) : "",
      reputerAddress: isSet(object.reputerAddress) ? globalThis.String(object.reputerAddress) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: GetStakeFromDelegatorInTopicInReputerRequest): unknown {
    const obj: any = {};
    if (message.delegatorAddress !== "") {
      obj.delegatorAddress = message.delegatorAddress;
    }
    if (message.reputerAddress !== "") {
      obj.reputerAddress = message.reputerAddress;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetStakeFromDelegatorInTopicInReputerRequest>,
  ): GetStakeFromDelegatorInTopicInReputerRequest {
    return GetStakeFromDelegatorInTopicInReputerRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetStakeFromDelegatorInTopicInReputerRequest>,
  ): GetStakeFromDelegatorInTopicInReputerRequest {
    const message = createBaseGetStakeFromDelegatorInTopicInReputerRequest();
    message.delegatorAddress = object.delegatorAddress ?? "";
    message.reputerAddress = object.reputerAddress ?? "";
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetStakeFromDelegatorInTopicInReputerResponse(): GetStakeFromDelegatorInTopicInReputerResponse {
  return { amount: "" };
}

export const GetStakeFromDelegatorInTopicInReputerResponse: MessageFns<GetStakeFromDelegatorInTopicInReputerResponse> =
  {
    encode(
      message: GetStakeFromDelegatorInTopicInReputerResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.amount !== "") {
        writer.uint32(10).string(message.amount);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetStakeFromDelegatorInTopicInReputerResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetStakeFromDelegatorInTopicInReputerResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.amount = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetStakeFromDelegatorInTopicInReputerResponse {
      return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "" };
    },

    toJSON(message: GetStakeFromDelegatorInTopicInReputerResponse): unknown {
      const obj: any = {};
      if (message.amount !== "") {
        obj.amount = message.amount;
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetStakeFromDelegatorInTopicInReputerResponse>,
    ): GetStakeFromDelegatorInTopicInReputerResponse {
      return GetStakeFromDelegatorInTopicInReputerResponse.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetStakeFromDelegatorInTopicInReputerResponse>,
    ): GetStakeFromDelegatorInTopicInReputerResponse {
      const message = createBaseGetStakeFromDelegatorInTopicInReputerResponse();
      message.amount = object.amount ?? "";
      return message;
    },
  };

function createBaseGetStakeFromDelegatorInTopicRequest(): GetStakeFromDelegatorInTopicRequest {
  return { delegatorAddress: "", topicId: "0" };
}

export const GetStakeFromDelegatorInTopicRequest: MessageFns<GetStakeFromDelegatorInTopicRequest> = {
  encode(message: GetStakeFromDelegatorInTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegatorAddress !== "") {
      writer.uint32(10).string(message.delegatorAddress);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeFromDelegatorInTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeFromDelegatorInTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeFromDelegatorInTopicRequest {
    return {
      delegatorAddress: isSet(object.delegatorAddress) ? globalThis.String(object.delegatorAddress) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: GetStakeFromDelegatorInTopicRequest): unknown {
    const obj: any = {};
    if (message.delegatorAddress !== "") {
      obj.delegatorAddress = message.delegatorAddress;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeFromDelegatorInTopicRequest>): GetStakeFromDelegatorInTopicRequest {
    return GetStakeFromDelegatorInTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeFromDelegatorInTopicRequest>): GetStakeFromDelegatorInTopicRequest {
    const message = createBaseGetStakeFromDelegatorInTopicRequest();
    message.delegatorAddress = object.delegatorAddress ?? "";
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetStakeFromDelegatorInTopicResponse(): GetStakeFromDelegatorInTopicResponse {
  return { amount: "" };
}

export const GetStakeFromDelegatorInTopicResponse: MessageFns<GetStakeFromDelegatorInTopicResponse> = {
  encode(message: GetStakeFromDelegatorInTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeFromDelegatorInTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeFromDelegatorInTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeFromDelegatorInTopicResponse {
    return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "" };
  },

  toJSON(message: GetStakeFromDelegatorInTopicResponse): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeFromDelegatorInTopicResponse>): GetStakeFromDelegatorInTopicResponse {
    return GetStakeFromDelegatorInTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeFromDelegatorInTopicResponse>): GetStakeFromDelegatorInTopicResponse {
    const message = createBaseGetStakeFromDelegatorInTopicResponse();
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseGetTopicStakeRequest(): GetTopicStakeRequest {
  return { topicId: "0" };
}

export const GetTopicStakeRequest: MessageFns<GetTopicStakeRequest> = {
  encode(message: GetTopicStakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicStakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicStakeRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetTopicStakeRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicStakeRequest>): GetTopicStakeRequest {
    return GetTopicStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicStakeRequest>): GetTopicStakeRequest {
    const message = createBaseGetTopicStakeRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetTopicStakeResponse(): GetTopicStakeResponse {
  return { amount: "" };
}

export const GetTopicStakeResponse: MessageFns<GetTopicStakeResponse> = {
  encode(message: GetTopicStakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicStakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicStakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicStakeResponse {
    return { amount: isSet(object.amount) ? globalThis.String(object.amount) : "" };
  },

  toJSON(message: GetTopicStakeResponse): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicStakeResponse>): GetTopicStakeResponse {
    return GetTopicStakeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicStakeResponse>): GetTopicStakeResponse {
    const message = createBaseGetTopicStakeResponse();
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseGetNetworkLossBundleAtBlockRequest(): GetNetworkLossBundleAtBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetNetworkLossBundleAtBlockRequest: MessageFns<GetNetworkLossBundleAtBlockRequest> = {
  encode(message: GetNetworkLossBundleAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkLossBundleAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkLossBundleAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkLossBundleAtBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetNetworkLossBundleAtBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNetworkLossBundleAtBlockRequest>): GetNetworkLossBundleAtBlockRequest {
    return GetNetworkLossBundleAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNetworkLossBundleAtBlockRequest>): GetNetworkLossBundleAtBlockRequest {
    const message = createBaseGetNetworkLossBundleAtBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetNetworkLossBundleAtBlockResponse(): GetNetworkLossBundleAtBlockResponse {
  return { lossBundle: undefined };
}

export const GetNetworkLossBundleAtBlockResponse: MessageFns<GetNetworkLossBundleAtBlockResponse> = {
  encode(message: GetNetworkLossBundleAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lossBundle !== undefined) {
      ValueBundle.encode(message.lossBundle, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkLossBundleAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkLossBundleAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lossBundle = ValueBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkLossBundleAtBlockResponse {
    return { lossBundle: isSet(object.lossBundle) ? ValueBundle.fromJSON(object.lossBundle) : undefined };
  },

  toJSON(message: GetNetworkLossBundleAtBlockResponse): unknown {
    const obj: any = {};
    if (message.lossBundle !== undefined) {
      obj.lossBundle = ValueBundle.toJSON(message.lossBundle);
    }
    return obj;
  },

  create(base?: DeepPartial<GetNetworkLossBundleAtBlockResponse>): GetNetworkLossBundleAtBlockResponse {
    return GetNetworkLossBundleAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNetworkLossBundleAtBlockResponse>): GetNetworkLossBundleAtBlockResponse {
    const message = createBaseGetNetworkLossBundleAtBlockResponse();
    message.lossBundle = (object.lossBundle !== undefined && object.lossBundle !== null)
      ? ValueBundle.fromPartial(object.lossBundle)
      : undefined;
    return message;
  },
};

function createBaseGetNextTopicIdRequest(): GetNextTopicIdRequest {
  return {};
}

export const GetNextTopicIdRequest: MessageFns<GetNextTopicIdRequest> = {
  encode(_: GetNextTopicIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNextTopicIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNextTopicIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetNextTopicIdRequest {
    return {};
  },

  toJSON(_: GetNextTopicIdRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetNextTopicIdRequest>): GetNextTopicIdRequest {
    return GetNextTopicIdRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetNextTopicIdRequest>): GetNextTopicIdRequest {
    const message = createBaseGetNextTopicIdRequest();
    return message;
  },
};

function createBaseGetNextTopicIdResponse(): GetNextTopicIdResponse {
  return { nextTopicId: "0" };
}

export const GetNextTopicIdResponse: MessageFns<GetNextTopicIdResponse> = {
  encode(message: GetNextTopicIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextTopicId !== "0") {
      writer.uint32(8).uint64(message.nextTopicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNextTopicIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNextTopicIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nextTopicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNextTopicIdResponse {
    return { nextTopicId: isSet(object.nextTopicId) ? globalThis.String(object.nextTopicId) : "0" };
  },

  toJSON(message: GetNextTopicIdResponse): unknown {
    const obj: any = {};
    if (message.nextTopicId !== "0") {
      obj.nextTopicId = message.nextTopicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNextTopicIdResponse>): GetNextTopicIdResponse {
    return GetNextTopicIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNextTopicIdResponse>): GetNextTopicIdResponse {
    const message = createBaseGetNextTopicIdResponse();
    message.nextTopicId = object.nextTopicId ?? "0";
    return message;
  },
};

function createBaseGetTopicRequest(): GetTopicRequest {
  return { topicId: "0" };
}

export const GetTopicRequest: MessageFns<GetTopicRequest> = {
  encode(message: GetTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetTopicRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicRequest>): GetTopicRequest {
    return GetTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicRequest>): GetTopicRequest {
    const message = createBaseGetTopicRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetTopicResponse(): GetTopicResponse {
  return { topic: undefined, weight: "", effectiveRevenue: "" };
}

export const GetTopicResponse: MessageFns<GetTopicResponse> = {
  encode(message: GetTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== undefined) {
      Topic.encode(message.topic, writer.uint32(10).fork()).join();
    }
    if (message.weight !== "") {
      writer.uint32(18).string(message.weight);
    }
    if (message.effectiveRevenue !== "") {
      writer.uint32(26).string(message.effectiveRevenue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = Topic.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.weight = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.effectiveRevenue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicResponse {
    return {
      topic: isSet(object.topic) ? Topic.fromJSON(object.topic) : undefined,
      weight: isSet(object.weight) ? globalThis.String(object.weight) : "",
      effectiveRevenue: isSet(object.effectiveRevenue) ? globalThis.String(object.effectiveRevenue) : "",
    };
  },

  toJSON(message: GetTopicResponse): unknown {
    const obj: any = {};
    if (message.topic !== undefined) {
      obj.topic = Topic.toJSON(message.topic);
    }
    if (message.weight !== "") {
      obj.weight = message.weight;
    }
    if (message.effectiveRevenue !== "") {
      obj.effectiveRevenue = message.effectiveRevenue;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicResponse>): GetTopicResponse {
    return GetTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicResponse>): GetTopicResponse {
    const message = createBaseGetTopicResponse();
    message.topic = (object.topic !== undefined && object.topic !== null) ? Topic.fromPartial(object.topic) : undefined;
    message.weight = object.weight ?? "";
    message.effectiveRevenue = object.effectiveRevenue ?? "";
    return message;
  },
};

function createBaseGetActiveTopicsRequest(): GetActiveTopicsRequest {
  return { pagination: undefined };
}

export const GetActiveTopicsRequest: MessageFns<GetActiveTopicsRequest> = {
  encode(message: GetActiveTopicsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      SimpleCursorPaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveTopicsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveTopicsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = SimpleCursorPaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveTopicsRequest {
    return {
      pagination: isSet(object.pagination) ? SimpleCursorPaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetActiveTopicsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = SimpleCursorPaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveTopicsRequest>): GetActiveTopicsRequest {
    return GetActiveTopicsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveTopicsRequest>): GetActiveTopicsRequest {
    const message = createBaseGetActiveTopicsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? SimpleCursorPaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetActiveTopicsResponse(): GetActiveTopicsResponse {
  return { topics: [], pagination: undefined };
}

export const GetActiveTopicsResponse: MessageFns<GetActiveTopicsResponse> = {
  encode(message: GetActiveTopicsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topics) {
      Topic.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      SimpleCursorPaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveTopicsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveTopicsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topics.push(Topic.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = SimpleCursorPaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveTopicsResponse {
    return {
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => Topic.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? SimpleCursorPaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetActiveTopicsResponse): unknown {
    const obj: any = {};
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => Topic.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = SimpleCursorPaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveTopicsResponse>): GetActiveTopicsResponse {
    return GetActiveTopicsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveTopicsResponse>): GetActiveTopicsResponse {
    const message = createBaseGetActiveTopicsResponse();
    message.topics = object.topics?.map((e) => Topic.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? SimpleCursorPaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetInferencesAtBlockRequest(): GetInferencesAtBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetInferencesAtBlockRequest: MessageFns<GetInferencesAtBlockRequest> = {
  encode(message: GetInferencesAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInferencesAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInferencesAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInferencesAtBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetInferencesAtBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInferencesAtBlockRequest>): GetInferencesAtBlockRequest {
    return GetInferencesAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInferencesAtBlockRequest>): GetInferencesAtBlockRequest {
    const message = createBaseGetInferencesAtBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetInferencesAtBlockResponse(): GetInferencesAtBlockResponse {
  return { inferences: undefined };
}

export const GetInferencesAtBlockResponse: MessageFns<GetInferencesAtBlockResponse> = {
  encode(message: GetInferencesAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inferences !== undefined) {
      Inferences.encode(message.inferences, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInferencesAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInferencesAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inferences = Inferences.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInferencesAtBlockResponse {
    return { inferences: isSet(object.inferences) ? Inferences.fromJSON(object.inferences) : undefined };
  },

  toJSON(message: GetInferencesAtBlockResponse): unknown {
    const obj: any = {};
    if (message.inferences !== undefined) {
      obj.inferences = Inferences.toJSON(message.inferences);
    }
    return obj;
  },

  create(base?: DeepPartial<GetInferencesAtBlockResponse>): GetInferencesAtBlockResponse {
    return GetInferencesAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInferencesAtBlockResponse>): GetInferencesAtBlockResponse {
    const message = createBaseGetInferencesAtBlockResponse();
    message.inferences = (object.inferences !== undefined && object.inferences !== null)
      ? Inferences.fromPartial(object.inferences)
      : undefined;
    return message;
  },
};

function createBaseGetLatestTopicInferencesRequest(): GetLatestTopicInferencesRequest {
  return { topicId: "0" };
}

export const GetLatestTopicInferencesRequest: MessageFns<GetLatestTopicInferencesRequest> = {
  encode(message: GetLatestTopicInferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestTopicInferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestTopicInferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestTopicInferencesRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetLatestTopicInferencesRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLatestTopicInferencesRequest>): GetLatestTopicInferencesRequest {
    return GetLatestTopicInferencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLatestTopicInferencesRequest>): GetLatestTopicInferencesRequest {
    const message = createBaseGetLatestTopicInferencesRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetLatestTopicInferencesResponse(): GetLatestTopicInferencesResponse {
  return { inferences: undefined, blockHeight: "0" };
}

export const GetLatestTopicInferencesResponse: MessageFns<GetLatestTopicInferencesResponse> = {
  encode(message: GetLatestTopicInferencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inferences !== undefined) {
      Inferences.encode(message.inferences, writer.uint32(10).fork()).join();
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestTopicInferencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestTopicInferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inferences = Inferences.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestTopicInferencesResponse {
    return {
      inferences: isSet(object.inferences) ? Inferences.fromJSON(object.inferences) : undefined,
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetLatestTopicInferencesResponse): unknown {
    const obj: any = {};
    if (message.inferences !== undefined) {
      obj.inferences = Inferences.toJSON(message.inferences);
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLatestTopicInferencesResponse>): GetLatestTopicInferencesResponse {
    return GetLatestTopicInferencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLatestTopicInferencesResponse>): GetLatestTopicInferencesResponse {
    const message = createBaseGetLatestTopicInferencesResponse();
    message.inferences = (object.inferences !== undefined && object.inferences !== null)
      ? Inferences.fromPartial(object.inferences)
      : undefined;
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetForecastsAtBlockRequest(): GetForecastsAtBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetForecastsAtBlockRequest: MessageFns<GetForecastsAtBlockRequest> = {
  encode(message: GetForecastsAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetForecastsAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetForecastsAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetForecastsAtBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetForecastsAtBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetForecastsAtBlockRequest>): GetForecastsAtBlockRequest {
    return GetForecastsAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetForecastsAtBlockRequest>): GetForecastsAtBlockRequest {
    const message = createBaseGetForecastsAtBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetForecastsAtBlockResponse(): GetForecastsAtBlockResponse {
  return { forecasts: undefined };
}

export const GetForecastsAtBlockResponse: MessageFns<GetForecastsAtBlockResponse> = {
  encode(message: GetForecastsAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.forecasts !== undefined) {
      Forecasts.encode(message.forecasts, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetForecastsAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetForecastsAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.forecasts = Forecasts.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetForecastsAtBlockResponse {
    return { forecasts: isSet(object.forecasts) ? Forecasts.fromJSON(object.forecasts) : undefined };
  },

  toJSON(message: GetForecastsAtBlockResponse): unknown {
    const obj: any = {};
    if (message.forecasts !== undefined) {
      obj.forecasts = Forecasts.toJSON(message.forecasts);
    }
    return obj;
  },

  create(base?: DeepPartial<GetForecastsAtBlockResponse>): GetForecastsAtBlockResponse {
    return GetForecastsAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetForecastsAtBlockResponse>): GetForecastsAtBlockResponse {
    const message = createBaseGetForecastsAtBlockResponse();
    message.forecasts = (object.forecasts !== undefined && object.forecasts !== null)
      ? Forecasts.fromPartial(object.forecasts)
      : undefined;
    return message;
  },
};

function createBaseGetWorkerLatestInferenceByTopicIdRequest(): GetWorkerLatestInferenceByTopicIdRequest {
  return { topicId: "0", workerAddress: "" };
}

export const GetWorkerLatestInferenceByTopicIdRequest: MessageFns<GetWorkerLatestInferenceByTopicIdRequest> = {
  encode(message: GetWorkerLatestInferenceByTopicIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.workerAddress !== "") {
      writer.uint32(18).string(message.workerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerLatestInferenceByTopicIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerLatestInferenceByTopicIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerLatestInferenceByTopicIdRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      workerAddress: isSet(object.workerAddress) ? globalThis.String(object.workerAddress) : "",
    };
  },

  toJSON(message: GetWorkerLatestInferenceByTopicIdRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.workerAddress !== "") {
      obj.workerAddress = message.workerAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkerLatestInferenceByTopicIdRequest>): GetWorkerLatestInferenceByTopicIdRequest {
    return GetWorkerLatestInferenceByTopicIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkerLatestInferenceByTopicIdRequest>): GetWorkerLatestInferenceByTopicIdRequest {
    const message = createBaseGetWorkerLatestInferenceByTopicIdRequest();
    message.topicId = object.topicId ?? "0";
    message.workerAddress = object.workerAddress ?? "";
    return message;
  },
};

function createBaseGetWorkerLatestInferenceByTopicIdResponse(): GetWorkerLatestInferenceByTopicIdResponse {
  return { latestInference: undefined };
}

export const GetWorkerLatestInferenceByTopicIdResponse: MessageFns<GetWorkerLatestInferenceByTopicIdResponse> = {
  encode(message: GetWorkerLatestInferenceByTopicIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latestInference !== undefined) {
      Inference.encode(message.latestInference, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerLatestInferenceByTopicIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerLatestInferenceByTopicIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.latestInference = Inference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerLatestInferenceByTopicIdResponse {
    return { latestInference: isSet(object.latestInference) ? Inference.fromJSON(object.latestInference) : undefined };
  },

  toJSON(message: GetWorkerLatestInferenceByTopicIdResponse): unknown {
    const obj: any = {};
    if (message.latestInference !== undefined) {
      obj.latestInference = Inference.toJSON(message.latestInference);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkerLatestInferenceByTopicIdResponse>): GetWorkerLatestInferenceByTopicIdResponse {
    return GetWorkerLatestInferenceByTopicIdResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetWorkerLatestInferenceByTopicIdResponse>,
  ): GetWorkerLatestInferenceByTopicIdResponse {
    const message = createBaseGetWorkerLatestInferenceByTopicIdResponse();
    message.latestInference = (object.latestInference !== undefined && object.latestInference !== null)
      ? Inference.fromPartial(object.latestInference)
      : undefined;
    return message;
  },
};

function createBaseGetWorkerNodeInfoRequest(): GetWorkerNodeInfoRequest {
  return { address: "" };
}

export const GetWorkerNodeInfoRequest: MessageFns<GetWorkerNodeInfoRequest> = {
  encode(message: GetWorkerNodeInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerNodeInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerNodeInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerNodeInfoRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: GetWorkerNodeInfoRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkerNodeInfoRequest>): GetWorkerNodeInfoRequest {
    return GetWorkerNodeInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkerNodeInfoRequest>): GetWorkerNodeInfoRequest {
    const message = createBaseGetWorkerNodeInfoRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseGetWorkerNodeInfoResponse(): GetWorkerNodeInfoResponse {
  return { nodeInfo: undefined };
}

export const GetWorkerNodeInfoResponse: MessageFns<GetWorkerNodeInfoResponse> = {
  encode(message: GetWorkerNodeInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeInfo !== undefined) {
      OffchainNode.encode(message.nodeInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerNodeInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerNodeInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeInfo = OffchainNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerNodeInfoResponse {
    return { nodeInfo: isSet(object.nodeInfo) ? OffchainNode.fromJSON(object.nodeInfo) : undefined };
  },

  toJSON(message: GetWorkerNodeInfoResponse): unknown {
    const obj: any = {};
    if (message.nodeInfo !== undefined) {
      obj.nodeInfo = OffchainNode.toJSON(message.nodeInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkerNodeInfoResponse>): GetWorkerNodeInfoResponse {
    return GetWorkerNodeInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkerNodeInfoResponse>): GetWorkerNodeInfoResponse {
    const message = createBaseGetWorkerNodeInfoResponse();
    message.nodeInfo = (object.nodeInfo !== undefined && object.nodeInfo !== null)
      ? OffchainNode.fromPartial(object.nodeInfo)
      : undefined;
    return message;
  },
};

function createBaseGetReputerNodeInfoRequest(): GetReputerNodeInfoRequest {
  return { address: "" };
}

export const GetReputerNodeInfoRequest: MessageFns<GetReputerNodeInfoRequest> = {
  encode(message: GetReputerNodeInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputerNodeInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputerNodeInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputerNodeInfoRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: GetReputerNodeInfoRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputerNodeInfoRequest>): GetReputerNodeInfoRequest {
    return GetReputerNodeInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputerNodeInfoRequest>): GetReputerNodeInfoRequest {
    const message = createBaseGetReputerNodeInfoRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseGetReputerNodeInfoResponse(): GetReputerNodeInfoResponse {
  return { nodeInfo: undefined };
}

export const GetReputerNodeInfoResponse: MessageFns<GetReputerNodeInfoResponse> = {
  encode(message: GetReputerNodeInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeInfo !== undefined) {
      OffchainNode.encode(message.nodeInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputerNodeInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputerNodeInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeInfo = OffchainNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputerNodeInfoResponse {
    return { nodeInfo: isSet(object.nodeInfo) ? OffchainNode.fromJSON(object.nodeInfo) : undefined };
  },

  toJSON(message: GetReputerNodeInfoResponse): unknown {
    const obj: any = {};
    if (message.nodeInfo !== undefined) {
      obj.nodeInfo = OffchainNode.toJSON(message.nodeInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputerNodeInfoResponse>): GetReputerNodeInfoResponse {
    return GetReputerNodeInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputerNodeInfoResponse>): GetReputerNodeInfoResponse {
    const message = createBaseGetReputerNodeInfoResponse();
    message.nodeInfo = (object.nodeInfo !== undefined && object.nodeInfo !== null)
      ? OffchainNode.fromPartial(object.nodeInfo)
      : undefined;
    return message;
  },
};

function createBaseGetNetworkInferencesAtBlockRequest(): GetNetworkInferencesAtBlockRequest {
  return { topicId: "0", blockHeightLastInference: "0" };
}

export const GetNetworkInferencesAtBlockRequest: MessageFns<GetNetworkInferencesAtBlockRequest> = {
  encode(message: GetNetworkInferencesAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeightLastInference !== "0") {
      writer.uint32(16).int64(message.blockHeightLastInference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkInferencesAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkInferencesAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeightLastInference = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkInferencesAtBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeightLastInference: isSet(object.blockHeightLastInference)
        ? globalThis.String(object.blockHeightLastInference)
        : "0",
    };
  },

  toJSON(message: GetNetworkInferencesAtBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeightLastInference !== "0") {
      obj.blockHeightLastInference = message.blockHeightLastInference;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNetworkInferencesAtBlockRequest>): GetNetworkInferencesAtBlockRequest {
    return GetNetworkInferencesAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNetworkInferencesAtBlockRequest>): GetNetworkInferencesAtBlockRequest {
    const message = createBaseGetNetworkInferencesAtBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeightLastInference = object.blockHeightLastInference ?? "0";
    return message;
  },
};

function createBaseGetLatestNetworkInferencesRequest(): GetLatestNetworkInferencesRequest {
  return { topicId: "0" };
}

export const GetLatestNetworkInferencesRequest: MessageFns<GetLatestNetworkInferencesRequest> = {
  encode(message: GetLatestNetworkInferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestNetworkInferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestNetworkInferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestNetworkInferencesRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetLatestNetworkInferencesRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLatestNetworkInferencesRequest>): GetLatestNetworkInferencesRequest {
    return GetLatestNetworkInferencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLatestNetworkInferencesRequest>): GetLatestNetworkInferencesRequest {
    const message = createBaseGetLatestNetworkInferencesRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetLatestAvailableNetworkInferencesRequest(): GetLatestAvailableNetworkInferencesRequest {
  return { topicId: "0" };
}

export const GetLatestAvailableNetworkInferencesRequest: MessageFns<GetLatestAvailableNetworkInferencesRequest> = {
  encode(message: GetLatestAvailableNetworkInferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestAvailableNetworkInferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestAvailableNetworkInferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestAvailableNetworkInferencesRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetLatestAvailableNetworkInferencesRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLatestAvailableNetworkInferencesRequest>): GetLatestAvailableNetworkInferencesRequest {
    return GetLatestAvailableNetworkInferencesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetLatestAvailableNetworkInferencesRequest>,
  ): GetLatestAvailableNetworkInferencesRequest {
    const message = createBaseGetLatestAvailableNetworkInferencesRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseIsWorkerNonceUnfulfilledRequest(): IsWorkerNonceUnfulfilledRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const IsWorkerNonceUnfulfilledRequest: MessageFns<IsWorkerNonceUnfulfilledRequest> = {
  encode(message: IsWorkerNonceUnfulfilledRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsWorkerNonceUnfulfilledRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsWorkerNonceUnfulfilledRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsWorkerNonceUnfulfilledRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: IsWorkerNonceUnfulfilledRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<IsWorkerNonceUnfulfilledRequest>): IsWorkerNonceUnfulfilledRequest {
    return IsWorkerNonceUnfulfilledRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsWorkerNonceUnfulfilledRequest>): IsWorkerNonceUnfulfilledRequest {
    const message = createBaseIsWorkerNonceUnfulfilledRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseIsWorkerNonceUnfulfilledResponse(): IsWorkerNonceUnfulfilledResponse {
  return { isWorkerNonceUnfulfilled: false };
}

export const IsWorkerNonceUnfulfilledResponse: MessageFns<IsWorkerNonceUnfulfilledResponse> = {
  encode(message: IsWorkerNonceUnfulfilledResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isWorkerNonceUnfulfilled !== false) {
      writer.uint32(8).bool(message.isWorkerNonceUnfulfilled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsWorkerNonceUnfulfilledResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsWorkerNonceUnfulfilledResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isWorkerNonceUnfulfilled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsWorkerNonceUnfulfilledResponse {
    return {
      isWorkerNonceUnfulfilled: isSet(object.isWorkerNonceUnfulfilled)
        ? globalThis.Boolean(object.isWorkerNonceUnfulfilled)
        : false,
    };
  },

  toJSON(message: IsWorkerNonceUnfulfilledResponse): unknown {
    const obj: any = {};
    if (message.isWorkerNonceUnfulfilled !== false) {
      obj.isWorkerNonceUnfulfilled = message.isWorkerNonceUnfulfilled;
    }
    return obj;
  },

  create(base?: DeepPartial<IsWorkerNonceUnfulfilledResponse>): IsWorkerNonceUnfulfilledResponse {
    return IsWorkerNonceUnfulfilledResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsWorkerNonceUnfulfilledResponse>): IsWorkerNonceUnfulfilledResponse {
    const message = createBaseIsWorkerNonceUnfulfilledResponse();
    message.isWorkerNonceUnfulfilled = object.isWorkerNonceUnfulfilled ?? false;
    return message;
  },
};

function createBaseGetUnfulfilledReputerNoncesRequest(): GetUnfulfilledReputerNoncesRequest {
  return { topicId: "0" };
}

export const GetUnfulfilledReputerNoncesRequest: MessageFns<GetUnfulfilledReputerNoncesRequest> = {
  encode(message: GetUnfulfilledReputerNoncesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnfulfilledReputerNoncesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnfulfilledReputerNoncesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnfulfilledReputerNoncesRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetUnfulfilledReputerNoncesRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUnfulfilledReputerNoncesRequest>): GetUnfulfilledReputerNoncesRequest {
    return GetUnfulfilledReputerNoncesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUnfulfilledReputerNoncesRequest>): GetUnfulfilledReputerNoncesRequest {
    const message = createBaseGetUnfulfilledReputerNoncesRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetUnfulfilledReputerNoncesResponse(): GetUnfulfilledReputerNoncesResponse {
  return { nonces: undefined };
}

export const GetUnfulfilledReputerNoncesResponse: MessageFns<GetUnfulfilledReputerNoncesResponse> = {
  encode(message: GetUnfulfilledReputerNoncesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nonces !== undefined) {
      ReputerRequestNonces.encode(message.nonces, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnfulfilledReputerNoncesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnfulfilledReputerNoncesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nonces = ReputerRequestNonces.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnfulfilledReputerNoncesResponse {
    return { nonces: isSet(object.nonces) ? ReputerRequestNonces.fromJSON(object.nonces) : undefined };
  },

  toJSON(message: GetUnfulfilledReputerNoncesResponse): unknown {
    const obj: any = {};
    if (message.nonces !== undefined) {
      obj.nonces = ReputerRequestNonces.toJSON(message.nonces);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUnfulfilledReputerNoncesResponse>): GetUnfulfilledReputerNoncesResponse {
    return GetUnfulfilledReputerNoncesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUnfulfilledReputerNoncesResponse>): GetUnfulfilledReputerNoncesResponse {
    const message = createBaseGetUnfulfilledReputerNoncesResponse();
    message.nonces = (object.nonces !== undefined && object.nonces !== null)
      ? ReputerRequestNonces.fromPartial(object.nonces)
      : undefined;
    return message;
  },
};

function createBaseGetUnfulfilledWorkerNoncesRequest(): GetUnfulfilledWorkerNoncesRequest {
  return { topicId: "0" };
}

export const GetUnfulfilledWorkerNoncesRequest: MessageFns<GetUnfulfilledWorkerNoncesRequest> = {
  encode(message: GetUnfulfilledWorkerNoncesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnfulfilledWorkerNoncesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnfulfilledWorkerNoncesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnfulfilledWorkerNoncesRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetUnfulfilledWorkerNoncesRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUnfulfilledWorkerNoncesRequest>): GetUnfulfilledWorkerNoncesRequest {
    return GetUnfulfilledWorkerNoncesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUnfulfilledWorkerNoncesRequest>): GetUnfulfilledWorkerNoncesRequest {
    const message = createBaseGetUnfulfilledWorkerNoncesRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetUnfulfilledWorkerNoncesResponse(): GetUnfulfilledWorkerNoncesResponse {
  return { nonces: undefined };
}

export const GetUnfulfilledWorkerNoncesResponse: MessageFns<GetUnfulfilledWorkerNoncesResponse> = {
  encode(message: GetUnfulfilledWorkerNoncesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nonces !== undefined) {
      Nonces.encode(message.nonces, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnfulfilledWorkerNoncesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnfulfilledWorkerNoncesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nonces = Nonces.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnfulfilledWorkerNoncesResponse {
    return { nonces: isSet(object.nonces) ? Nonces.fromJSON(object.nonces) : undefined };
  },

  toJSON(message: GetUnfulfilledWorkerNoncesResponse): unknown {
    const obj: any = {};
    if (message.nonces !== undefined) {
      obj.nonces = Nonces.toJSON(message.nonces);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUnfulfilledWorkerNoncesResponse>): GetUnfulfilledWorkerNoncesResponse {
    return GetUnfulfilledWorkerNoncesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUnfulfilledWorkerNoncesResponse>): GetUnfulfilledWorkerNoncesResponse {
    const message = createBaseGetUnfulfilledWorkerNoncesResponse();
    message.nonces = (object.nonces !== undefined && object.nonces !== null)
      ? Nonces.fromPartial(object.nonces)
      : undefined;
    return message;
  },
};

function createBaseGetInfererNetworkRegretRequest(): GetInfererNetworkRegretRequest {
  return { topicId: "0", actorId: "" };
}

export const GetInfererNetworkRegretRequest: MessageFns<GetInfererNetworkRegretRequest> = {
  encode(message: GetInfererNetworkRegretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInfererNetworkRegretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInfererNetworkRegretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInfererNetworkRegretRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
    };
  },

  toJSON(message: GetInfererNetworkRegretRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInfererNetworkRegretRequest>): GetInfererNetworkRegretRequest {
    return GetInfererNetworkRegretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInfererNetworkRegretRequest>): GetInfererNetworkRegretRequest {
    const message = createBaseGetInfererNetworkRegretRequest();
    message.topicId = object.topicId ?? "0";
    message.actorId = object.actorId ?? "";
    return message;
  },
};

function createBaseGetInfererNetworkRegretResponse(): GetInfererNetworkRegretResponse {
  return { regret: undefined };
}

export const GetInfererNetworkRegretResponse: MessageFns<GetInfererNetworkRegretResponse> = {
  encode(message: GetInfererNetworkRegretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regret !== undefined) {
      TimestampedValue.encode(message.regret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInfererNetworkRegretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInfererNetworkRegretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regret = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInfererNetworkRegretResponse {
    return { regret: isSet(object.regret) ? TimestampedValue.fromJSON(object.regret) : undefined };
  },

  toJSON(message: GetInfererNetworkRegretResponse): unknown {
    const obj: any = {};
    if (message.regret !== undefined) {
      obj.regret = TimestampedValue.toJSON(message.regret);
    }
    return obj;
  },

  create(base?: DeepPartial<GetInfererNetworkRegretResponse>): GetInfererNetworkRegretResponse {
    return GetInfererNetworkRegretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInfererNetworkRegretResponse>): GetInfererNetworkRegretResponse {
    const message = createBaseGetInfererNetworkRegretResponse();
    message.regret = (object.regret !== undefined && object.regret !== null)
      ? TimestampedValue.fromPartial(object.regret)
      : undefined;
    return message;
  },
};

function createBaseGetForecasterNetworkRegretRequest(): GetForecasterNetworkRegretRequest {
  return { topicId: "0", worker: "" };
}

export const GetForecasterNetworkRegretRequest: MessageFns<GetForecasterNetworkRegretRequest> = {
  encode(message: GetForecasterNetworkRegretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.worker !== "") {
      writer.uint32(18).string(message.worker);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetForecasterNetworkRegretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetForecasterNetworkRegretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.worker = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetForecasterNetworkRegretRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      worker: isSet(object.worker) ? globalThis.String(object.worker) : "",
    };
  },

  toJSON(message: GetForecasterNetworkRegretRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.worker !== "") {
      obj.worker = message.worker;
    }
    return obj;
  },

  create(base?: DeepPartial<GetForecasterNetworkRegretRequest>): GetForecasterNetworkRegretRequest {
    return GetForecasterNetworkRegretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetForecasterNetworkRegretRequest>): GetForecasterNetworkRegretRequest {
    const message = createBaseGetForecasterNetworkRegretRequest();
    message.topicId = object.topicId ?? "0";
    message.worker = object.worker ?? "";
    return message;
  },
};

function createBaseGetForecasterNetworkRegretResponse(): GetForecasterNetworkRegretResponse {
  return { regret: undefined };
}

export const GetForecasterNetworkRegretResponse: MessageFns<GetForecasterNetworkRegretResponse> = {
  encode(message: GetForecasterNetworkRegretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regret !== undefined) {
      TimestampedValue.encode(message.regret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetForecasterNetworkRegretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetForecasterNetworkRegretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regret = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetForecasterNetworkRegretResponse {
    return { regret: isSet(object.regret) ? TimestampedValue.fromJSON(object.regret) : undefined };
  },

  toJSON(message: GetForecasterNetworkRegretResponse): unknown {
    const obj: any = {};
    if (message.regret !== undefined) {
      obj.regret = TimestampedValue.toJSON(message.regret);
    }
    return obj;
  },

  create(base?: DeepPartial<GetForecasterNetworkRegretResponse>): GetForecasterNetworkRegretResponse {
    return GetForecasterNetworkRegretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetForecasterNetworkRegretResponse>): GetForecasterNetworkRegretResponse {
    const message = createBaseGetForecasterNetworkRegretResponse();
    message.regret = (object.regret !== undefined && object.regret !== null)
      ? TimestampedValue.fromPartial(object.regret)
      : undefined;
    return message;
  },
};

function createBaseGetOneInForecasterNetworkRegretRequest(): GetOneInForecasterNetworkRegretRequest {
  return { topicId: "0", forecaster: "", inferer: "" };
}

export const GetOneInForecasterNetworkRegretRequest: MessageFns<GetOneInForecasterNetworkRegretRequest> = {
  encode(message: GetOneInForecasterNetworkRegretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.forecaster !== "") {
      writer.uint32(18).string(message.forecaster);
    }
    if (message.inferer !== "") {
      writer.uint32(26).string(message.inferer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneInForecasterNetworkRegretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneInForecasterNetworkRegretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.forecaster = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inferer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneInForecasterNetworkRegretRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      forecaster: isSet(object.forecaster) ? globalThis.String(object.forecaster) : "",
      inferer: isSet(object.inferer) ? globalThis.String(object.inferer) : "",
    };
  },

  toJSON(message: GetOneInForecasterNetworkRegretRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.forecaster !== "") {
      obj.forecaster = message.forecaster;
    }
    if (message.inferer !== "") {
      obj.inferer = message.inferer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOneInForecasterNetworkRegretRequest>): GetOneInForecasterNetworkRegretRequest {
    return GetOneInForecasterNetworkRegretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOneInForecasterNetworkRegretRequest>): GetOneInForecasterNetworkRegretRequest {
    const message = createBaseGetOneInForecasterNetworkRegretRequest();
    message.topicId = object.topicId ?? "0";
    message.forecaster = object.forecaster ?? "";
    message.inferer = object.inferer ?? "";
    return message;
  },
};

function createBaseGetOneInForecasterNetworkRegretResponse(): GetOneInForecasterNetworkRegretResponse {
  return { regret: undefined };
}

export const GetOneInForecasterNetworkRegretResponse: MessageFns<GetOneInForecasterNetworkRegretResponse> = {
  encode(message: GetOneInForecasterNetworkRegretResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regret !== undefined) {
      TimestampedValue.encode(message.regret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneInForecasterNetworkRegretResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneInForecasterNetworkRegretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regret = TimestampedValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneInForecasterNetworkRegretResponse {
    return { regret: isSet(object.regret) ? TimestampedValue.fromJSON(object.regret) : undefined };
  },

  toJSON(message: GetOneInForecasterNetworkRegretResponse): unknown {
    const obj: any = {};
    if (message.regret !== undefined) {
      obj.regret = TimestampedValue.toJSON(message.regret);
    }
    return obj;
  },

  create(base?: DeepPartial<GetOneInForecasterNetworkRegretResponse>): GetOneInForecasterNetworkRegretResponse {
    return GetOneInForecasterNetworkRegretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOneInForecasterNetworkRegretResponse>): GetOneInForecasterNetworkRegretResponse {
    const message = createBaseGetOneInForecasterNetworkRegretResponse();
    message.regret = (object.regret !== undefined && object.regret !== null)
      ? TimestampedValue.fromPartial(object.regret)
      : undefined;
    return message;
  },
};

function createBaseIsReputerNonceUnfulfilledRequest(): IsReputerNonceUnfulfilledRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const IsReputerNonceUnfulfilledRequest: MessageFns<IsReputerNonceUnfulfilledRequest> = {
  encode(message: IsReputerNonceUnfulfilledRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsReputerNonceUnfulfilledRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsReputerNonceUnfulfilledRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsReputerNonceUnfulfilledRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: IsReputerNonceUnfulfilledRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<IsReputerNonceUnfulfilledRequest>): IsReputerNonceUnfulfilledRequest {
    return IsReputerNonceUnfulfilledRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsReputerNonceUnfulfilledRequest>): IsReputerNonceUnfulfilledRequest {
    const message = createBaseIsReputerNonceUnfulfilledRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseIsReputerNonceUnfulfilledResponse(): IsReputerNonceUnfulfilledResponse {
  return { isReputerNonceUnfulfilled: false };
}

export const IsReputerNonceUnfulfilledResponse: MessageFns<IsReputerNonceUnfulfilledResponse> = {
  encode(message: IsReputerNonceUnfulfilledResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isReputerNonceUnfulfilled !== false) {
      writer.uint32(8).bool(message.isReputerNonceUnfulfilled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsReputerNonceUnfulfilledResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsReputerNonceUnfulfilledResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isReputerNonceUnfulfilled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsReputerNonceUnfulfilledResponse {
    return {
      isReputerNonceUnfulfilled: isSet(object.isReputerNonceUnfulfilled)
        ? globalThis.Boolean(object.isReputerNonceUnfulfilled)
        : false,
    };
  },

  toJSON(message: IsReputerNonceUnfulfilledResponse): unknown {
    const obj: any = {};
    if (message.isReputerNonceUnfulfilled !== false) {
      obj.isReputerNonceUnfulfilled = message.isReputerNonceUnfulfilled;
    }
    return obj;
  },

  create(base?: DeepPartial<IsReputerNonceUnfulfilledResponse>): IsReputerNonceUnfulfilledResponse {
    return IsReputerNonceUnfulfilledResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsReputerNonceUnfulfilledResponse>): IsReputerNonceUnfulfilledResponse {
    const message = createBaseIsReputerNonceUnfulfilledResponse();
    message.isReputerNonceUnfulfilled = object.isReputerNonceUnfulfilled ?? false;
    return message;
  },
};

function createBaseGetNetworkInferencesAtBlockResponse(): GetNetworkInferencesAtBlockResponse {
  return { networkInferences: undefined };
}

export const GetNetworkInferencesAtBlockResponse: MessageFns<GetNetworkInferencesAtBlockResponse> = {
  encode(message: GetNetworkInferencesAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkInferences !== undefined) {
      ValueBundle.encode(message.networkInferences, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkInferencesAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkInferencesAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.networkInferences = ValueBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkInferencesAtBlockResponse {
    return {
      networkInferences: isSet(object.networkInferences) ? ValueBundle.fromJSON(object.networkInferences) : undefined,
    };
  },

  toJSON(message: GetNetworkInferencesAtBlockResponse): unknown {
    const obj: any = {};
    if (message.networkInferences !== undefined) {
      obj.networkInferences = ValueBundle.toJSON(message.networkInferences);
    }
    return obj;
  },

  create(base?: DeepPartial<GetNetworkInferencesAtBlockResponse>): GetNetworkInferencesAtBlockResponse {
    return GetNetworkInferencesAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNetworkInferencesAtBlockResponse>): GetNetworkInferencesAtBlockResponse {
    const message = createBaseGetNetworkInferencesAtBlockResponse();
    message.networkInferences = (object.networkInferences !== undefined && object.networkInferences !== null)
      ? ValueBundle.fromPartial(object.networkInferences)
      : undefined;
    return message;
  },
};

function createBaseGetLatestNetworkInferencesResponse(): GetLatestNetworkInferencesResponse {
  return {
    networkInferences: undefined,
    infererWeights: [],
    forecasterWeights: [],
    inferenceBlockHeight: "0",
    lossBlockHeight: "0",
    confidenceIntervalRawPercentiles: [],
    confidenceIntervalValues: [],
  };
}

export const GetLatestNetworkInferencesResponse: MessageFns<GetLatestNetworkInferencesResponse> = {
  encode(message: GetLatestNetworkInferencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkInferences !== undefined) {
      ValueBundle.encode(message.networkInferences, writer.uint32(10).fork()).join();
    }
    for (const v of message.infererWeights) {
      RegretInformedWeight.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.forecasterWeights) {
      RegretInformedWeight.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.inferenceBlockHeight !== "0") {
      writer.uint32(40).int64(message.inferenceBlockHeight);
    }
    if (message.lossBlockHeight !== "0") {
      writer.uint32(48).int64(message.lossBlockHeight);
    }
    for (const v of message.confidenceIntervalRawPercentiles) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.confidenceIntervalValues) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestNetworkInferencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestNetworkInferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.networkInferences = ValueBundle.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.infererWeights.push(RegretInformedWeight.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.forecasterWeights.push(RegretInformedWeight.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.inferenceBlockHeight = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lossBlockHeight = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.confidenceIntervalRawPercentiles.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.confidenceIntervalValues.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestNetworkInferencesResponse {
    return {
      networkInferences: isSet(object.networkInferences) ? ValueBundle.fromJSON(object.networkInferences) : undefined,
      infererWeights: globalThis.Array.isArray(object?.infererWeights)
        ? object.infererWeights.map((e: any) => RegretInformedWeight.fromJSON(e))
        : [],
      forecasterWeights: globalThis.Array.isArray(object?.forecasterWeights)
        ? object.forecasterWeights.map((e: any) => RegretInformedWeight.fromJSON(e))
        : [],
      inferenceBlockHeight: isSet(object.inferenceBlockHeight) ? globalThis.String(object.inferenceBlockHeight) : "0",
      lossBlockHeight: isSet(object.lossBlockHeight) ? globalThis.String(object.lossBlockHeight) : "0",
      confidenceIntervalRawPercentiles: globalThis.Array.isArray(object?.confidenceIntervalRawPercentiles)
        ? object.confidenceIntervalRawPercentiles.map((e: any) => globalThis.String(e))
        : [],
      confidenceIntervalValues: globalThis.Array.isArray(object?.confidenceIntervalValues)
        ? object.confidenceIntervalValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetLatestNetworkInferencesResponse): unknown {
    const obj: any = {};
    if (message.networkInferences !== undefined) {
      obj.networkInferences = ValueBundle.toJSON(message.networkInferences);
    }
    if (message.infererWeights?.length) {
      obj.infererWeights = message.infererWeights.map((e) => RegretInformedWeight.toJSON(e));
    }
    if (message.forecasterWeights?.length) {
      obj.forecasterWeights = message.forecasterWeights.map((e) => RegretInformedWeight.toJSON(e));
    }
    if (message.inferenceBlockHeight !== "0") {
      obj.inferenceBlockHeight = message.inferenceBlockHeight;
    }
    if (message.lossBlockHeight !== "0") {
      obj.lossBlockHeight = message.lossBlockHeight;
    }
    if (message.confidenceIntervalRawPercentiles?.length) {
      obj.confidenceIntervalRawPercentiles = message.confidenceIntervalRawPercentiles;
    }
    if (message.confidenceIntervalValues?.length) {
      obj.confidenceIntervalValues = message.confidenceIntervalValues;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLatestNetworkInferencesResponse>): GetLatestNetworkInferencesResponse {
    return GetLatestNetworkInferencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLatestNetworkInferencesResponse>): GetLatestNetworkInferencesResponse {
    const message = createBaseGetLatestNetworkInferencesResponse();
    message.networkInferences = (object.networkInferences !== undefined && object.networkInferences !== null)
      ? ValueBundle.fromPartial(object.networkInferences)
      : undefined;
    message.infererWeights = object.infererWeights?.map((e) => RegretInformedWeight.fromPartial(e)) || [];
    message.forecasterWeights = object.forecasterWeights?.map((e) => RegretInformedWeight.fromPartial(e)) || [];
    message.inferenceBlockHeight = object.inferenceBlockHeight ?? "0";
    message.lossBlockHeight = object.lossBlockHeight ?? "0";
    message.confidenceIntervalRawPercentiles = object.confidenceIntervalRawPercentiles?.map((e) => e) || [];
    message.confidenceIntervalValues = object.confidenceIntervalValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetLatestAvailableNetworkInferencesResponse(): GetLatestAvailableNetworkInferencesResponse {
  return {
    networkInferences: undefined,
    infererWeights: [],
    forecasterWeights: [],
    inferenceBlockHeight: "0",
    lossBlockHeight: "0",
    confidenceIntervalRawPercentiles: [],
    confidenceIntervalValues: [],
  };
}

export const GetLatestAvailableNetworkInferencesResponse: MessageFns<GetLatestAvailableNetworkInferencesResponse> = {
  encode(
    message: GetLatestAvailableNetworkInferencesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.networkInferences !== undefined) {
      ValueBundle.encode(message.networkInferences, writer.uint32(10).fork()).join();
    }
    for (const v of message.infererWeights) {
      RegretInformedWeight.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.forecasterWeights) {
      RegretInformedWeight.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.inferenceBlockHeight !== "0") {
      writer.uint32(40).int64(message.inferenceBlockHeight);
    }
    if (message.lossBlockHeight !== "0") {
      writer.uint32(48).int64(message.lossBlockHeight);
    }
    for (const v of message.confidenceIntervalRawPercentiles) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.confidenceIntervalValues) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLatestAvailableNetworkInferencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLatestAvailableNetworkInferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.networkInferences = ValueBundle.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.infererWeights.push(RegretInformedWeight.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.forecasterWeights.push(RegretInformedWeight.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.inferenceBlockHeight = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lossBlockHeight = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.confidenceIntervalRawPercentiles.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.confidenceIntervalValues.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLatestAvailableNetworkInferencesResponse {
    return {
      networkInferences: isSet(object.networkInferences) ? ValueBundle.fromJSON(object.networkInferences) : undefined,
      infererWeights: globalThis.Array.isArray(object?.infererWeights)
        ? object.infererWeights.map((e: any) => RegretInformedWeight.fromJSON(e))
        : [],
      forecasterWeights: globalThis.Array.isArray(object?.forecasterWeights)
        ? object.forecasterWeights.map((e: any) => RegretInformedWeight.fromJSON(e))
        : [],
      inferenceBlockHeight: isSet(object.inferenceBlockHeight) ? globalThis.String(object.inferenceBlockHeight) : "0",
      lossBlockHeight: isSet(object.lossBlockHeight) ? globalThis.String(object.lossBlockHeight) : "0",
      confidenceIntervalRawPercentiles: globalThis.Array.isArray(object?.confidenceIntervalRawPercentiles)
        ? object.confidenceIntervalRawPercentiles.map((e: any) => globalThis.String(e))
        : [],
      confidenceIntervalValues: globalThis.Array.isArray(object?.confidenceIntervalValues)
        ? object.confidenceIntervalValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetLatestAvailableNetworkInferencesResponse): unknown {
    const obj: any = {};
    if (message.networkInferences !== undefined) {
      obj.networkInferences = ValueBundle.toJSON(message.networkInferences);
    }
    if (message.infererWeights?.length) {
      obj.infererWeights = message.infererWeights.map((e) => RegretInformedWeight.toJSON(e));
    }
    if (message.forecasterWeights?.length) {
      obj.forecasterWeights = message.forecasterWeights.map((e) => RegretInformedWeight.toJSON(e));
    }
    if (message.inferenceBlockHeight !== "0") {
      obj.inferenceBlockHeight = message.inferenceBlockHeight;
    }
    if (message.lossBlockHeight !== "0") {
      obj.lossBlockHeight = message.lossBlockHeight;
    }
    if (message.confidenceIntervalRawPercentiles?.length) {
      obj.confidenceIntervalRawPercentiles = message.confidenceIntervalRawPercentiles;
    }
    if (message.confidenceIntervalValues?.length) {
      obj.confidenceIntervalValues = message.confidenceIntervalValues;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLatestAvailableNetworkInferencesResponse>): GetLatestAvailableNetworkInferencesResponse {
    return GetLatestAvailableNetworkInferencesResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetLatestAvailableNetworkInferencesResponse>,
  ): GetLatestAvailableNetworkInferencesResponse {
    const message = createBaseGetLatestAvailableNetworkInferencesResponse();
    message.networkInferences = (object.networkInferences !== undefined && object.networkInferences !== null)
      ? ValueBundle.fromPartial(object.networkInferences)
      : undefined;
    message.infererWeights = object.infererWeights?.map((e) => RegretInformedWeight.fromPartial(e)) || [];
    message.forecasterWeights = object.forecasterWeights?.map((e) => RegretInformedWeight.fromPartial(e)) || [];
    message.inferenceBlockHeight = object.inferenceBlockHeight ?? "0";
    message.lossBlockHeight = object.lossBlockHeight ?? "0";
    message.confidenceIntervalRawPercentiles = object.confidenceIntervalRawPercentiles?.map((e) => e) || [];
    message.confidenceIntervalValues = object.confidenceIntervalValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseIsWorkerRegisteredInTopicIdRequest(): IsWorkerRegisteredInTopicIdRequest {
  return { topicId: "0", address: "" };
}

export const IsWorkerRegisteredInTopicIdRequest: MessageFns<IsWorkerRegisteredInTopicIdRequest> = {
  encode(message: IsWorkerRegisteredInTopicIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsWorkerRegisteredInTopicIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsWorkerRegisteredInTopicIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsWorkerRegisteredInTopicIdRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: IsWorkerRegisteredInTopicIdRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<IsWorkerRegisteredInTopicIdRequest>): IsWorkerRegisteredInTopicIdRequest {
    return IsWorkerRegisteredInTopicIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsWorkerRegisteredInTopicIdRequest>): IsWorkerRegisteredInTopicIdRequest {
    const message = createBaseIsWorkerRegisteredInTopicIdRequest();
    message.topicId = object.topicId ?? "0";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseIsWorkerRegisteredInTopicIdResponse(): IsWorkerRegisteredInTopicIdResponse {
  return { isRegistered: false };
}

export const IsWorkerRegisteredInTopicIdResponse: MessageFns<IsWorkerRegisteredInTopicIdResponse> = {
  encode(message: IsWorkerRegisteredInTopicIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isRegistered !== false) {
      writer.uint32(8).bool(message.isRegistered);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsWorkerRegisteredInTopicIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsWorkerRegisteredInTopicIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isRegistered = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsWorkerRegisteredInTopicIdResponse {
    return { isRegistered: isSet(object.isRegistered) ? globalThis.Boolean(object.isRegistered) : false };
  },

  toJSON(message: IsWorkerRegisteredInTopicIdResponse): unknown {
    const obj: any = {};
    if (message.isRegistered !== false) {
      obj.isRegistered = message.isRegistered;
    }
    return obj;
  },

  create(base?: DeepPartial<IsWorkerRegisteredInTopicIdResponse>): IsWorkerRegisteredInTopicIdResponse {
    return IsWorkerRegisteredInTopicIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsWorkerRegisteredInTopicIdResponse>): IsWorkerRegisteredInTopicIdResponse {
    const message = createBaseIsWorkerRegisteredInTopicIdResponse();
    message.isRegistered = object.isRegistered ?? false;
    return message;
  },
};

function createBaseIsReputerRegisteredInTopicIdRequest(): IsReputerRegisteredInTopicIdRequest {
  return { topicId: "0", address: "" };
}

export const IsReputerRegisteredInTopicIdRequest: MessageFns<IsReputerRegisteredInTopicIdRequest> = {
  encode(message: IsReputerRegisteredInTopicIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsReputerRegisteredInTopicIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsReputerRegisteredInTopicIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsReputerRegisteredInTopicIdRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: IsReputerRegisteredInTopicIdRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<IsReputerRegisteredInTopicIdRequest>): IsReputerRegisteredInTopicIdRequest {
    return IsReputerRegisteredInTopicIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsReputerRegisteredInTopicIdRequest>): IsReputerRegisteredInTopicIdRequest {
    const message = createBaseIsReputerRegisteredInTopicIdRequest();
    message.topicId = object.topicId ?? "0";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseIsReputerRegisteredInTopicIdResponse(): IsReputerRegisteredInTopicIdResponse {
  return { isRegistered: false };
}

export const IsReputerRegisteredInTopicIdResponse: MessageFns<IsReputerRegisteredInTopicIdResponse> = {
  encode(message: IsReputerRegisteredInTopicIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isRegistered !== false) {
      writer.uint32(8).bool(message.isRegistered);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsReputerRegisteredInTopicIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsReputerRegisteredInTopicIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isRegistered = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsReputerRegisteredInTopicIdResponse {
    return { isRegistered: isSet(object.isRegistered) ? globalThis.Boolean(object.isRegistered) : false };
  },

  toJSON(message: IsReputerRegisteredInTopicIdResponse): unknown {
    const obj: any = {};
    if (message.isRegistered !== false) {
      obj.isRegistered = message.isRegistered;
    }
    return obj;
  },

  create(base?: DeepPartial<IsReputerRegisteredInTopicIdResponse>): IsReputerRegisteredInTopicIdResponse {
    return IsReputerRegisteredInTopicIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsReputerRegisteredInTopicIdResponse>): IsReputerRegisteredInTopicIdResponse {
    const message = createBaseIsReputerRegisteredInTopicIdResponse();
    message.isRegistered = object.isRegistered ?? false;
    return message;
  },
};

function createBaseIsWhitelistAdminRequest(): IsWhitelistAdminRequest {
  return { address: "" };
}

export const IsWhitelistAdminRequest: MessageFns<IsWhitelistAdminRequest> = {
  encode(message: IsWhitelistAdminRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsWhitelistAdminRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsWhitelistAdminRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsWhitelistAdminRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: IsWhitelistAdminRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<IsWhitelistAdminRequest>): IsWhitelistAdminRequest {
    return IsWhitelistAdminRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsWhitelistAdminRequest>): IsWhitelistAdminRequest {
    const message = createBaseIsWhitelistAdminRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseIsWhitelistAdminResponse(): IsWhitelistAdminResponse {
  return { isAdmin: false };
}

export const IsWhitelistAdminResponse: MessageFns<IsWhitelistAdminResponse> = {
  encode(message: IsWhitelistAdminResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isAdmin !== false) {
      writer.uint32(8).bool(message.isAdmin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsWhitelistAdminResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsWhitelistAdminResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isAdmin = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsWhitelistAdminResponse {
    return { isAdmin: isSet(object.isAdmin) ? globalThis.Boolean(object.isAdmin) : false };
  },

  toJSON(message: IsWhitelistAdminResponse): unknown {
    const obj: any = {};
    if (message.isAdmin !== false) {
      obj.isAdmin = message.isAdmin;
    }
    return obj;
  },

  create(base?: DeepPartial<IsWhitelistAdminResponse>): IsWhitelistAdminResponse {
    return IsWhitelistAdminResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsWhitelistAdminResponse>): IsWhitelistAdminResponse {
    const message = createBaseIsWhitelistAdminResponse();
    message.isAdmin = object.isAdmin ?? false;
    return message;
  },
};

function createBaseGetStakeRemovalsUpUntilBlockRequest(): GetStakeRemovalsUpUntilBlockRequest {
  return { blockHeight: "0" };
}

export const GetStakeRemovalsUpUntilBlockRequest: MessageFns<GetStakeRemovalsUpUntilBlockRequest> = {
  encode(message: GetStakeRemovalsUpUntilBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHeight !== "0") {
      writer.uint32(8).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeRemovalsUpUntilBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeRemovalsUpUntilBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeRemovalsUpUntilBlockRequest {
    return { blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0" };
  },

  toJSON(message: GetStakeRemovalsUpUntilBlockRequest): unknown {
    const obj: any = {};
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeRemovalsUpUntilBlockRequest>): GetStakeRemovalsUpUntilBlockRequest {
    return GetStakeRemovalsUpUntilBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeRemovalsUpUntilBlockRequest>): GetStakeRemovalsUpUntilBlockRequest {
    const message = createBaseGetStakeRemovalsUpUntilBlockRequest();
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetStakeRemovalsUpUntilBlockResponse(): GetStakeRemovalsUpUntilBlockResponse {
  return { removals: [] };
}

export const GetStakeRemovalsUpUntilBlockResponse: MessageFns<GetStakeRemovalsUpUntilBlockResponse> = {
  encode(message: GetStakeRemovalsUpUntilBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.removals) {
      StakeRemovalInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeRemovalsUpUntilBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeRemovalsUpUntilBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.removals.push(StakeRemovalInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeRemovalsUpUntilBlockResponse {
    return {
      removals: globalThis.Array.isArray(object?.removals)
        ? object.removals.map((e: any) => StakeRemovalInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetStakeRemovalsUpUntilBlockResponse): unknown {
    const obj: any = {};
    if (message.removals?.length) {
      obj.removals = message.removals.map((e) => StakeRemovalInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeRemovalsUpUntilBlockResponse>): GetStakeRemovalsUpUntilBlockResponse {
    return GetStakeRemovalsUpUntilBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeRemovalsUpUntilBlockResponse>): GetStakeRemovalsUpUntilBlockResponse {
    const message = createBaseGetStakeRemovalsUpUntilBlockResponse();
    message.removals = object.removals?.map((e) => StakeRemovalInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDelegateStakeRemovalsUpUntilBlockRequest(): GetDelegateStakeRemovalsUpUntilBlockRequest {
  return { blockHeight: "0" };
}

export const GetDelegateStakeRemovalsUpUntilBlockRequest: MessageFns<GetDelegateStakeRemovalsUpUntilBlockRequest> = {
  encode(
    message: GetDelegateStakeRemovalsUpUntilBlockRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.blockHeight !== "0") {
      writer.uint32(8).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeRemovalsUpUntilBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeRemovalsUpUntilBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeRemovalsUpUntilBlockRequest {
    return { blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0" };
  },

  toJSON(message: GetDelegateStakeRemovalsUpUntilBlockRequest): unknown {
    const obj: any = {};
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeRemovalsUpUntilBlockRequest>): GetDelegateStakeRemovalsUpUntilBlockRequest {
    return GetDelegateStakeRemovalsUpUntilBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetDelegateStakeRemovalsUpUntilBlockRequest>,
  ): GetDelegateStakeRemovalsUpUntilBlockRequest {
    const message = createBaseGetDelegateStakeRemovalsUpUntilBlockRequest();
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetDelegateStakeRemovalsUpUntilBlockResponse(): GetDelegateStakeRemovalsUpUntilBlockResponse {
  return { removals: [] };
}

export const GetDelegateStakeRemovalsUpUntilBlockResponse: MessageFns<GetDelegateStakeRemovalsUpUntilBlockResponse> = {
  encode(
    message: GetDelegateStakeRemovalsUpUntilBlockResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.removals) {
      DelegateStakeRemovalInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeRemovalsUpUntilBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeRemovalsUpUntilBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.removals.push(DelegateStakeRemovalInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeRemovalsUpUntilBlockResponse {
    return {
      removals: globalThis.Array.isArray(object?.removals)
        ? object.removals.map((e: any) => DelegateStakeRemovalInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetDelegateStakeRemovalsUpUntilBlockResponse): unknown {
    const obj: any = {};
    if (message.removals?.length) {
      obj.removals = message.removals.map((e) => DelegateStakeRemovalInfo.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetDelegateStakeRemovalsUpUntilBlockResponse>,
  ): GetDelegateStakeRemovalsUpUntilBlockResponse {
    return GetDelegateStakeRemovalsUpUntilBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetDelegateStakeRemovalsUpUntilBlockResponse>,
  ): GetDelegateStakeRemovalsUpUntilBlockResponse {
    const message = createBaseGetDelegateStakeRemovalsUpUntilBlockResponse();
    message.removals = object.removals?.map((e) => DelegateStakeRemovalInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetStakeRemovalInfoRequest(): GetStakeRemovalInfoRequest {
  return { topicId: "0", reputer: "" };
}

export const GetStakeRemovalInfoRequest: MessageFns<GetStakeRemovalInfoRequest> = {
  encode(message: GetStakeRemovalInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(18).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeRemovalInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeRemovalInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeRemovalInfoRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: GetStakeRemovalInfoRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeRemovalInfoRequest>): GetStakeRemovalInfoRequest {
    return GetStakeRemovalInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeRemovalInfoRequest>): GetStakeRemovalInfoRequest {
    const message = createBaseGetStakeRemovalInfoRequest();
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseGetStakeRemovalInfoResponse(): GetStakeRemovalInfoResponse {
  return { removal: undefined };
}

export const GetStakeRemovalInfoResponse: MessageFns<GetStakeRemovalInfoResponse> = {
  encode(message: GetStakeRemovalInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.removal !== undefined) {
      StakeRemovalInfo.encode(message.removal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeRemovalInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeRemovalInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.removal = StakeRemovalInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeRemovalInfoResponse {
    return { removal: isSet(object.removal) ? StakeRemovalInfo.fromJSON(object.removal) : undefined };
  },

  toJSON(message: GetStakeRemovalInfoResponse): unknown {
    const obj: any = {};
    if (message.removal !== undefined) {
      obj.removal = StakeRemovalInfo.toJSON(message.removal);
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeRemovalInfoResponse>): GetStakeRemovalInfoResponse {
    return GetStakeRemovalInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeRemovalInfoResponse>): GetStakeRemovalInfoResponse {
    const message = createBaseGetStakeRemovalInfoResponse();
    message.removal = (object.removal !== undefined && object.removal !== null)
      ? StakeRemovalInfo.fromPartial(object.removal)
      : undefined;
    return message;
  },
};

function createBaseGetDelegateStakeRemovalInfoRequest(): GetDelegateStakeRemovalInfoRequest {
  return { topicId: "0", delegator: "", reputer: "" };
}

export const GetDelegateStakeRemovalInfoRequest: MessageFns<GetDelegateStakeRemovalInfoRequest> = {
  encode(message: GetDelegateStakeRemovalInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.delegator !== "") {
      writer.uint32(18).string(message.delegator);
    }
    if (message.reputer !== "") {
      writer.uint32(26).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeRemovalInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeRemovalInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delegator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeRemovalInfoRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      delegator: isSet(object.delegator) ? globalThis.String(object.delegator) : "",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: GetDelegateStakeRemovalInfoRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.delegator !== "") {
      obj.delegator = message.delegator;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeRemovalInfoRequest>): GetDelegateStakeRemovalInfoRequest {
    return GetDelegateStakeRemovalInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakeRemovalInfoRequest>): GetDelegateStakeRemovalInfoRequest {
    const message = createBaseGetDelegateStakeRemovalInfoRequest();
    message.topicId = object.topicId ?? "0";
    message.delegator = object.delegator ?? "";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseGetDelegateStakeRemovalInfoResponse(): GetDelegateStakeRemovalInfoResponse {
  return { removal: undefined };
}

export const GetDelegateStakeRemovalInfoResponse: MessageFns<GetDelegateStakeRemovalInfoResponse> = {
  encode(message: GetDelegateStakeRemovalInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.removal !== undefined) {
      DelegateStakeRemovalInfo.encode(message.removal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeRemovalInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeRemovalInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.removal = DelegateStakeRemovalInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeRemovalInfoResponse {
    return { removal: isSet(object.removal) ? DelegateStakeRemovalInfo.fromJSON(object.removal) : undefined };
  },

  toJSON(message: GetDelegateStakeRemovalInfoResponse): unknown {
    const obj: any = {};
    if (message.removal !== undefined) {
      obj.removal = DelegateStakeRemovalInfo.toJSON(message.removal);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeRemovalInfoResponse>): GetDelegateStakeRemovalInfoResponse {
    return GetDelegateStakeRemovalInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakeRemovalInfoResponse>): GetDelegateStakeRemovalInfoResponse {
    const message = createBaseGetDelegateStakeRemovalInfoResponse();
    message.removal = (object.removal !== undefined && object.removal !== null)
      ? DelegateStakeRemovalInfo.fromPartial(object.removal)
      : undefined;
    return message;
  },
};

function createBaseGetTopicLastWorkerCommitInfoRequest(): GetTopicLastWorkerCommitInfoRequest {
  return { topicId: "0" };
}

export const GetTopicLastWorkerCommitInfoRequest: MessageFns<GetTopicLastWorkerCommitInfoRequest> = {
  encode(message: GetTopicLastWorkerCommitInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicLastWorkerCommitInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicLastWorkerCommitInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicLastWorkerCommitInfoRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetTopicLastWorkerCommitInfoRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicLastWorkerCommitInfoRequest>): GetTopicLastWorkerCommitInfoRequest {
    return GetTopicLastWorkerCommitInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicLastWorkerCommitInfoRequest>): GetTopicLastWorkerCommitInfoRequest {
    const message = createBaseGetTopicLastWorkerCommitInfoRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetTopicLastWorkerCommitInfoResponse(): GetTopicLastWorkerCommitInfoResponse {
  return { lastCommit: undefined };
}

export const GetTopicLastWorkerCommitInfoResponse: MessageFns<GetTopicLastWorkerCommitInfoResponse> = {
  encode(message: GetTopicLastWorkerCommitInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastCommit !== undefined) {
      TimestampedActorNonce.encode(message.lastCommit, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicLastWorkerCommitInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicLastWorkerCommitInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lastCommit = TimestampedActorNonce.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicLastWorkerCommitInfoResponse {
    return { lastCommit: isSet(object.lastCommit) ? TimestampedActorNonce.fromJSON(object.lastCommit) : undefined };
  },

  toJSON(message: GetTopicLastWorkerCommitInfoResponse): unknown {
    const obj: any = {};
    if (message.lastCommit !== undefined) {
      obj.lastCommit = TimestampedActorNonce.toJSON(message.lastCommit);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicLastWorkerCommitInfoResponse>): GetTopicLastWorkerCommitInfoResponse {
    return GetTopicLastWorkerCommitInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicLastWorkerCommitInfoResponse>): GetTopicLastWorkerCommitInfoResponse {
    const message = createBaseGetTopicLastWorkerCommitInfoResponse();
    message.lastCommit = (object.lastCommit !== undefined && object.lastCommit !== null)
      ? TimestampedActorNonce.fromPartial(object.lastCommit)
      : undefined;
    return message;
  },
};

function createBaseGetTopicLastReputerCommitInfoRequest(): GetTopicLastReputerCommitInfoRequest {
  return { topicId: "0" };
}

export const GetTopicLastReputerCommitInfoRequest: MessageFns<GetTopicLastReputerCommitInfoRequest> = {
  encode(message: GetTopicLastReputerCommitInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicLastReputerCommitInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicLastReputerCommitInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicLastReputerCommitInfoRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetTopicLastReputerCommitInfoRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicLastReputerCommitInfoRequest>): GetTopicLastReputerCommitInfoRequest {
    return GetTopicLastReputerCommitInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicLastReputerCommitInfoRequest>): GetTopicLastReputerCommitInfoRequest {
    const message = createBaseGetTopicLastReputerCommitInfoRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetTopicLastReputerCommitInfoResponse(): GetTopicLastReputerCommitInfoResponse {
  return { lastCommit: undefined };
}

export const GetTopicLastReputerCommitInfoResponse: MessageFns<GetTopicLastReputerCommitInfoResponse> = {
  encode(message: GetTopicLastReputerCommitInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastCommit !== undefined) {
      TimestampedActorNonce.encode(message.lastCommit, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicLastReputerCommitInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicLastReputerCommitInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lastCommit = TimestampedActorNonce.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicLastReputerCommitInfoResponse {
    return { lastCommit: isSet(object.lastCommit) ? TimestampedActorNonce.fromJSON(object.lastCommit) : undefined };
  },

  toJSON(message: GetTopicLastReputerCommitInfoResponse): unknown {
    const obj: any = {};
    if (message.lastCommit !== undefined) {
      obj.lastCommit = TimestampedActorNonce.toJSON(message.lastCommit);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicLastReputerCommitInfoResponse>): GetTopicLastReputerCommitInfoResponse {
    return GetTopicLastReputerCommitInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicLastReputerCommitInfoResponse>): GetTopicLastReputerCommitInfoResponse {
    const message = createBaseGetTopicLastReputerCommitInfoResponse();
    message.lastCommit = (object.lastCommit !== undefined && object.lastCommit !== null)
      ? TimestampedActorNonce.fromPartial(object.lastCommit)
      : undefined;
    return message;
  },
};

function createBaseGetTopicRewardNonceRequest(): GetTopicRewardNonceRequest {
  return { topicId: "0" };
}

export const GetTopicRewardNonceRequest: MessageFns<GetTopicRewardNonceRequest> = {
  encode(message: GetTopicRewardNonceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicRewardNonceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicRewardNonceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicRewardNonceRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetTopicRewardNonceRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicRewardNonceRequest>): GetTopicRewardNonceRequest {
    return GetTopicRewardNonceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicRewardNonceRequest>): GetTopicRewardNonceRequest {
    const message = createBaseGetTopicRewardNonceRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetTopicRewardNonceResponse(): GetTopicRewardNonceResponse {
  return { nonce: "0" };
}

export const GetTopicRewardNonceResponse: MessageFns<GetTopicRewardNonceResponse> = {
  encode(message: GetTopicRewardNonceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nonce !== "0") {
      writer.uint32(8).int64(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicRewardNonceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicRewardNonceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nonce = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicRewardNonceResponse {
    return { nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "0" };
  },

  toJSON(message: GetTopicRewardNonceResponse): unknown {
    const obj: any = {};
    if (message.nonce !== "0") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicRewardNonceResponse>): GetTopicRewardNonceResponse {
    return GetTopicRewardNonceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicRewardNonceResponse>): GetTopicRewardNonceResponse {
    const message = createBaseGetTopicRewardNonceResponse();
    message.nonce = object.nonce ?? "0";
    return message;
  },
};

function createBaseGetReputerLossBundlesAtBlockRequest(): GetReputerLossBundlesAtBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetReputerLossBundlesAtBlockRequest: MessageFns<GetReputerLossBundlesAtBlockRequest> = {
  encode(message: GetReputerLossBundlesAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputerLossBundlesAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputerLossBundlesAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputerLossBundlesAtBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetReputerLossBundlesAtBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputerLossBundlesAtBlockRequest>): GetReputerLossBundlesAtBlockRequest {
    return GetReputerLossBundlesAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputerLossBundlesAtBlockRequest>): GetReputerLossBundlesAtBlockRequest {
    const message = createBaseGetReputerLossBundlesAtBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetReputerLossBundlesAtBlockResponse(): GetReputerLossBundlesAtBlockResponse {
  return { lossBundles: undefined };
}

export const GetReputerLossBundlesAtBlockResponse: MessageFns<GetReputerLossBundlesAtBlockResponse> = {
  encode(message: GetReputerLossBundlesAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lossBundles !== undefined) {
      ReputerValueBundles.encode(message.lossBundles, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputerLossBundlesAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputerLossBundlesAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lossBundles = ReputerValueBundles.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputerLossBundlesAtBlockResponse {
    return { lossBundles: isSet(object.lossBundles) ? ReputerValueBundles.fromJSON(object.lossBundles) : undefined };
  },

  toJSON(message: GetReputerLossBundlesAtBlockResponse): unknown {
    const obj: any = {};
    if (message.lossBundles !== undefined) {
      obj.lossBundles = ReputerValueBundles.toJSON(message.lossBundles);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputerLossBundlesAtBlockResponse>): GetReputerLossBundlesAtBlockResponse {
    return GetReputerLossBundlesAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputerLossBundlesAtBlockResponse>): GetReputerLossBundlesAtBlockResponse {
    const message = createBaseGetReputerLossBundlesAtBlockResponse();
    message.lossBundles = (object.lossBundles !== undefined && object.lossBundles !== null)
      ? ReputerValueBundles.fromPartial(object.lossBundles)
      : undefined;
    return message;
  },
};

function createBaseGetStakeReputerAuthorityRequest(): GetStakeReputerAuthorityRequest {
  return { topicId: "0", reputer: "" };
}

export const GetStakeReputerAuthorityRequest: MessageFns<GetStakeReputerAuthorityRequest> = {
  encode(message: GetStakeReputerAuthorityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(18).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeReputerAuthorityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeReputerAuthorityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeReputerAuthorityRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: GetStakeReputerAuthorityRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeReputerAuthorityRequest>): GetStakeReputerAuthorityRequest {
    return GetStakeReputerAuthorityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeReputerAuthorityRequest>): GetStakeReputerAuthorityRequest {
    const message = createBaseGetStakeReputerAuthorityRequest();
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseGetStakeReputerAuthorityResponse(): GetStakeReputerAuthorityResponse {
  return { authority: "" };
}

export const GetStakeReputerAuthorityResponse: MessageFns<GetStakeReputerAuthorityResponse> = {
  encode(message: GetStakeReputerAuthorityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeReputerAuthorityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeReputerAuthorityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeReputerAuthorityResponse {
    return { authority: isSet(object.authority) ? globalThis.String(object.authority) : "" };
  },

  toJSON(message: GetStakeReputerAuthorityResponse): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeReputerAuthorityResponse>): GetStakeReputerAuthorityResponse {
    return GetStakeReputerAuthorityResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeReputerAuthorityResponse>): GetStakeReputerAuthorityResponse {
    const message = createBaseGetStakeReputerAuthorityResponse();
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseGetDelegateStakePlacementRequest(): GetDelegateStakePlacementRequest {
  return { topicId: "0", delegator: "", target: "" };
}

export const GetDelegateStakePlacementRequest: MessageFns<GetDelegateStakePlacementRequest> = {
  encode(message: GetDelegateStakePlacementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.delegator !== "") {
      writer.uint32(18).string(message.delegator);
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakePlacementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakePlacementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delegator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakePlacementRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      delegator: isSet(object.delegator) ? globalThis.String(object.delegator) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
    };
  },

  toJSON(message: GetDelegateStakePlacementRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.delegator !== "") {
      obj.delegator = message.delegator;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakePlacementRequest>): GetDelegateStakePlacementRequest {
    return GetDelegateStakePlacementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakePlacementRequest>): GetDelegateStakePlacementRequest {
    const message = createBaseGetDelegateStakePlacementRequest();
    message.topicId = object.topicId ?? "0";
    message.delegator = object.delegator ?? "";
    message.target = object.target ?? "";
    return message;
  },
};

function createBaseGetDelegateStakePlacementResponse(): GetDelegateStakePlacementResponse {
  return { delegatorInfo: undefined };
}

export const GetDelegateStakePlacementResponse: MessageFns<GetDelegateStakePlacementResponse> = {
  encode(message: GetDelegateStakePlacementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegatorInfo !== undefined) {
      DelegatorInfo.encode(message.delegatorInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakePlacementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakePlacementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegatorInfo = DelegatorInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakePlacementResponse {
    return { delegatorInfo: isSet(object.delegatorInfo) ? DelegatorInfo.fromJSON(object.delegatorInfo) : undefined };
  },

  toJSON(message: GetDelegateStakePlacementResponse): unknown {
    const obj: any = {};
    if (message.delegatorInfo !== undefined) {
      obj.delegatorInfo = DelegatorInfo.toJSON(message.delegatorInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakePlacementResponse>): GetDelegateStakePlacementResponse {
    return GetDelegateStakePlacementResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakePlacementResponse>): GetDelegateStakePlacementResponse {
    const message = createBaseGetDelegateStakePlacementResponse();
    message.delegatorInfo = (object.delegatorInfo !== undefined && object.delegatorInfo !== null)
      ? DelegatorInfo.fromPartial(object.delegatorInfo)
      : undefined;
    return message;
  },
};

function createBaseGetDelegateStakeUponReputerRequest(): GetDelegateStakeUponReputerRequest {
  return { topicId: "0", target: "" };
}

export const GetDelegateStakeUponReputerRequest: MessageFns<GetDelegateStakeUponReputerRequest> = {
  encode(message: GetDelegateStakeUponReputerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.target !== "") {
      writer.uint32(18).string(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeUponReputerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeUponReputerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeUponReputerRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
    };
  },

  toJSON(message: GetDelegateStakeUponReputerRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeUponReputerRequest>): GetDelegateStakeUponReputerRequest {
    return GetDelegateStakeUponReputerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakeUponReputerRequest>): GetDelegateStakeUponReputerRequest {
    const message = createBaseGetDelegateStakeUponReputerRequest();
    message.topicId = object.topicId ?? "0";
    message.target = object.target ?? "";
    return message;
  },
};

function createBaseGetDelegateStakeUponReputerResponse(): GetDelegateStakeUponReputerResponse {
  return { stake: "" };
}

export const GetDelegateStakeUponReputerResponse: MessageFns<GetDelegateStakeUponReputerResponse> = {
  encode(message: GetDelegateStakeUponReputerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stake !== "") {
      writer.uint32(10).string(message.stake);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeUponReputerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeUponReputerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stake = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeUponReputerResponse {
    return { stake: isSet(object.stake) ? globalThis.String(object.stake) : "" };
  },

  toJSON(message: GetDelegateStakeUponReputerResponse): unknown {
    const obj: any = {};
    if (message.stake !== "") {
      obj.stake = message.stake;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeUponReputerResponse>): GetDelegateStakeUponReputerResponse {
    return GetDelegateStakeUponReputerResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakeUponReputerResponse>): GetDelegateStakeUponReputerResponse {
    const message = createBaseGetDelegateStakeUponReputerResponse();
    message.stake = object.stake ?? "";
    return message;
  },
};

function createBaseGetDelegateRewardPerShareRequest(): GetDelegateRewardPerShareRequest {
  return { topicId: "0", reputer: "" };
}

export const GetDelegateRewardPerShareRequest: MessageFns<GetDelegateRewardPerShareRequest> = {
  encode(message: GetDelegateRewardPerShareRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(18).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateRewardPerShareRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateRewardPerShareRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateRewardPerShareRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: GetDelegateRewardPerShareRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateRewardPerShareRequest>): GetDelegateRewardPerShareRequest {
    return GetDelegateRewardPerShareRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateRewardPerShareRequest>): GetDelegateRewardPerShareRequest {
    const message = createBaseGetDelegateRewardPerShareRequest();
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseGetDelegateRewardPerShareResponse(): GetDelegateRewardPerShareResponse {
  return { rewardPerShare: "" };
}

export const GetDelegateRewardPerShareResponse: MessageFns<GetDelegateRewardPerShareResponse> = {
  encode(message: GetDelegateRewardPerShareResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rewardPerShare !== "") {
      writer.uint32(10).string(message.rewardPerShare);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateRewardPerShareResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateRewardPerShareResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewardPerShare = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateRewardPerShareResponse {
    return { rewardPerShare: isSet(object.rewardPerShare) ? globalThis.String(object.rewardPerShare) : "" };
  },

  toJSON(message: GetDelegateRewardPerShareResponse): unknown {
    const obj: any = {};
    if (message.rewardPerShare !== "") {
      obj.rewardPerShare = message.rewardPerShare;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateRewardPerShareResponse>): GetDelegateRewardPerShareResponse {
    return GetDelegateRewardPerShareResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateRewardPerShareResponse>): GetDelegateRewardPerShareResponse {
    const message = createBaseGetDelegateRewardPerShareResponse();
    message.rewardPerShare = object.rewardPerShare ?? "";
    return message;
  },
};

function createBaseGetStakeRemovalForReputerAndTopicIdRequest(): GetStakeRemovalForReputerAndTopicIdRequest {
  return { reputer: "", topicId: "0" };
}

export const GetStakeRemovalForReputerAndTopicIdRequest: MessageFns<GetStakeRemovalForReputerAndTopicIdRequest> = {
  encode(message: GetStakeRemovalForReputerAndTopicIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reputer !== "") {
      writer.uint32(10).string(message.reputer);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeRemovalForReputerAndTopicIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeRemovalForReputerAndTopicIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeRemovalForReputerAndTopicIdRequest {
    return {
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
    };
  },

  toJSON(message: GetStakeRemovalForReputerAndTopicIdRequest): unknown {
    const obj: any = {};
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeRemovalForReputerAndTopicIdRequest>): GetStakeRemovalForReputerAndTopicIdRequest {
    return GetStakeRemovalForReputerAndTopicIdRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetStakeRemovalForReputerAndTopicIdRequest>,
  ): GetStakeRemovalForReputerAndTopicIdRequest {
    const message = createBaseGetStakeRemovalForReputerAndTopicIdRequest();
    message.reputer = object.reputer ?? "";
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetStakeRemovalForReputerAndTopicIdResponse(): GetStakeRemovalForReputerAndTopicIdResponse {
  return { stakeRemovalInfo: undefined };
}

export const GetStakeRemovalForReputerAndTopicIdResponse: MessageFns<GetStakeRemovalForReputerAndTopicIdResponse> = {
  encode(
    message: GetStakeRemovalForReputerAndTopicIdResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stakeRemovalInfo !== undefined) {
      StakeRemovalInfo.encode(message.stakeRemovalInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStakeRemovalForReputerAndTopicIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeRemovalForReputerAndTopicIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stakeRemovalInfo = StakeRemovalInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeRemovalForReputerAndTopicIdResponse {
    return {
      stakeRemovalInfo: isSet(object.stakeRemovalInfo) ? StakeRemovalInfo.fromJSON(object.stakeRemovalInfo) : undefined,
    };
  },

  toJSON(message: GetStakeRemovalForReputerAndTopicIdResponse): unknown {
    const obj: any = {};
    if (message.stakeRemovalInfo !== undefined) {
      obj.stakeRemovalInfo = StakeRemovalInfo.toJSON(message.stakeRemovalInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeRemovalForReputerAndTopicIdResponse>): GetStakeRemovalForReputerAndTopicIdResponse {
    return GetStakeRemovalForReputerAndTopicIdResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetStakeRemovalForReputerAndTopicIdResponse>,
  ): GetStakeRemovalForReputerAndTopicIdResponse {
    const message = createBaseGetStakeRemovalForReputerAndTopicIdResponse();
    message.stakeRemovalInfo = (object.stakeRemovalInfo !== undefined && object.stakeRemovalInfo !== null)
      ? StakeRemovalInfo.fromPartial(object.stakeRemovalInfo)
      : undefined;
    return message;
  },
};

function createBaseGetDelegateStakeRemovalRequest(): GetDelegateStakeRemovalRequest {
  return { blockHeight: "0", topicId: "0", delegator: "", reputer: "" };
}

export const GetDelegateStakeRemovalRequest: MessageFns<GetDelegateStakeRemovalRequest> = {
  encode(message: GetDelegateStakeRemovalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHeight !== "0") {
      writer.uint32(8).int64(message.blockHeight);
    }
    if (message.topicId !== "0") {
      writer.uint32(16).uint64(message.topicId);
    }
    if (message.delegator !== "") {
      writer.uint32(26).string(message.delegator);
    }
    if (message.reputer !== "") {
      writer.uint32(34).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeRemovalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeRemovalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.delegator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeRemovalRequest {
    return {
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      delegator: isSet(object.delegator) ? globalThis.String(object.delegator) : "",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: GetDelegateStakeRemovalRequest): unknown {
    const obj: any = {};
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.delegator !== "") {
      obj.delegator = message.delegator;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeRemovalRequest>): GetDelegateStakeRemovalRequest {
    return GetDelegateStakeRemovalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakeRemovalRequest>): GetDelegateStakeRemovalRequest {
    const message = createBaseGetDelegateStakeRemovalRequest();
    message.blockHeight = object.blockHeight ?? "0";
    message.topicId = object.topicId ?? "0";
    message.delegator = object.delegator ?? "";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseGetDelegateStakeRemovalResponse(): GetDelegateStakeRemovalResponse {
  return { stakeRemovalInfo: undefined };
}

export const GetDelegateStakeRemovalResponse: MessageFns<GetDelegateStakeRemovalResponse> = {
  encode(message: GetDelegateStakeRemovalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stakeRemovalInfo !== undefined) {
      DelegateStakeRemovalInfo.encode(message.stakeRemovalInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDelegateStakeRemovalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDelegateStakeRemovalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stakeRemovalInfo = DelegateStakeRemovalInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDelegateStakeRemovalResponse {
    return {
      stakeRemovalInfo: isSet(object.stakeRemovalInfo)
        ? DelegateStakeRemovalInfo.fromJSON(object.stakeRemovalInfo)
        : undefined,
    };
  },

  toJSON(message: GetDelegateStakeRemovalResponse): unknown {
    const obj: any = {};
    if (message.stakeRemovalInfo !== undefined) {
      obj.stakeRemovalInfo = DelegateStakeRemovalInfo.toJSON(message.stakeRemovalInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDelegateStakeRemovalResponse>): GetDelegateStakeRemovalResponse {
    return GetDelegateStakeRemovalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDelegateStakeRemovalResponse>): GetDelegateStakeRemovalResponse {
    const message = createBaseGetDelegateStakeRemovalResponse();
    message.stakeRemovalInfo = (object.stakeRemovalInfo !== undefined && object.stakeRemovalInfo !== null)
      ? DelegateStakeRemovalInfo.fromPartial(object.stakeRemovalInfo)
      : undefined;
    return message;
  },
};

function createBaseGetPreviousTopicWeightRequest(): GetPreviousTopicWeightRequest {
  return { topicId: "0" };
}

export const GetPreviousTopicWeightRequest: MessageFns<GetPreviousTopicWeightRequest> = {
  encode(message: GetPreviousTopicWeightRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousTopicWeightRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousTopicWeightRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousTopicWeightRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetPreviousTopicWeightRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousTopicWeightRequest>): GetPreviousTopicWeightRequest {
    return GetPreviousTopicWeightRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPreviousTopicWeightRequest>): GetPreviousTopicWeightRequest {
    const message = createBaseGetPreviousTopicWeightRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetPreviousTopicWeightResponse(): GetPreviousTopicWeightResponse {
  return { weight: "", notFound: false };
}

export const GetPreviousTopicWeightResponse: MessageFns<GetPreviousTopicWeightResponse> = {
  encode(message: GetPreviousTopicWeightResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.weight !== "") {
      writer.uint32(10).string(message.weight);
    }
    if (message.notFound !== false) {
      writer.uint32(16).bool(message.notFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousTopicWeightResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousTopicWeightResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.weight = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.notFound = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousTopicWeightResponse {
    return {
      weight: isSet(object.weight) ? globalThis.String(object.weight) : "",
      notFound: isSet(object.notFound) ? globalThis.Boolean(object.notFound) : false,
    };
  },

  toJSON(message: GetPreviousTopicWeightResponse): unknown {
    const obj: any = {};
    if (message.weight !== "") {
      obj.weight = message.weight;
    }
    if (message.notFound !== false) {
      obj.notFound = message.notFound;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousTopicWeightResponse>): GetPreviousTopicWeightResponse {
    return GetPreviousTopicWeightResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPreviousTopicWeightResponse>): GetPreviousTopicWeightResponse {
    const message = createBaseGetPreviousTopicWeightResponse();
    message.weight = object.weight ?? "";
    message.notFound = object.notFound ?? false;
    return message;
  },
};

function createBaseGetTotalSumPreviousTopicWeightsRequest(): GetTotalSumPreviousTopicWeightsRequest {
  return {};
}

export const GetTotalSumPreviousTopicWeightsRequest: MessageFns<GetTotalSumPreviousTopicWeightsRequest> = {
  encode(_: GetTotalSumPreviousTopicWeightsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalSumPreviousTopicWeightsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalSumPreviousTopicWeightsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTotalSumPreviousTopicWeightsRequest {
    return {};
  },

  toJSON(_: GetTotalSumPreviousTopicWeightsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetTotalSumPreviousTopicWeightsRequest>): GetTotalSumPreviousTopicWeightsRequest {
    return GetTotalSumPreviousTopicWeightsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetTotalSumPreviousTopicWeightsRequest>): GetTotalSumPreviousTopicWeightsRequest {
    const message = createBaseGetTotalSumPreviousTopicWeightsRequest();
    return message;
  },
};

function createBaseGetTotalSumPreviousTopicWeightsResponse(): GetTotalSumPreviousTopicWeightsResponse {
  return { weight: "" };
}

export const GetTotalSumPreviousTopicWeightsResponse: MessageFns<GetTotalSumPreviousTopicWeightsResponse> = {
  encode(message: GetTotalSumPreviousTopicWeightsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.weight !== "") {
      writer.uint32(10).string(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalSumPreviousTopicWeightsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalSumPreviousTopicWeightsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.weight = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTotalSumPreviousTopicWeightsResponse {
    return { weight: isSet(object.weight) ? globalThis.String(object.weight) : "" };
  },

  toJSON(message: GetTotalSumPreviousTopicWeightsResponse): unknown {
    const obj: any = {};
    if (message.weight !== "") {
      obj.weight = message.weight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTotalSumPreviousTopicWeightsResponse>): GetTotalSumPreviousTopicWeightsResponse {
    return GetTotalSumPreviousTopicWeightsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTotalSumPreviousTopicWeightsResponse>): GetTotalSumPreviousTopicWeightsResponse {
    const message = createBaseGetTotalSumPreviousTopicWeightsResponse();
    message.weight = object.weight ?? "";
    return message;
  },
};

function createBaseTopicExistsRequest(): TopicExistsRequest {
  return { topicId: "0" };
}

export const TopicExistsRequest: MessageFns<TopicExistsRequest> = {
  encode(message: TopicExistsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicExistsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicExistsRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: TopicExistsRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicExistsRequest>): TopicExistsRequest {
    return TopicExistsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicExistsRequest>): TopicExistsRequest {
    const message = createBaseTopicExistsRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseTopicExistsResponse(): TopicExistsResponse {
  return { exists: false };
}

export const TopicExistsResponse: MessageFns<TopicExistsResponse> = {
  encode(message: TopicExistsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicExistsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicExistsResponse {
    return { exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false };
  },

  toJSON(message: TopicExistsResponse): unknown {
    const obj: any = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicExistsResponse>): TopicExistsResponse {
    return TopicExistsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicExistsResponse>): TopicExistsResponse {
    const message = createBaseTopicExistsResponse();
    message.exists = object.exists ?? false;
    return message;
  },
};

function createBaseIsTopicActiveRequest(): IsTopicActiveRequest {
  return { topicId: "0" };
}

export const IsTopicActiveRequest: MessageFns<IsTopicActiveRequest> = {
  encode(message: IsTopicActiveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsTopicActiveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsTopicActiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsTopicActiveRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: IsTopicActiveRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<IsTopicActiveRequest>): IsTopicActiveRequest {
    return IsTopicActiveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsTopicActiveRequest>): IsTopicActiveRequest {
    const message = createBaseIsTopicActiveRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseIsTopicActiveResponse(): IsTopicActiveResponse {
  return { isActive: false };
}

export const IsTopicActiveResponse: MessageFns<IsTopicActiveResponse> = {
  encode(message: IsTopicActiveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isActive !== false) {
      writer.uint32(8).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsTopicActiveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsTopicActiveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsTopicActiveResponse {
    return { isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false };
  },

  toJSON(message: IsTopicActiveResponse): unknown {
    const obj: any = {};
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create(base?: DeepPartial<IsTopicActiveResponse>): IsTopicActiveResponse {
    return IsTopicActiveResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IsTopicActiveResponse>): IsTopicActiveResponse {
    const message = createBaseIsTopicActiveResponse();
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseGetTopicFeeRevenueRequest(): GetTopicFeeRevenueRequest {
  return { topicId: "0" };
}

export const GetTopicFeeRevenueRequest: MessageFns<GetTopicFeeRevenueRequest> = {
  encode(message: GetTopicFeeRevenueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicFeeRevenueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicFeeRevenueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicFeeRevenueRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetTopicFeeRevenueRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicFeeRevenueRequest>): GetTopicFeeRevenueRequest {
    return GetTopicFeeRevenueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicFeeRevenueRequest>): GetTopicFeeRevenueRequest {
    const message = createBaseGetTopicFeeRevenueRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetTopicFeeRevenueResponse(): GetTopicFeeRevenueResponse {
  return { feeRevenue: "" };
}

export const GetTopicFeeRevenueResponse: MessageFns<GetTopicFeeRevenueResponse> = {
  encode(message: GetTopicFeeRevenueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.feeRevenue !== "") {
      writer.uint32(10).string(message.feeRevenue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicFeeRevenueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicFeeRevenueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feeRevenue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicFeeRevenueResponse {
    return { feeRevenue: isSet(object.feeRevenue) ? globalThis.String(object.feeRevenue) : "" };
  },

  toJSON(message: GetTopicFeeRevenueResponse): unknown {
    const obj: any = {};
    if (message.feeRevenue !== "") {
      obj.feeRevenue = message.feeRevenue;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicFeeRevenueResponse>): GetTopicFeeRevenueResponse {
    return GetTopicFeeRevenueResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicFeeRevenueResponse>): GetTopicFeeRevenueResponse {
    const message = createBaseGetTopicFeeRevenueResponse();
    message.feeRevenue = object.feeRevenue ?? "";
    return message;
  },
};

function createBaseGetInfererScoreEmaRequest(): GetInfererScoreEmaRequest {
  return { topicId: "0", inferer: "" };
}

export const GetInfererScoreEmaRequest: MessageFns<GetInfererScoreEmaRequest> = {
  encode(message: GetInfererScoreEmaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.inferer !== "") {
      writer.uint32(18).string(message.inferer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInfererScoreEmaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInfererScoreEmaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inferer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInfererScoreEmaRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      inferer: isSet(object.inferer) ? globalThis.String(object.inferer) : "",
    };
  },

  toJSON(message: GetInfererScoreEmaRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.inferer !== "") {
      obj.inferer = message.inferer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInfererScoreEmaRequest>): GetInfererScoreEmaRequest {
    return GetInfererScoreEmaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInfererScoreEmaRequest>): GetInfererScoreEmaRequest {
    const message = createBaseGetInfererScoreEmaRequest();
    message.topicId = object.topicId ?? "0";
    message.inferer = object.inferer ?? "";
    return message;
  },
};

function createBaseGetInfererScoreEmaResponse(): GetInfererScoreEmaResponse {
  return { score: undefined };
}

export const GetInfererScoreEmaResponse: MessageFns<GetInfererScoreEmaResponse> = {
  encode(message: GetInfererScoreEmaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInfererScoreEmaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInfererScoreEmaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInfererScoreEmaResponse {
    return { score: isSet(object.score) ? Score.fromJSON(object.score) : undefined };
  },

  toJSON(message: GetInfererScoreEmaResponse): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create(base?: DeepPartial<GetInfererScoreEmaResponse>): GetInfererScoreEmaResponse {
    return GetInfererScoreEmaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInfererScoreEmaResponse>): GetInfererScoreEmaResponse {
    const message = createBaseGetInfererScoreEmaResponse();
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseGetForecasterScoreEmaRequest(): GetForecasterScoreEmaRequest {
  return { topicId: "0", forecaster: "" };
}

export const GetForecasterScoreEmaRequest: MessageFns<GetForecasterScoreEmaRequest> = {
  encode(message: GetForecasterScoreEmaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.forecaster !== "") {
      writer.uint32(18).string(message.forecaster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetForecasterScoreEmaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetForecasterScoreEmaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.forecaster = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetForecasterScoreEmaRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      forecaster: isSet(object.forecaster) ? globalThis.String(object.forecaster) : "",
    };
  },

  toJSON(message: GetForecasterScoreEmaRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.forecaster !== "") {
      obj.forecaster = message.forecaster;
    }
    return obj;
  },

  create(base?: DeepPartial<GetForecasterScoreEmaRequest>): GetForecasterScoreEmaRequest {
    return GetForecasterScoreEmaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetForecasterScoreEmaRequest>): GetForecasterScoreEmaRequest {
    const message = createBaseGetForecasterScoreEmaRequest();
    message.topicId = object.topicId ?? "0";
    message.forecaster = object.forecaster ?? "";
    return message;
  },
};

function createBaseGetForecasterScoreEmaResponse(): GetForecasterScoreEmaResponse {
  return { score: undefined };
}

export const GetForecasterScoreEmaResponse: MessageFns<GetForecasterScoreEmaResponse> = {
  encode(message: GetForecasterScoreEmaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetForecasterScoreEmaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetForecasterScoreEmaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetForecasterScoreEmaResponse {
    return { score: isSet(object.score) ? Score.fromJSON(object.score) : undefined };
  },

  toJSON(message: GetForecasterScoreEmaResponse): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create(base?: DeepPartial<GetForecasterScoreEmaResponse>): GetForecasterScoreEmaResponse {
    return GetForecasterScoreEmaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetForecasterScoreEmaResponse>): GetForecasterScoreEmaResponse {
    const message = createBaseGetForecasterScoreEmaResponse();
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseGetReputerScoreEmaRequest(): GetReputerScoreEmaRequest {
  return { topicId: "0", reputer: "" };
}

export const GetReputerScoreEmaRequest: MessageFns<GetReputerScoreEmaRequest> = {
  encode(message: GetReputerScoreEmaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(18).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputerScoreEmaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputerScoreEmaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputerScoreEmaRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: GetReputerScoreEmaRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputerScoreEmaRequest>): GetReputerScoreEmaRequest {
    return GetReputerScoreEmaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputerScoreEmaRequest>): GetReputerScoreEmaRequest {
    const message = createBaseGetReputerScoreEmaRequest();
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseGetReputerScoreEmaResponse(): GetReputerScoreEmaResponse {
  return { score: undefined };
}

export const GetReputerScoreEmaResponse: MessageFns<GetReputerScoreEmaResponse> = {
  encode(message: GetReputerScoreEmaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputerScoreEmaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputerScoreEmaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputerScoreEmaResponse {
    return { score: isSet(object.score) ? Score.fromJSON(object.score) : undefined };
  },

  toJSON(message: GetReputerScoreEmaResponse): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputerScoreEmaResponse>): GetReputerScoreEmaResponse {
    return GetReputerScoreEmaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputerScoreEmaResponse>): GetReputerScoreEmaResponse {
    const message = createBaseGetReputerScoreEmaResponse();
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseGetInferenceScoresUntilBlockRequest(): GetInferenceScoresUntilBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetInferenceScoresUntilBlockRequest: MessageFns<GetInferenceScoresUntilBlockRequest> = {
  encode(message: GetInferenceScoresUntilBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInferenceScoresUntilBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInferenceScoresUntilBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInferenceScoresUntilBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetInferenceScoresUntilBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInferenceScoresUntilBlockRequest>): GetInferenceScoresUntilBlockRequest {
    return GetInferenceScoresUntilBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInferenceScoresUntilBlockRequest>): GetInferenceScoresUntilBlockRequest {
    const message = createBaseGetInferenceScoresUntilBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetInferenceScoresUntilBlockResponse(): GetInferenceScoresUntilBlockResponse {
  return { scores: [] };
}

export const GetInferenceScoresUntilBlockResponse: MessageFns<GetInferenceScoresUntilBlockResponse> = {
  encode(message: GetInferenceScoresUntilBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.scores) {
      Score.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInferenceScoresUntilBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInferenceScoresUntilBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scores.push(Score.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInferenceScoresUntilBlockResponse {
    return { scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => Score.fromJSON(e)) : [] };
  },

  toJSON(message: GetInferenceScoresUntilBlockResponse): unknown {
    const obj: any = {};
    if (message.scores?.length) {
      obj.scores = message.scores.map((e) => Score.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetInferenceScoresUntilBlockResponse>): GetInferenceScoresUntilBlockResponse {
    return GetInferenceScoresUntilBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInferenceScoresUntilBlockResponse>): GetInferenceScoresUntilBlockResponse {
    const message = createBaseGetInferenceScoresUntilBlockResponse();
    message.scores = object.scores?.map((e) => Score.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPreviousTopicQuantileForecasterScoreEmaRequest(): GetPreviousTopicQuantileForecasterScoreEmaRequest {
  return { topicId: "0" };
}

export const GetPreviousTopicQuantileForecasterScoreEmaRequest: MessageFns<
  GetPreviousTopicQuantileForecasterScoreEmaRequest
> = {
  encode(
    message: GetPreviousTopicQuantileForecasterScoreEmaRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousTopicQuantileForecasterScoreEmaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousTopicQuantileForecasterScoreEmaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousTopicQuantileForecasterScoreEmaRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetPreviousTopicQuantileForecasterScoreEmaRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetPreviousTopicQuantileForecasterScoreEmaRequest>,
  ): GetPreviousTopicQuantileForecasterScoreEmaRequest {
    return GetPreviousTopicQuantileForecasterScoreEmaRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousTopicQuantileForecasterScoreEmaRequest>,
  ): GetPreviousTopicQuantileForecasterScoreEmaRequest {
    const message = createBaseGetPreviousTopicQuantileForecasterScoreEmaRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetPreviousTopicQuantileForecasterScoreEmaResponse(): GetPreviousTopicQuantileForecasterScoreEmaResponse {
  return { value: "" };
}

export const GetPreviousTopicQuantileForecasterScoreEmaResponse: MessageFns<
  GetPreviousTopicQuantileForecasterScoreEmaResponse
> = {
  encode(
    message: GetPreviousTopicQuantileForecasterScoreEmaResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousTopicQuantileForecasterScoreEmaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousTopicQuantileForecasterScoreEmaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousTopicQuantileForecasterScoreEmaResponse {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: GetPreviousTopicQuantileForecasterScoreEmaResponse): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetPreviousTopicQuantileForecasterScoreEmaResponse>,
  ): GetPreviousTopicQuantileForecasterScoreEmaResponse {
    return GetPreviousTopicQuantileForecasterScoreEmaResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousTopicQuantileForecasterScoreEmaResponse>,
  ): GetPreviousTopicQuantileForecasterScoreEmaResponse {
    const message = createBaseGetPreviousTopicQuantileForecasterScoreEmaResponse();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetPreviousTopicQuantileInfererScoreEmaRequest(): GetPreviousTopicQuantileInfererScoreEmaRequest {
  return { topicId: "0" };
}

export const GetPreviousTopicQuantileInfererScoreEmaRequest: MessageFns<
  GetPreviousTopicQuantileInfererScoreEmaRequest
> = {
  encode(
    message: GetPreviousTopicQuantileInfererScoreEmaRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousTopicQuantileInfererScoreEmaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousTopicQuantileInfererScoreEmaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousTopicQuantileInfererScoreEmaRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetPreviousTopicQuantileInfererScoreEmaRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetPreviousTopicQuantileInfererScoreEmaRequest>,
  ): GetPreviousTopicQuantileInfererScoreEmaRequest {
    return GetPreviousTopicQuantileInfererScoreEmaRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousTopicQuantileInfererScoreEmaRequest>,
  ): GetPreviousTopicQuantileInfererScoreEmaRequest {
    const message = createBaseGetPreviousTopicQuantileInfererScoreEmaRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetPreviousTopicQuantileInfererScoreEmaResponse(): GetPreviousTopicQuantileInfererScoreEmaResponse {
  return { value: "" };
}

export const GetPreviousTopicQuantileInfererScoreEmaResponse: MessageFns<
  GetPreviousTopicQuantileInfererScoreEmaResponse
> = {
  encode(
    message: GetPreviousTopicQuantileInfererScoreEmaResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousTopicQuantileInfererScoreEmaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousTopicQuantileInfererScoreEmaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousTopicQuantileInfererScoreEmaResponse {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: GetPreviousTopicQuantileInfererScoreEmaResponse): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetPreviousTopicQuantileInfererScoreEmaResponse>,
  ): GetPreviousTopicQuantileInfererScoreEmaResponse {
    return GetPreviousTopicQuantileInfererScoreEmaResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousTopicQuantileInfererScoreEmaResponse>,
  ): GetPreviousTopicQuantileInfererScoreEmaResponse {
    const message = createBaseGetPreviousTopicQuantileInfererScoreEmaResponse();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetPreviousTopicQuantileReputerScoreEmaRequest(): GetPreviousTopicQuantileReputerScoreEmaRequest {
  return { topicId: "0" };
}

export const GetPreviousTopicQuantileReputerScoreEmaRequest: MessageFns<
  GetPreviousTopicQuantileReputerScoreEmaRequest
> = {
  encode(
    message: GetPreviousTopicQuantileReputerScoreEmaRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousTopicQuantileReputerScoreEmaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousTopicQuantileReputerScoreEmaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousTopicQuantileReputerScoreEmaRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetPreviousTopicQuantileReputerScoreEmaRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetPreviousTopicQuantileReputerScoreEmaRequest>,
  ): GetPreviousTopicQuantileReputerScoreEmaRequest {
    return GetPreviousTopicQuantileReputerScoreEmaRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousTopicQuantileReputerScoreEmaRequest>,
  ): GetPreviousTopicQuantileReputerScoreEmaRequest {
    const message = createBaseGetPreviousTopicQuantileReputerScoreEmaRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetPreviousTopicQuantileReputerScoreEmaResponse(): GetPreviousTopicQuantileReputerScoreEmaResponse {
  return { value: "" };
}

export const GetPreviousTopicQuantileReputerScoreEmaResponse: MessageFns<
  GetPreviousTopicQuantileReputerScoreEmaResponse
> = {
  encode(
    message: GetPreviousTopicQuantileReputerScoreEmaResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousTopicQuantileReputerScoreEmaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousTopicQuantileReputerScoreEmaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousTopicQuantileReputerScoreEmaResponse {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: GetPreviousTopicQuantileReputerScoreEmaResponse): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetPreviousTopicQuantileReputerScoreEmaResponse>,
  ): GetPreviousTopicQuantileReputerScoreEmaResponse {
    return GetPreviousTopicQuantileReputerScoreEmaResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousTopicQuantileReputerScoreEmaResponse>,
  ): GetPreviousTopicQuantileReputerScoreEmaResponse {
    const message = createBaseGetPreviousTopicQuantileReputerScoreEmaResponse();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetWorkerInferenceScoresAtBlockRequest(): GetWorkerInferenceScoresAtBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetWorkerInferenceScoresAtBlockRequest: MessageFns<GetWorkerInferenceScoresAtBlockRequest> = {
  encode(message: GetWorkerInferenceScoresAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerInferenceScoresAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerInferenceScoresAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerInferenceScoresAtBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetWorkerInferenceScoresAtBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkerInferenceScoresAtBlockRequest>): GetWorkerInferenceScoresAtBlockRequest {
    return GetWorkerInferenceScoresAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkerInferenceScoresAtBlockRequest>): GetWorkerInferenceScoresAtBlockRequest {
    const message = createBaseGetWorkerInferenceScoresAtBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetWorkerInferenceScoresAtBlockResponse(): GetWorkerInferenceScoresAtBlockResponse {
  return { scores: undefined };
}

export const GetWorkerInferenceScoresAtBlockResponse: MessageFns<GetWorkerInferenceScoresAtBlockResponse> = {
  encode(message: GetWorkerInferenceScoresAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scores !== undefined) {
      Scores.encode(message.scores, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerInferenceScoresAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerInferenceScoresAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scores = Scores.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerInferenceScoresAtBlockResponse {
    return { scores: isSet(object.scores) ? Scores.fromJSON(object.scores) : undefined };
  },

  toJSON(message: GetWorkerInferenceScoresAtBlockResponse): unknown {
    const obj: any = {};
    if (message.scores !== undefined) {
      obj.scores = Scores.toJSON(message.scores);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkerInferenceScoresAtBlockResponse>): GetWorkerInferenceScoresAtBlockResponse {
    return GetWorkerInferenceScoresAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkerInferenceScoresAtBlockResponse>): GetWorkerInferenceScoresAtBlockResponse {
    const message = createBaseGetWorkerInferenceScoresAtBlockResponse();
    message.scores = (object.scores !== undefined && object.scores !== null)
      ? Scores.fromPartial(object.scores)
      : undefined;
    return message;
  },
};

function createBaseGetCurrentLowestInfererScoreRequest(): GetCurrentLowestInfererScoreRequest {
  return { topicId: "0" };
}

export const GetCurrentLowestInfererScoreRequest: MessageFns<GetCurrentLowestInfererScoreRequest> = {
  encode(message: GetCurrentLowestInfererScoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentLowestInfererScoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentLowestInfererScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentLowestInfererScoreRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetCurrentLowestInfererScoreRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrentLowestInfererScoreRequest>): GetCurrentLowestInfererScoreRequest {
    return GetCurrentLowestInfererScoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentLowestInfererScoreRequest>): GetCurrentLowestInfererScoreRequest {
    const message = createBaseGetCurrentLowestInfererScoreRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetCurrentLowestInfererScoreResponse(): GetCurrentLowestInfererScoreResponse {
  return { score: undefined };
}

export const GetCurrentLowestInfererScoreResponse: MessageFns<GetCurrentLowestInfererScoreResponse> = {
  encode(message: GetCurrentLowestInfererScoreResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentLowestInfererScoreResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentLowestInfererScoreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentLowestInfererScoreResponse {
    return { score: isSet(object.score) ? Score.fromJSON(object.score) : undefined };
  },

  toJSON(message: GetCurrentLowestInfererScoreResponse): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrentLowestInfererScoreResponse>): GetCurrentLowestInfererScoreResponse {
    return GetCurrentLowestInfererScoreResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentLowestInfererScoreResponse>): GetCurrentLowestInfererScoreResponse {
    const message = createBaseGetCurrentLowestInfererScoreResponse();
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseGetForecastScoresUntilBlockRequest(): GetForecastScoresUntilBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetForecastScoresUntilBlockRequest: MessageFns<GetForecastScoresUntilBlockRequest> = {
  encode(message: GetForecastScoresUntilBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetForecastScoresUntilBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetForecastScoresUntilBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetForecastScoresUntilBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetForecastScoresUntilBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetForecastScoresUntilBlockRequest>): GetForecastScoresUntilBlockRequest {
    return GetForecastScoresUntilBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetForecastScoresUntilBlockRequest>): GetForecastScoresUntilBlockRequest {
    const message = createBaseGetForecastScoresUntilBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetForecastScoresUntilBlockResponse(): GetForecastScoresUntilBlockResponse {
  return { scores: [] };
}

export const GetForecastScoresUntilBlockResponse: MessageFns<GetForecastScoresUntilBlockResponse> = {
  encode(message: GetForecastScoresUntilBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.scores) {
      Score.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetForecastScoresUntilBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetForecastScoresUntilBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scores.push(Score.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetForecastScoresUntilBlockResponse {
    return { scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => Score.fromJSON(e)) : [] };
  },

  toJSON(message: GetForecastScoresUntilBlockResponse): unknown {
    const obj: any = {};
    if (message.scores?.length) {
      obj.scores = message.scores.map((e) => Score.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetForecastScoresUntilBlockResponse>): GetForecastScoresUntilBlockResponse {
    return GetForecastScoresUntilBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetForecastScoresUntilBlockResponse>): GetForecastScoresUntilBlockResponse {
    const message = createBaseGetForecastScoresUntilBlockResponse();
    message.scores = object.scores?.map((e) => Score.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetWorkerForecastScoresAtBlockRequest(): GetWorkerForecastScoresAtBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetWorkerForecastScoresAtBlockRequest: MessageFns<GetWorkerForecastScoresAtBlockRequest> = {
  encode(message: GetWorkerForecastScoresAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerForecastScoresAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerForecastScoresAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerForecastScoresAtBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetWorkerForecastScoresAtBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkerForecastScoresAtBlockRequest>): GetWorkerForecastScoresAtBlockRequest {
    return GetWorkerForecastScoresAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkerForecastScoresAtBlockRequest>): GetWorkerForecastScoresAtBlockRequest {
    const message = createBaseGetWorkerForecastScoresAtBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetWorkerForecastScoresAtBlockResponse(): GetWorkerForecastScoresAtBlockResponse {
  return { scores: undefined };
}

export const GetWorkerForecastScoresAtBlockResponse: MessageFns<GetWorkerForecastScoresAtBlockResponse> = {
  encode(message: GetWorkerForecastScoresAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scores !== undefined) {
      Scores.encode(message.scores, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkerForecastScoresAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkerForecastScoresAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scores = Scores.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkerForecastScoresAtBlockResponse {
    return { scores: isSet(object.scores) ? Scores.fromJSON(object.scores) : undefined };
  },

  toJSON(message: GetWorkerForecastScoresAtBlockResponse): unknown {
    const obj: any = {};
    if (message.scores !== undefined) {
      obj.scores = Scores.toJSON(message.scores);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkerForecastScoresAtBlockResponse>): GetWorkerForecastScoresAtBlockResponse {
    return GetWorkerForecastScoresAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkerForecastScoresAtBlockResponse>): GetWorkerForecastScoresAtBlockResponse {
    const message = createBaseGetWorkerForecastScoresAtBlockResponse();
    message.scores = (object.scores !== undefined && object.scores !== null)
      ? Scores.fromPartial(object.scores)
      : undefined;
    return message;
  },
};

function createBaseGetCurrentLowestForecasterScoreRequest(): GetCurrentLowestForecasterScoreRequest {
  return { topicId: "0" };
}

export const GetCurrentLowestForecasterScoreRequest: MessageFns<GetCurrentLowestForecasterScoreRequest> = {
  encode(message: GetCurrentLowestForecasterScoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentLowestForecasterScoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentLowestForecasterScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentLowestForecasterScoreRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetCurrentLowestForecasterScoreRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrentLowestForecasterScoreRequest>): GetCurrentLowestForecasterScoreRequest {
    return GetCurrentLowestForecasterScoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentLowestForecasterScoreRequest>): GetCurrentLowestForecasterScoreRequest {
    const message = createBaseGetCurrentLowestForecasterScoreRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetCurrentLowestForecasterScoreResponse(): GetCurrentLowestForecasterScoreResponse {
  return { score: undefined };
}

export const GetCurrentLowestForecasterScoreResponse: MessageFns<GetCurrentLowestForecasterScoreResponse> = {
  encode(message: GetCurrentLowestForecasterScoreResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentLowestForecasterScoreResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentLowestForecasterScoreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentLowestForecasterScoreResponse {
    return { score: isSet(object.score) ? Score.fromJSON(object.score) : undefined };
  },

  toJSON(message: GetCurrentLowestForecasterScoreResponse): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrentLowestForecasterScoreResponse>): GetCurrentLowestForecasterScoreResponse {
    return GetCurrentLowestForecasterScoreResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentLowestForecasterScoreResponse>): GetCurrentLowestForecasterScoreResponse {
    const message = createBaseGetCurrentLowestForecasterScoreResponse();
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseGetReputersScoresAtBlockRequest(): GetReputersScoresAtBlockRequest {
  return { topicId: "0", blockHeight: "0" };
}

export const GetReputersScoresAtBlockRequest: MessageFns<GetReputersScoresAtBlockRequest> = {
  encode(message: GetReputersScoresAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.blockHeight !== "0") {
      writer.uint32(16).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputersScoresAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputersScoresAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputersScoresAtBlockRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
    };
  },

  toJSON(message: GetReputersScoresAtBlockRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputersScoresAtBlockRequest>): GetReputersScoresAtBlockRequest {
    return GetReputersScoresAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputersScoresAtBlockRequest>): GetReputersScoresAtBlockRequest {
    const message = createBaseGetReputersScoresAtBlockRequest();
    message.topicId = object.topicId ?? "0";
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetReputersScoresAtBlockResponse(): GetReputersScoresAtBlockResponse {
  return { scores: undefined };
}

export const GetReputersScoresAtBlockResponse: MessageFns<GetReputersScoresAtBlockResponse> = {
  encode(message: GetReputersScoresAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scores !== undefined) {
      Scores.encode(message.scores, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReputersScoresAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReputersScoresAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scores = Scores.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReputersScoresAtBlockResponse {
    return { scores: isSet(object.scores) ? Scores.fromJSON(object.scores) : undefined };
  },

  toJSON(message: GetReputersScoresAtBlockResponse): unknown {
    const obj: any = {};
    if (message.scores !== undefined) {
      obj.scores = Scores.toJSON(message.scores);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReputersScoresAtBlockResponse>): GetReputersScoresAtBlockResponse {
    return GetReputersScoresAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReputersScoresAtBlockResponse>): GetReputersScoresAtBlockResponse {
    const message = createBaseGetReputersScoresAtBlockResponse();
    message.scores = (object.scores !== undefined && object.scores !== null)
      ? Scores.fromPartial(object.scores)
      : undefined;
    return message;
  },
};

function createBaseGetCurrentLowestReputerScoreRequest(): GetCurrentLowestReputerScoreRequest {
  return { topicId: "0" };
}

export const GetCurrentLowestReputerScoreRequest: MessageFns<GetCurrentLowestReputerScoreRequest> = {
  encode(message: GetCurrentLowestReputerScoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentLowestReputerScoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentLowestReputerScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentLowestReputerScoreRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetCurrentLowestReputerScoreRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrentLowestReputerScoreRequest>): GetCurrentLowestReputerScoreRequest {
    return GetCurrentLowestReputerScoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentLowestReputerScoreRequest>): GetCurrentLowestReputerScoreRequest {
    const message = createBaseGetCurrentLowestReputerScoreRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetCurrentLowestReputerScoreResponse(): GetCurrentLowestReputerScoreResponse {
  return { score: undefined };
}

export const GetCurrentLowestReputerScoreResponse: MessageFns<GetCurrentLowestReputerScoreResponse> = {
  encode(message: GetCurrentLowestReputerScoreResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentLowestReputerScoreResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentLowestReputerScoreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentLowestReputerScoreResponse {
    return { score: isSet(object.score) ? Score.fromJSON(object.score) : undefined };
  },

  toJSON(message: GetCurrentLowestReputerScoreResponse): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrentLowestReputerScoreResponse>): GetCurrentLowestReputerScoreResponse {
    return GetCurrentLowestReputerScoreResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrentLowestReputerScoreResponse>): GetCurrentLowestReputerScoreResponse {
    const message = createBaseGetCurrentLowestReputerScoreResponse();
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseGetListeningCoefficientRequest(): GetListeningCoefficientRequest {
  return { topicId: "0", reputer: "" };
}

export const GetListeningCoefficientRequest: MessageFns<GetListeningCoefficientRequest> = {
  encode(message: GetListeningCoefficientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(18).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetListeningCoefficientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetListeningCoefficientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetListeningCoefficientRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: GetListeningCoefficientRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetListeningCoefficientRequest>): GetListeningCoefficientRequest {
    return GetListeningCoefficientRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetListeningCoefficientRequest>): GetListeningCoefficientRequest {
    const message = createBaseGetListeningCoefficientRequest();
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseGetListeningCoefficientResponse(): GetListeningCoefficientResponse {
  return { listeningCoefficient: undefined };
}

export const GetListeningCoefficientResponse: MessageFns<GetListeningCoefficientResponse> = {
  encode(message: GetListeningCoefficientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listeningCoefficient !== undefined) {
      ListeningCoefficient.encode(message.listeningCoefficient, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetListeningCoefficientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetListeningCoefficientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.listeningCoefficient = ListeningCoefficient.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetListeningCoefficientResponse {
    return {
      listeningCoefficient: isSet(object.listeningCoefficient)
        ? ListeningCoefficient.fromJSON(object.listeningCoefficient)
        : undefined,
    };
  },

  toJSON(message: GetListeningCoefficientResponse): unknown {
    const obj: any = {};
    if (message.listeningCoefficient !== undefined) {
      obj.listeningCoefficient = ListeningCoefficient.toJSON(message.listeningCoefficient);
    }
    return obj;
  },

  create(base?: DeepPartial<GetListeningCoefficientResponse>): GetListeningCoefficientResponse {
    return GetListeningCoefficientResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetListeningCoefficientResponse>): GetListeningCoefficientResponse {
    const message = createBaseGetListeningCoefficientResponse();
    message.listeningCoefficient = (object.listeningCoefficient !== undefined && object.listeningCoefficient !== null)
      ? ListeningCoefficient.fromPartial(object.listeningCoefficient)
      : undefined;
    return message;
  },
};

function createBaseGetPreviousReputerRewardFractionRequest(): GetPreviousReputerRewardFractionRequest {
  return { topicId: "0", reputer: "" };
}

export const GetPreviousReputerRewardFractionRequest: MessageFns<GetPreviousReputerRewardFractionRequest> = {
  encode(message: GetPreviousReputerRewardFractionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.reputer !== "") {
      writer.uint32(18).string(message.reputer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousReputerRewardFractionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousReputerRewardFractionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reputer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousReputerRewardFractionRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      reputer: isSet(object.reputer) ? globalThis.String(object.reputer) : "",
    };
  },

  toJSON(message: GetPreviousReputerRewardFractionRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.reputer !== "") {
      obj.reputer = message.reputer;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousReputerRewardFractionRequest>): GetPreviousReputerRewardFractionRequest {
    return GetPreviousReputerRewardFractionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPreviousReputerRewardFractionRequest>): GetPreviousReputerRewardFractionRequest {
    const message = createBaseGetPreviousReputerRewardFractionRequest();
    message.topicId = object.topicId ?? "0";
    message.reputer = object.reputer ?? "";
    return message;
  },
};

function createBaseGetPreviousReputerRewardFractionResponse(): GetPreviousReputerRewardFractionResponse {
  return { rewardFraction: "", notFound: false };
}

export const GetPreviousReputerRewardFractionResponse: MessageFns<GetPreviousReputerRewardFractionResponse> = {
  encode(message: GetPreviousReputerRewardFractionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rewardFraction !== "") {
      writer.uint32(10).string(message.rewardFraction);
    }
    if (message.notFound !== false) {
      writer.uint32(16).bool(message.notFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousReputerRewardFractionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousReputerRewardFractionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewardFraction = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.notFound = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousReputerRewardFractionResponse {
    return {
      rewardFraction: isSet(object.rewardFraction) ? globalThis.String(object.rewardFraction) : "",
      notFound: isSet(object.notFound) ? globalThis.Boolean(object.notFound) : false,
    };
  },

  toJSON(message: GetPreviousReputerRewardFractionResponse): unknown {
    const obj: any = {};
    if (message.rewardFraction !== "") {
      obj.rewardFraction = message.rewardFraction;
    }
    if (message.notFound !== false) {
      obj.notFound = message.notFound;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousReputerRewardFractionResponse>): GetPreviousReputerRewardFractionResponse {
    return GetPreviousReputerRewardFractionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPreviousReputerRewardFractionResponse>): GetPreviousReputerRewardFractionResponse {
    const message = createBaseGetPreviousReputerRewardFractionResponse();
    message.rewardFraction = object.rewardFraction ?? "";
    message.notFound = object.notFound ?? false;
    return message;
  },
};

function createBaseGetPreviousInferenceRewardFractionRequest(): GetPreviousInferenceRewardFractionRequest {
  return { topicId: "0", worker: "" };
}

export const GetPreviousInferenceRewardFractionRequest: MessageFns<GetPreviousInferenceRewardFractionRequest> = {
  encode(message: GetPreviousInferenceRewardFractionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.worker !== "") {
      writer.uint32(18).string(message.worker);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousInferenceRewardFractionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousInferenceRewardFractionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.worker = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousInferenceRewardFractionRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      worker: isSet(object.worker) ? globalThis.String(object.worker) : "",
    };
  },

  toJSON(message: GetPreviousInferenceRewardFractionRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.worker !== "") {
      obj.worker = message.worker;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousInferenceRewardFractionRequest>): GetPreviousInferenceRewardFractionRequest {
    return GetPreviousInferenceRewardFractionRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousInferenceRewardFractionRequest>,
  ): GetPreviousInferenceRewardFractionRequest {
    const message = createBaseGetPreviousInferenceRewardFractionRequest();
    message.topicId = object.topicId ?? "0";
    message.worker = object.worker ?? "";
    return message;
  },
};

function createBaseGetPreviousInferenceRewardFractionResponse(): GetPreviousInferenceRewardFractionResponse {
  return { rewardFraction: "", notFound: false };
}

export const GetPreviousInferenceRewardFractionResponse: MessageFns<GetPreviousInferenceRewardFractionResponse> = {
  encode(message: GetPreviousInferenceRewardFractionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rewardFraction !== "") {
      writer.uint32(10).string(message.rewardFraction);
    }
    if (message.notFound !== false) {
      writer.uint32(16).bool(message.notFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousInferenceRewardFractionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousInferenceRewardFractionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewardFraction = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.notFound = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousInferenceRewardFractionResponse {
    return {
      rewardFraction: isSet(object.rewardFraction) ? globalThis.String(object.rewardFraction) : "",
      notFound: isSet(object.notFound) ? globalThis.Boolean(object.notFound) : false,
    };
  },

  toJSON(message: GetPreviousInferenceRewardFractionResponse): unknown {
    const obj: any = {};
    if (message.rewardFraction !== "") {
      obj.rewardFraction = message.rewardFraction;
    }
    if (message.notFound !== false) {
      obj.notFound = message.notFound;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousInferenceRewardFractionResponse>): GetPreviousInferenceRewardFractionResponse {
    return GetPreviousInferenceRewardFractionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousInferenceRewardFractionResponse>,
  ): GetPreviousInferenceRewardFractionResponse {
    const message = createBaseGetPreviousInferenceRewardFractionResponse();
    message.rewardFraction = object.rewardFraction ?? "";
    message.notFound = object.notFound ?? false;
    return message;
  },
};

function createBaseGetPreviousForecastRewardFractionRequest(): GetPreviousForecastRewardFractionRequest {
  return { topicId: "0", worker: "" };
}

export const GetPreviousForecastRewardFractionRequest: MessageFns<GetPreviousForecastRewardFractionRequest> = {
  encode(message: GetPreviousForecastRewardFractionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    if (message.worker !== "") {
      writer.uint32(18).string(message.worker);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousForecastRewardFractionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousForecastRewardFractionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.worker = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousForecastRewardFractionRequest {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0",
      worker: isSet(object.worker) ? globalThis.String(object.worker) : "",
    };
  },

  toJSON(message: GetPreviousForecastRewardFractionRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    if (message.worker !== "") {
      obj.worker = message.worker;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousForecastRewardFractionRequest>): GetPreviousForecastRewardFractionRequest {
    return GetPreviousForecastRewardFractionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPreviousForecastRewardFractionRequest>): GetPreviousForecastRewardFractionRequest {
    const message = createBaseGetPreviousForecastRewardFractionRequest();
    message.topicId = object.topicId ?? "0";
    message.worker = object.worker ?? "";
    return message;
  },
};

function createBaseGetPreviousForecastRewardFractionResponse(): GetPreviousForecastRewardFractionResponse {
  return { rewardFraction: "", notFound: false };
}

export const GetPreviousForecastRewardFractionResponse: MessageFns<GetPreviousForecastRewardFractionResponse> = {
  encode(message: GetPreviousForecastRewardFractionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rewardFraction !== "") {
      writer.uint32(10).string(message.rewardFraction);
    }
    if (message.notFound !== false) {
      writer.uint32(16).bool(message.notFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousForecastRewardFractionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousForecastRewardFractionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewardFraction = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.notFound = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousForecastRewardFractionResponse {
    return {
      rewardFraction: isSet(object.rewardFraction) ? globalThis.String(object.rewardFraction) : "",
      notFound: isSet(object.notFound) ? globalThis.Boolean(object.notFound) : false,
    };
  },

  toJSON(message: GetPreviousForecastRewardFractionResponse): unknown {
    const obj: any = {};
    if (message.rewardFraction !== "") {
      obj.rewardFraction = message.rewardFraction;
    }
    if (message.notFound !== false) {
      obj.notFound = message.notFound;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreviousForecastRewardFractionResponse>): GetPreviousForecastRewardFractionResponse {
    return GetPreviousForecastRewardFractionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousForecastRewardFractionResponse>,
  ): GetPreviousForecastRewardFractionResponse {
    const message = createBaseGetPreviousForecastRewardFractionResponse();
    message.rewardFraction = object.rewardFraction ?? "";
    message.notFound = object.notFound ?? false;
    return message;
  },
};

function createBaseGetPreviousPercentageRewardToStakedReputersRequest(): GetPreviousPercentageRewardToStakedReputersRequest {
  return {};
}

export const GetPreviousPercentageRewardToStakedReputersRequest: MessageFns<
  GetPreviousPercentageRewardToStakedReputersRequest
> = {
  encode(
    _: GetPreviousPercentageRewardToStakedReputersRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousPercentageRewardToStakedReputersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousPercentageRewardToStakedReputersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetPreviousPercentageRewardToStakedReputersRequest {
    return {};
  },

  toJSON(_: GetPreviousPercentageRewardToStakedReputersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<GetPreviousPercentageRewardToStakedReputersRequest>,
  ): GetPreviousPercentageRewardToStakedReputersRequest {
    return GetPreviousPercentageRewardToStakedReputersRequest.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<GetPreviousPercentageRewardToStakedReputersRequest>,
  ): GetPreviousPercentageRewardToStakedReputersRequest {
    const message = createBaseGetPreviousPercentageRewardToStakedReputersRequest();
    return message;
  },
};

function createBaseGetPreviousPercentageRewardToStakedReputersResponse(): GetPreviousPercentageRewardToStakedReputersResponse {
  return { percentageReward: "" };
}

export const GetPreviousPercentageRewardToStakedReputersResponse: MessageFns<
  GetPreviousPercentageRewardToStakedReputersResponse
> = {
  encode(
    message: GetPreviousPercentageRewardToStakedReputersResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.percentageReward !== "") {
      writer.uint32(10).string(message.percentageReward);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreviousPercentageRewardToStakedReputersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreviousPercentageRewardToStakedReputersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.percentageReward = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreviousPercentageRewardToStakedReputersResponse {
    return { percentageReward: isSet(object.percentageReward) ? globalThis.String(object.percentageReward) : "" };
  },

  toJSON(message: GetPreviousPercentageRewardToStakedReputersResponse): unknown {
    const obj: any = {};
    if (message.percentageReward !== "") {
      obj.percentageReward = message.percentageReward;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetPreviousPercentageRewardToStakedReputersResponse>,
  ): GetPreviousPercentageRewardToStakedReputersResponse {
    return GetPreviousPercentageRewardToStakedReputersResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetPreviousPercentageRewardToStakedReputersResponse>,
  ): GetPreviousPercentageRewardToStakedReputersResponse {
    const message = createBaseGetPreviousPercentageRewardToStakedReputersResponse();
    message.percentageReward = object.percentageReward ?? "";
    return message;
  },
};

function createBaseGetTotalRewardToDistributeRequest(): GetTotalRewardToDistributeRequest {
  return {};
}

export const GetTotalRewardToDistributeRequest: MessageFns<GetTotalRewardToDistributeRequest> = {
  encode(_: GetTotalRewardToDistributeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalRewardToDistributeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalRewardToDistributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTotalRewardToDistributeRequest {
    return {};
  },

  toJSON(_: GetTotalRewardToDistributeRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetTotalRewardToDistributeRequest>): GetTotalRewardToDistributeRequest {
    return GetTotalRewardToDistributeRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetTotalRewardToDistributeRequest>): GetTotalRewardToDistributeRequest {
    const message = createBaseGetTotalRewardToDistributeRequest();
    return message;
  },
};

function createBaseGetTotalRewardToDistributeResponse(): GetTotalRewardToDistributeResponse {
  return { totalReward: "" };
}

export const GetTotalRewardToDistributeResponse: MessageFns<GetTotalRewardToDistributeResponse> = {
  encode(message: GetTotalRewardToDistributeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalReward !== "") {
      writer.uint32(10).string(message.totalReward);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalRewardToDistributeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalRewardToDistributeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.totalReward = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTotalRewardToDistributeResponse {
    return { totalReward: isSet(object.totalReward) ? globalThis.String(object.totalReward) : "" };
  },

  toJSON(message: GetTotalRewardToDistributeResponse): unknown {
    const obj: any = {};
    if (message.totalReward !== "") {
      obj.totalReward = message.totalReward;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTotalRewardToDistributeResponse>): GetTotalRewardToDistributeResponse {
    return GetTotalRewardToDistributeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTotalRewardToDistributeResponse>): GetTotalRewardToDistributeResponse {
    const message = createBaseGetTotalRewardToDistributeResponse();
    message.totalReward = object.totalReward ?? "";
    return message;
  },
};

function createBaseGetActiveTopicsAtBlockRequest(): GetActiveTopicsAtBlockRequest {
  return { blockHeight: "0" };
}

export const GetActiveTopicsAtBlockRequest: MessageFns<GetActiveTopicsAtBlockRequest> = {
  encode(message: GetActiveTopicsAtBlockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHeight !== "0") {
      writer.uint32(8).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveTopicsAtBlockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveTopicsAtBlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveTopicsAtBlockRequest {
    return { blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0" };
  },

  toJSON(message: GetActiveTopicsAtBlockRequest): unknown {
    const obj: any = {};
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveTopicsAtBlockRequest>): GetActiveTopicsAtBlockRequest {
    return GetActiveTopicsAtBlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveTopicsAtBlockRequest>): GetActiveTopicsAtBlockRequest {
    const message = createBaseGetActiveTopicsAtBlockRequest();
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetActiveTopicsAtBlockResponse(): GetActiveTopicsAtBlockResponse {
  return { topics: [], pagination: undefined };
}

export const GetActiveTopicsAtBlockResponse: MessageFns<GetActiveTopicsAtBlockResponse> = {
  encode(message: GetActiveTopicsAtBlockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topics) {
      Topic.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      SimpleCursorPaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveTopicsAtBlockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveTopicsAtBlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topics.push(Topic.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = SimpleCursorPaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveTopicsAtBlockResponse {
    return {
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => Topic.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? SimpleCursorPaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetActiveTopicsAtBlockResponse): unknown {
    const obj: any = {};
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => Topic.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = SimpleCursorPaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveTopicsAtBlockResponse>): GetActiveTopicsAtBlockResponse {
    return GetActiveTopicsAtBlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveTopicsAtBlockResponse>): GetActiveTopicsAtBlockResponse {
    const message = createBaseGetActiveTopicsAtBlockResponse();
    message.topics = object.topics?.map((e) => Topic.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? SimpleCursorPaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetNextChurningBlockByTopicIdRequest(): GetNextChurningBlockByTopicIdRequest {
  return { topicId: "0" };
}

export const GetNextChurningBlockByTopicIdRequest: MessageFns<GetNextChurningBlockByTopicIdRequest> = {
  encode(message: GetNextChurningBlockByTopicIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNextChurningBlockByTopicIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNextChurningBlockByTopicIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNextChurningBlockByTopicIdRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetNextChurningBlockByTopicIdRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNextChurningBlockByTopicIdRequest>): GetNextChurningBlockByTopicIdRequest {
    return GetNextChurningBlockByTopicIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNextChurningBlockByTopicIdRequest>): GetNextChurningBlockByTopicIdRequest {
    const message = createBaseGetNextChurningBlockByTopicIdRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetNextChurningBlockByTopicIdResponse(): GetNextChurningBlockByTopicIdResponse {
  return { blockHeight: "0" };
}

export const GetNextChurningBlockByTopicIdResponse: MessageFns<GetNextChurningBlockByTopicIdResponse> = {
  encode(message: GetNextChurningBlockByTopicIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHeight !== "0") {
      writer.uint32(8).int64(message.blockHeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNextChurningBlockByTopicIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNextChurningBlockByTopicIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNextChurningBlockByTopicIdResponse {
    return { blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0" };
  },

  toJSON(message: GetNextChurningBlockByTopicIdResponse): unknown {
    const obj: any = {};
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNextChurningBlockByTopicIdResponse>): GetNextChurningBlockByTopicIdResponse {
    return GetNextChurningBlockByTopicIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNextChurningBlockByTopicIdResponse>): GetNextChurningBlockByTopicIdResponse {
    const message = createBaseGetNextChurningBlockByTopicIdResponse();
    message.blockHeight = object.blockHeight ?? "0";
    return message;
  },
};

function createBaseGetActiveReputersForTopicRequest(): GetActiveReputersForTopicRequest {
  return { topicId: "0" };
}

export const GetActiveReputersForTopicRequest: MessageFns<GetActiveReputersForTopicRequest> = {
  encode(message: GetActiveReputersForTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveReputersForTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveReputersForTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveReputersForTopicRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetActiveReputersForTopicRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveReputersForTopicRequest>): GetActiveReputersForTopicRequest {
    return GetActiveReputersForTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveReputersForTopicRequest>): GetActiveReputersForTopicRequest {
    const message = createBaseGetActiveReputersForTopicRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetActiveReputersForTopicResponse(): GetActiveReputersForTopicResponse {
  return { reputers: [] };
}

export const GetActiveReputersForTopicResponse: MessageFns<GetActiveReputersForTopicResponse> = {
  encode(message: GetActiveReputersForTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reputers) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveReputersForTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveReputersForTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reputers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveReputersForTopicResponse {
    return {
      reputers: globalThis.Array.isArray(object?.reputers) ? object.reputers.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetActiveReputersForTopicResponse): unknown {
    const obj: any = {};
    if (message.reputers?.length) {
      obj.reputers = message.reputers;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveReputersForTopicResponse>): GetActiveReputersForTopicResponse {
    return GetActiveReputersForTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveReputersForTopicResponse>): GetActiveReputersForTopicResponse {
    const message = createBaseGetActiveReputersForTopicResponse();
    message.reputers = object.reputers?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetActiveForecastersForTopicRequest(): GetActiveForecastersForTopicRequest {
  return { topicId: "0" };
}

export const GetActiveForecastersForTopicRequest: MessageFns<GetActiveForecastersForTopicRequest> = {
  encode(message: GetActiveForecastersForTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveForecastersForTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveForecastersForTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveForecastersForTopicRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetActiveForecastersForTopicRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveForecastersForTopicRequest>): GetActiveForecastersForTopicRequest {
    return GetActiveForecastersForTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveForecastersForTopicRequest>): GetActiveForecastersForTopicRequest {
    const message = createBaseGetActiveForecastersForTopicRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetActiveForecastersForTopicResponse(): GetActiveForecastersForTopicResponse {
  return { forecasters: [] };
}

export const GetActiveForecastersForTopicResponse: MessageFns<GetActiveForecastersForTopicResponse> = {
  encode(message: GetActiveForecastersForTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.forecasters) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveForecastersForTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveForecastersForTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.forecasters.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveForecastersForTopicResponse {
    return {
      forecasters: globalThis.Array.isArray(object?.forecasters)
        ? object.forecasters.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetActiveForecastersForTopicResponse): unknown {
    const obj: any = {};
    if (message.forecasters?.length) {
      obj.forecasters = message.forecasters;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveForecastersForTopicResponse>): GetActiveForecastersForTopicResponse {
    return GetActiveForecastersForTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveForecastersForTopicResponse>): GetActiveForecastersForTopicResponse {
    const message = createBaseGetActiveForecastersForTopicResponse();
    message.forecasters = object.forecasters?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetActiveInferersForTopicRequest(): GetActiveInferersForTopicRequest {
  return { topicId: "0" };
}

export const GetActiveInferersForTopicRequest: MessageFns<GetActiveInferersForTopicRequest> = {
  encode(message: GetActiveInferersForTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "0") {
      writer.uint32(8).uint64(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveInferersForTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveInferersForTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveInferersForTopicRequest {
    return { topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "0" };
  },

  toJSON(message: GetActiveInferersForTopicRequest): unknown {
    const obj: any = {};
    if (message.topicId !== "0") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveInferersForTopicRequest>): GetActiveInferersForTopicRequest {
    return GetActiveInferersForTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveInferersForTopicRequest>): GetActiveInferersForTopicRequest {
    const message = createBaseGetActiveInferersForTopicRequest();
    message.topicId = object.topicId ?? "0";
    return message;
  },
};

function createBaseGetActiveInferersForTopicResponse(): GetActiveInferersForTopicResponse {
  return { inferers: [] };
}

export const GetActiveInferersForTopicResponse: MessageFns<GetActiveInferersForTopicResponse> = {
  encode(message: GetActiveInferersForTopicResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inferers) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveInferersForTopicResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveInferersForTopicResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inferers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveInferersForTopicResponse {
    return {
      inferers: globalThis.Array.isArray(object?.inferers) ? object.inferers.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetActiveInferersForTopicResponse): unknown {
    const obj: any = {};
    if (message.inferers?.length) {
      obj.inferers = message.inferers;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActiveInferersForTopicResponse>): GetActiveInferersForTopicResponse {
    return GetActiveInferersForTopicResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActiveInferersForTopicResponse>): GetActiveInferersForTopicResponse {
    const message = createBaseGetActiveInferersForTopicResponse();
    message.inferers = object.inferers?.map((e) => e) || [];
    return message;
  },
};

/** Msg defines the module Msg service. */
export interface QueryService {
  /** Params returns the module parameters. */
  GetParams(request: GetParamsRequest): Promise<GetParamsResponse>;
  GetNextTopicId(request: GetNextTopicIdRequest): Promise<GetNextTopicIdResponse>;
  GetTopic(request: GetTopicRequest): Promise<GetTopicResponse>;
  GetWorkerLatestInferenceByTopicId(
    request: GetWorkerLatestInferenceByTopicIdRequest,
  ): Promise<GetWorkerLatestInferenceByTopicIdResponse>;
  GetInferencesAtBlock(request: GetInferencesAtBlockRequest): Promise<GetInferencesAtBlockResponse>;
  GetLatestTopicInferences(request: GetLatestTopicInferencesRequest): Promise<GetLatestTopicInferencesResponse>;
  GetForecastsAtBlock(request: GetForecastsAtBlockRequest): Promise<GetForecastsAtBlockResponse>;
  GetNetworkLossBundleAtBlock(
    request: GetNetworkLossBundleAtBlockRequest,
  ): Promise<GetNetworkLossBundleAtBlockResponse>;
  GetTotalStake(request: GetTotalStakeRequest): Promise<GetTotalStakeResponse>;
  GetReputerStakeInTopic(request: GetReputerStakeInTopicRequest): Promise<GetReputerStakeInTopicResponse>;
  GetMultiReputerStakeInTopic(
    request: GetMultiReputerStakeInTopicRequest,
  ): Promise<GetMultiReputerStakeInTopicResponse>;
  GetStakeFromReputerInTopicInSelf(
    request: GetStakeFromReputerInTopicInSelfRequest,
  ): Promise<GetStakeFromReputerInTopicInSelfResponse>;
  GetDelegateStakeInTopicInReputer(
    request: GetDelegateStakeInTopicInReputerRequest,
  ): Promise<GetDelegateStakeInTopicInReputerResponse>;
  GetStakeFromDelegatorInTopicInReputer(
    request: GetStakeFromDelegatorInTopicInReputerRequest,
  ): Promise<GetStakeFromDelegatorInTopicInReputerResponse>;
  GetStakeFromDelegatorInTopic(
    request: GetStakeFromDelegatorInTopicRequest,
  ): Promise<GetStakeFromDelegatorInTopicResponse>;
  GetTopicStake(request: GetTopicStakeRequest): Promise<GetTopicStakeResponse>;
  GetStakeRemovalsUpUntilBlock(
    request: GetStakeRemovalsUpUntilBlockRequest,
  ): Promise<GetStakeRemovalsUpUntilBlockResponse>;
  GetDelegateStakeRemovalsUpUntilBlock(
    request: GetDelegateStakeRemovalsUpUntilBlockRequest,
  ): Promise<GetDelegateStakeRemovalsUpUntilBlockResponse>;
  GetStakeRemovalInfo(request: GetStakeRemovalInfoRequest): Promise<GetStakeRemovalInfoResponse>;
  GetDelegateStakeRemovalInfo(
    request: GetDelegateStakeRemovalInfoRequest,
  ): Promise<GetDelegateStakeRemovalInfoResponse>;
  GetWorkerNodeInfo(request: GetWorkerNodeInfoRequest): Promise<GetWorkerNodeInfoResponse>;
  GetReputerNodeInfo(request: GetReputerNodeInfoRequest): Promise<GetReputerNodeInfoResponse>;
  IsWorkerRegisteredInTopicId(
    request: IsWorkerRegisteredInTopicIdRequest,
  ): Promise<IsWorkerRegisteredInTopicIdResponse>;
  IsReputerRegisteredInTopicId(
    request: IsReputerRegisteredInTopicIdRequest,
  ): Promise<IsReputerRegisteredInTopicIdResponse>;
  GetNetworkInferencesAtBlock(
    request: GetNetworkInferencesAtBlockRequest,
  ): Promise<GetNetworkInferencesAtBlockResponse>;
  GetLatestNetworkInferences(request: GetLatestNetworkInferencesRequest): Promise<GetLatestNetworkInferencesResponse>;
  GetLatestAvailableNetworkInferences(
    request: GetLatestAvailableNetworkInferencesRequest,
  ): Promise<GetLatestAvailableNetworkInferencesResponse>;
  IsWorkerNonceUnfulfilled(request: IsWorkerNonceUnfulfilledRequest): Promise<IsWorkerNonceUnfulfilledResponse>;
  IsReputerNonceUnfulfilled(request: IsReputerNonceUnfulfilledRequest): Promise<IsReputerNonceUnfulfilledResponse>;
  GetUnfulfilledWorkerNonces(request: GetUnfulfilledWorkerNoncesRequest): Promise<GetUnfulfilledWorkerNoncesResponse>;
  GetUnfulfilledReputerNonces(
    request: GetUnfulfilledReputerNoncesRequest,
  ): Promise<GetUnfulfilledReputerNoncesResponse>;
  GetInfererNetworkRegret(request: GetInfererNetworkRegretRequest): Promise<GetInfererNetworkRegretResponse>;
  GetForecasterNetworkRegret(request: GetForecasterNetworkRegretRequest): Promise<GetForecasterNetworkRegretResponse>;
  GetOneInForecasterNetworkRegret(
    request: GetOneInForecasterNetworkRegretRequest,
  ): Promise<GetOneInForecasterNetworkRegretResponse>;
  IsWhitelistAdmin(request: IsWhitelistAdminRequest): Promise<IsWhitelistAdminResponse>;
  GetTopicLastWorkerCommitInfo(
    request: GetTopicLastWorkerCommitInfoRequest,
  ): Promise<GetTopicLastWorkerCommitInfoResponse>;
  GetTopicLastReputerCommitInfo(
    request: GetTopicLastReputerCommitInfoRequest,
  ): Promise<GetTopicLastReputerCommitInfoResponse>;
  GetTopicRewardNonce(request: GetTopicRewardNonceRequest): Promise<GetTopicRewardNonceResponse>;
  GetReputerLossBundlesAtBlock(
    request: GetReputerLossBundlesAtBlockRequest,
  ): Promise<GetReputerLossBundlesAtBlockResponse>;
  GetStakeReputerAuthority(request: GetStakeReputerAuthorityRequest): Promise<GetStakeReputerAuthorityResponse>;
  GetDelegateStakePlacement(request: GetDelegateStakePlacementRequest): Promise<GetDelegateStakePlacementResponse>;
  GetDelegateStakeUponReputer(
    request: GetDelegateStakeUponReputerRequest,
  ): Promise<GetDelegateStakeUponReputerResponse>;
  GetDelegateRewardPerShare(request: GetDelegateRewardPerShareRequest): Promise<GetDelegateRewardPerShareResponse>;
  GetStakeRemovalForReputerAndTopicId(
    request: GetStakeRemovalForReputerAndTopicIdRequest,
  ): Promise<GetStakeRemovalForReputerAndTopicIdResponse>;
  GetDelegateStakeRemoval(request: GetDelegateStakeRemovalRequest): Promise<GetDelegateStakeRemovalResponse>;
  GetPreviousTopicWeight(request: GetPreviousTopicWeightRequest): Promise<GetPreviousTopicWeightResponse>;
  GetTotalSumPreviousTopicWeights(
    request: GetTotalSumPreviousTopicWeightsRequest,
  ): Promise<GetTotalSumPreviousTopicWeightsResponse>;
  TopicExists(request: TopicExistsRequest): Promise<TopicExistsResponse>;
  IsTopicActive(request: IsTopicActiveRequest): Promise<IsTopicActiveResponse>;
  GetTopicFeeRevenue(request: GetTopicFeeRevenueRequest): Promise<GetTopicFeeRevenueResponse>;
  GetInfererScoreEma(request: GetInfererScoreEmaRequest): Promise<GetInfererScoreEmaResponse>;
  GetForecasterScoreEma(request: GetForecasterScoreEmaRequest): Promise<GetForecasterScoreEmaResponse>;
  GetReputerScoreEma(request: GetReputerScoreEmaRequest): Promise<GetReputerScoreEmaResponse>;
  GetInferenceScoresUntilBlock(
    request: GetInferenceScoresUntilBlockRequest,
  ): Promise<GetInferenceScoresUntilBlockResponse>;
  GetPreviousTopicQuantileForecasterScoreEma(
    request: GetPreviousTopicQuantileForecasterScoreEmaRequest,
  ): Promise<GetPreviousTopicQuantileForecasterScoreEmaResponse>;
  GetPreviousTopicQuantileInfererScoreEma(
    request: GetPreviousTopicQuantileInfererScoreEmaRequest,
  ): Promise<GetPreviousTopicQuantileInfererScoreEmaResponse>;
  GetPreviousTopicQuantileReputerScoreEma(
    request: GetPreviousTopicQuantileReputerScoreEmaRequest,
  ): Promise<GetPreviousTopicQuantileReputerScoreEmaResponse>;
  GetWorkerInferenceScoresAtBlock(
    request: GetWorkerInferenceScoresAtBlockRequest,
  ): Promise<GetWorkerInferenceScoresAtBlockResponse>;
  GetCurrentLowestInfererScore(
    request: GetCurrentLowestInfererScoreRequest,
  ): Promise<GetCurrentLowestInfererScoreResponse>;
  GetForecastScoresUntilBlock(
    request: GetForecastScoresUntilBlockRequest,
  ): Promise<GetForecastScoresUntilBlockResponse>;
  GetWorkerForecastScoresAtBlock(
    request: GetWorkerForecastScoresAtBlockRequest,
  ): Promise<GetWorkerForecastScoresAtBlockResponse>;
  GetCurrentLowestForecasterScore(
    request: GetCurrentLowestForecasterScoreRequest,
  ): Promise<GetCurrentLowestForecasterScoreResponse>;
  GetReputersScoresAtBlock(request: GetReputersScoresAtBlockRequest): Promise<GetReputersScoresAtBlockResponse>;
  GetCurrentLowestReputerScore(
    request: GetCurrentLowestReputerScoreRequest,
  ): Promise<GetCurrentLowestReputerScoreResponse>;
  GetListeningCoefficient(request: GetListeningCoefficientRequest): Promise<GetListeningCoefficientResponse>;
  GetPreviousReputerRewardFraction(
    request: GetPreviousReputerRewardFractionRequest,
  ): Promise<GetPreviousReputerRewardFractionResponse>;
  GetPreviousInferenceRewardFraction(
    request: GetPreviousInferenceRewardFractionRequest,
  ): Promise<GetPreviousInferenceRewardFractionResponse>;
  GetPreviousForecastRewardFraction(
    request: GetPreviousForecastRewardFractionRequest,
  ): Promise<GetPreviousForecastRewardFractionResponse>;
  GetPreviousPercentageRewardToStakedReputers(
    request: GetPreviousPercentageRewardToStakedReputersRequest,
  ): Promise<GetPreviousPercentageRewardToStakedReputersResponse>;
  GetTotalRewardToDistribute(request: GetTotalRewardToDistributeRequest): Promise<GetTotalRewardToDistributeResponse>;
  GetNaiveInfererNetworkRegret(
    request: GetNaiveInfererNetworkRegretRequest,
  ): Promise<GetNaiveInfererNetworkRegretResponse>;
  GetOneOutInfererInfererNetworkRegret(
    request: GetOneOutInfererInfererNetworkRegretRequest,
  ): Promise<GetOneOutInfererInfererNetworkRegretResponse>;
  GetOneOutInfererForecasterNetworkRegret(
    request: GetOneOutInfererForecasterNetworkRegretRequest,
  ): Promise<GetOneOutInfererForecasterNetworkRegretResponse>;
  GetOneOutForecasterInfererNetworkRegret(
    request: GetOneOutForecasterInfererNetworkRegretRequest,
  ): Promise<GetOneOutForecasterInfererNetworkRegretResponse>;
  GetOneOutForecasterForecasterNetworkRegret(
    request: GetOneOutForecasterForecasterNetworkRegretRequest,
  ): Promise<GetOneOutForecasterForecasterNetworkRegretResponse>;
  GetActiveTopicsAtBlock(request: GetActiveTopicsAtBlockRequest): Promise<GetActiveTopicsAtBlockResponse>;
  GetNextChurningBlockByTopicId(
    request: GetNextChurningBlockByTopicIdRequest,
  ): Promise<GetNextChurningBlockByTopicIdResponse>;
  GetCountInfererInclusionsInTopic(
    request: GetCountInfererInclusionsInTopicRequest,
  ): Promise<GetCountInfererInclusionsInTopicResponse>;
  GetCountForecasterInclusionsInTopic(
    request: GetCountForecasterInclusionsInTopicRequest,
  ): Promise<GetCountForecasterInclusionsInTopicResponse>;
  GetActiveReputersForTopic(request: GetActiveReputersForTopicRequest): Promise<GetActiveReputersForTopicResponse>;
  GetActiveForecastersForTopic(
    request: GetActiveForecastersForTopicRequest,
  ): Promise<GetActiveForecastersForTopicResponse>;
  GetActiveInferersForTopic(request: GetActiveInferersForTopicRequest): Promise<GetActiveInferersForTopicResponse>;
}

export const QueryServiceServiceName = "emissions.v5.QueryService";
export class QueryServiceClientImpl implements QueryService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceServiceName;
    this.rpc = rpc;
    this.GetParams = this.GetParams.bind(this);
    this.GetNextTopicId = this.GetNextTopicId.bind(this);
    this.GetTopic = this.GetTopic.bind(this);
    this.GetWorkerLatestInferenceByTopicId = this.GetWorkerLatestInferenceByTopicId.bind(this);
    this.GetInferencesAtBlock = this.GetInferencesAtBlock.bind(this);
    this.GetLatestTopicInferences = this.GetLatestTopicInferences.bind(this);
    this.GetForecastsAtBlock = this.GetForecastsAtBlock.bind(this);
    this.GetNetworkLossBundleAtBlock = this.GetNetworkLossBundleAtBlock.bind(this);
    this.GetTotalStake = this.GetTotalStake.bind(this);
    this.GetReputerStakeInTopic = this.GetReputerStakeInTopic.bind(this);
    this.GetMultiReputerStakeInTopic = this.GetMultiReputerStakeInTopic.bind(this);
    this.GetStakeFromReputerInTopicInSelf = this.GetStakeFromReputerInTopicInSelf.bind(this);
    this.GetDelegateStakeInTopicInReputer = this.GetDelegateStakeInTopicInReputer.bind(this);
    this.GetStakeFromDelegatorInTopicInReputer = this.GetStakeFromDelegatorInTopicInReputer.bind(this);
    this.GetStakeFromDelegatorInTopic = this.GetStakeFromDelegatorInTopic.bind(this);
    this.GetTopicStake = this.GetTopicStake.bind(this);
    this.GetStakeRemovalsUpUntilBlock = this.GetStakeRemovalsUpUntilBlock.bind(this);
    this.GetDelegateStakeRemovalsUpUntilBlock = this.GetDelegateStakeRemovalsUpUntilBlock.bind(this);
    this.GetStakeRemovalInfo = this.GetStakeRemovalInfo.bind(this);
    this.GetDelegateStakeRemovalInfo = this.GetDelegateStakeRemovalInfo.bind(this);
    this.GetWorkerNodeInfo = this.GetWorkerNodeInfo.bind(this);
    this.GetReputerNodeInfo = this.GetReputerNodeInfo.bind(this);
    this.IsWorkerRegisteredInTopicId = this.IsWorkerRegisteredInTopicId.bind(this);
    this.IsReputerRegisteredInTopicId = this.IsReputerRegisteredInTopicId.bind(this);
    this.GetNetworkInferencesAtBlock = this.GetNetworkInferencesAtBlock.bind(this);
    this.GetLatestNetworkInferences = this.GetLatestNetworkInferences.bind(this);
    this.GetLatestAvailableNetworkInferences = this.GetLatestAvailableNetworkInferences.bind(this);
    this.IsWorkerNonceUnfulfilled = this.IsWorkerNonceUnfulfilled.bind(this);
    this.IsReputerNonceUnfulfilled = this.IsReputerNonceUnfulfilled.bind(this);
    this.GetUnfulfilledWorkerNonces = this.GetUnfulfilledWorkerNonces.bind(this);
    this.GetUnfulfilledReputerNonces = this.GetUnfulfilledReputerNonces.bind(this);
    this.GetInfererNetworkRegret = this.GetInfererNetworkRegret.bind(this);
    this.GetForecasterNetworkRegret = this.GetForecasterNetworkRegret.bind(this);
    this.GetOneInForecasterNetworkRegret = this.GetOneInForecasterNetworkRegret.bind(this);
    this.IsWhitelistAdmin = this.IsWhitelistAdmin.bind(this);
    this.GetTopicLastWorkerCommitInfo = this.GetTopicLastWorkerCommitInfo.bind(this);
    this.GetTopicLastReputerCommitInfo = this.GetTopicLastReputerCommitInfo.bind(this);
    this.GetTopicRewardNonce = this.GetTopicRewardNonce.bind(this);
    this.GetReputerLossBundlesAtBlock = this.GetReputerLossBundlesAtBlock.bind(this);
    this.GetStakeReputerAuthority = this.GetStakeReputerAuthority.bind(this);
    this.GetDelegateStakePlacement = this.GetDelegateStakePlacement.bind(this);
    this.GetDelegateStakeUponReputer = this.GetDelegateStakeUponReputer.bind(this);
    this.GetDelegateRewardPerShare = this.GetDelegateRewardPerShare.bind(this);
    this.GetStakeRemovalForReputerAndTopicId = this.GetStakeRemovalForReputerAndTopicId.bind(this);
    this.GetDelegateStakeRemoval = this.GetDelegateStakeRemoval.bind(this);
    this.GetPreviousTopicWeight = this.GetPreviousTopicWeight.bind(this);
    this.GetTotalSumPreviousTopicWeights = this.GetTotalSumPreviousTopicWeights.bind(this);
    this.TopicExists = this.TopicExists.bind(this);
    this.IsTopicActive = this.IsTopicActive.bind(this);
    this.GetTopicFeeRevenue = this.GetTopicFeeRevenue.bind(this);
    this.GetInfererScoreEma = this.GetInfererScoreEma.bind(this);
    this.GetForecasterScoreEma = this.GetForecasterScoreEma.bind(this);
    this.GetReputerScoreEma = this.GetReputerScoreEma.bind(this);
    this.GetInferenceScoresUntilBlock = this.GetInferenceScoresUntilBlock.bind(this);
    this.GetPreviousTopicQuantileForecasterScoreEma = this.GetPreviousTopicQuantileForecasterScoreEma.bind(this);
    this.GetPreviousTopicQuantileInfererScoreEma = this.GetPreviousTopicQuantileInfererScoreEma.bind(this);
    this.GetPreviousTopicQuantileReputerScoreEma = this.GetPreviousTopicQuantileReputerScoreEma.bind(this);
    this.GetWorkerInferenceScoresAtBlock = this.GetWorkerInferenceScoresAtBlock.bind(this);
    this.GetCurrentLowestInfererScore = this.GetCurrentLowestInfererScore.bind(this);
    this.GetForecastScoresUntilBlock = this.GetForecastScoresUntilBlock.bind(this);
    this.GetWorkerForecastScoresAtBlock = this.GetWorkerForecastScoresAtBlock.bind(this);
    this.GetCurrentLowestForecasterScore = this.GetCurrentLowestForecasterScore.bind(this);
    this.GetReputersScoresAtBlock = this.GetReputersScoresAtBlock.bind(this);
    this.GetCurrentLowestReputerScore = this.GetCurrentLowestReputerScore.bind(this);
    this.GetListeningCoefficient = this.GetListeningCoefficient.bind(this);
    this.GetPreviousReputerRewardFraction = this.GetPreviousReputerRewardFraction.bind(this);
    this.GetPreviousInferenceRewardFraction = this.GetPreviousInferenceRewardFraction.bind(this);
    this.GetPreviousForecastRewardFraction = this.GetPreviousForecastRewardFraction.bind(this);
    this.GetPreviousPercentageRewardToStakedReputers = this.GetPreviousPercentageRewardToStakedReputers.bind(this);
    this.GetTotalRewardToDistribute = this.GetTotalRewardToDistribute.bind(this);
    this.GetNaiveInfererNetworkRegret = this.GetNaiveInfererNetworkRegret.bind(this);
    this.GetOneOutInfererInfererNetworkRegret = this.GetOneOutInfererInfererNetworkRegret.bind(this);
    this.GetOneOutInfererForecasterNetworkRegret = this.GetOneOutInfererForecasterNetworkRegret.bind(this);
    this.GetOneOutForecasterInfererNetworkRegret = this.GetOneOutForecasterInfererNetworkRegret.bind(this);
    this.GetOneOutForecasterForecasterNetworkRegret = this.GetOneOutForecasterForecasterNetworkRegret.bind(this);
    this.GetActiveTopicsAtBlock = this.GetActiveTopicsAtBlock.bind(this);
    this.GetNextChurningBlockByTopicId = this.GetNextChurningBlockByTopicId.bind(this);
    this.GetCountInfererInclusionsInTopic = this.GetCountInfererInclusionsInTopic.bind(this);
    this.GetCountForecasterInclusionsInTopic = this.GetCountForecasterInclusionsInTopic.bind(this);
    this.GetActiveReputersForTopic = this.GetActiveReputersForTopic.bind(this);
    this.GetActiveForecastersForTopic = this.GetActiveForecastersForTopic.bind(this);
    this.GetActiveInferersForTopic = this.GetActiveInferersForTopic.bind(this);
  }
  GetParams(request: GetParamsRequest): Promise<GetParamsResponse> {
    const data = GetParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetParams", data);
    return promise.then((data) => GetParamsResponse.decode(new BinaryReader(data)));
  }

  GetNextTopicId(request: GetNextTopicIdRequest): Promise<GetNextTopicIdResponse> {
    const data = GetNextTopicIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNextTopicId", data);
    return promise.then((data) => GetNextTopicIdResponse.decode(new BinaryReader(data)));
  }

  GetTopic(request: GetTopicRequest): Promise<GetTopicResponse> {
    const data = GetTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTopic", data);
    return promise.then((data) => GetTopicResponse.decode(new BinaryReader(data)));
  }

  GetWorkerLatestInferenceByTopicId(
    request: GetWorkerLatestInferenceByTopicIdRequest,
  ): Promise<GetWorkerLatestInferenceByTopicIdResponse> {
    const data = GetWorkerLatestInferenceByTopicIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWorkerLatestInferenceByTopicId", data);
    return promise.then((data) => GetWorkerLatestInferenceByTopicIdResponse.decode(new BinaryReader(data)));
  }

  GetInferencesAtBlock(request: GetInferencesAtBlockRequest): Promise<GetInferencesAtBlockResponse> {
    const data = GetInferencesAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetInferencesAtBlock", data);
    return promise.then((data) => GetInferencesAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetLatestTopicInferences(request: GetLatestTopicInferencesRequest): Promise<GetLatestTopicInferencesResponse> {
    const data = GetLatestTopicInferencesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLatestTopicInferences", data);
    return promise.then((data) => GetLatestTopicInferencesResponse.decode(new BinaryReader(data)));
  }

  GetForecastsAtBlock(request: GetForecastsAtBlockRequest): Promise<GetForecastsAtBlockResponse> {
    const data = GetForecastsAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetForecastsAtBlock", data);
    return promise.then((data) => GetForecastsAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetNetworkLossBundleAtBlock(
    request: GetNetworkLossBundleAtBlockRequest,
  ): Promise<GetNetworkLossBundleAtBlockResponse> {
    const data = GetNetworkLossBundleAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNetworkLossBundleAtBlock", data);
    return promise.then((data) => GetNetworkLossBundleAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetTotalStake(request: GetTotalStakeRequest): Promise<GetTotalStakeResponse> {
    const data = GetTotalStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTotalStake", data);
    return promise.then((data) => GetTotalStakeResponse.decode(new BinaryReader(data)));
  }

  GetReputerStakeInTopic(request: GetReputerStakeInTopicRequest): Promise<GetReputerStakeInTopicResponse> {
    const data = GetReputerStakeInTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReputerStakeInTopic", data);
    return promise.then((data) => GetReputerStakeInTopicResponse.decode(new BinaryReader(data)));
  }

  GetMultiReputerStakeInTopic(
    request: GetMultiReputerStakeInTopicRequest,
  ): Promise<GetMultiReputerStakeInTopicResponse> {
    const data = GetMultiReputerStakeInTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetMultiReputerStakeInTopic", data);
    return promise.then((data) => GetMultiReputerStakeInTopicResponse.decode(new BinaryReader(data)));
  }

  GetStakeFromReputerInTopicInSelf(
    request: GetStakeFromReputerInTopicInSelfRequest,
  ): Promise<GetStakeFromReputerInTopicInSelfResponse> {
    const data = GetStakeFromReputerInTopicInSelfRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStakeFromReputerInTopicInSelf", data);
    return promise.then((data) => GetStakeFromReputerInTopicInSelfResponse.decode(new BinaryReader(data)));
  }

  GetDelegateStakeInTopicInReputer(
    request: GetDelegateStakeInTopicInReputerRequest,
  ): Promise<GetDelegateStakeInTopicInReputerResponse> {
    const data = GetDelegateStakeInTopicInReputerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDelegateStakeInTopicInReputer", data);
    return promise.then((data) => GetDelegateStakeInTopicInReputerResponse.decode(new BinaryReader(data)));
  }

  GetStakeFromDelegatorInTopicInReputer(
    request: GetStakeFromDelegatorInTopicInReputerRequest,
  ): Promise<GetStakeFromDelegatorInTopicInReputerResponse> {
    const data = GetStakeFromDelegatorInTopicInReputerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStakeFromDelegatorInTopicInReputer", data);
    return promise.then((data) => GetStakeFromDelegatorInTopicInReputerResponse.decode(new BinaryReader(data)));
  }

  GetStakeFromDelegatorInTopic(
    request: GetStakeFromDelegatorInTopicRequest,
  ): Promise<GetStakeFromDelegatorInTopicResponse> {
    const data = GetStakeFromDelegatorInTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStakeFromDelegatorInTopic", data);
    return promise.then((data) => GetStakeFromDelegatorInTopicResponse.decode(new BinaryReader(data)));
  }

  GetTopicStake(request: GetTopicStakeRequest): Promise<GetTopicStakeResponse> {
    const data = GetTopicStakeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTopicStake", data);
    return promise.then((data) => GetTopicStakeResponse.decode(new BinaryReader(data)));
  }

  GetStakeRemovalsUpUntilBlock(
    request: GetStakeRemovalsUpUntilBlockRequest,
  ): Promise<GetStakeRemovalsUpUntilBlockResponse> {
    const data = GetStakeRemovalsUpUntilBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStakeRemovalsUpUntilBlock", data);
    return promise.then((data) => GetStakeRemovalsUpUntilBlockResponse.decode(new BinaryReader(data)));
  }

  GetDelegateStakeRemovalsUpUntilBlock(
    request: GetDelegateStakeRemovalsUpUntilBlockRequest,
  ): Promise<GetDelegateStakeRemovalsUpUntilBlockResponse> {
    const data = GetDelegateStakeRemovalsUpUntilBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDelegateStakeRemovalsUpUntilBlock", data);
    return promise.then((data) => GetDelegateStakeRemovalsUpUntilBlockResponse.decode(new BinaryReader(data)));
  }

  GetStakeRemovalInfo(request: GetStakeRemovalInfoRequest): Promise<GetStakeRemovalInfoResponse> {
    const data = GetStakeRemovalInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStakeRemovalInfo", data);
    return promise.then((data) => GetStakeRemovalInfoResponse.decode(new BinaryReader(data)));
  }

  GetDelegateStakeRemovalInfo(
    request: GetDelegateStakeRemovalInfoRequest,
  ): Promise<GetDelegateStakeRemovalInfoResponse> {
    const data = GetDelegateStakeRemovalInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDelegateStakeRemovalInfo", data);
    return promise.then((data) => GetDelegateStakeRemovalInfoResponse.decode(new BinaryReader(data)));
  }

  GetWorkerNodeInfo(request: GetWorkerNodeInfoRequest): Promise<GetWorkerNodeInfoResponse> {
    const data = GetWorkerNodeInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWorkerNodeInfo", data);
    return promise.then((data) => GetWorkerNodeInfoResponse.decode(new BinaryReader(data)));
  }

  GetReputerNodeInfo(request: GetReputerNodeInfoRequest): Promise<GetReputerNodeInfoResponse> {
    const data = GetReputerNodeInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReputerNodeInfo", data);
    return promise.then((data) => GetReputerNodeInfoResponse.decode(new BinaryReader(data)));
  }

  IsWorkerRegisteredInTopicId(
    request: IsWorkerRegisteredInTopicIdRequest,
  ): Promise<IsWorkerRegisteredInTopicIdResponse> {
    const data = IsWorkerRegisteredInTopicIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IsWorkerRegisteredInTopicId", data);
    return promise.then((data) => IsWorkerRegisteredInTopicIdResponse.decode(new BinaryReader(data)));
  }

  IsReputerRegisteredInTopicId(
    request: IsReputerRegisteredInTopicIdRequest,
  ): Promise<IsReputerRegisteredInTopicIdResponse> {
    const data = IsReputerRegisteredInTopicIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IsReputerRegisteredInTopicId", data);
    return promise.then((data) => IsReputerRegisteredInTopicIdResponse.decode(new BinaryReader(data)));
  }

  GetNetworkInferencesAtBlock(
    request: GetNetworkInferencesAtBlockRequest,
  ): Promise<GetNetworkInferencesAtBlockResponse> {
    const data = GetNetworkInferencesAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNetworkInferencesAtBlock", data);
    return promise.then((data) => GetNetworkInferencesAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetLatestNetworkInferences(request: GetLatestNetworkInferencesRequest): Promise<GetLatestNetworkInferencesResponse> {
    const data = GetLatestNetworkInferencesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLatestNetworkInferences", data);
    return promise.then((data) => GetLatestNetworkInferencesResponse.decode(new BinaryReader(data)));
  }

  GetLatestAvailableNetworkInferences(
    request: GetLatestAvailableNetworkInferencesRequest,
  ): Promise<GetLatestAvailableNetworkInferencesResponse> {
    const data = GetLatestAvailableNetworkInferencesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLatestAvailableNetworkInferences", data);
    return promise.then((data) => GetLatestAvailableNetworkInferencesResponse.decode(new BinaryReader(data)));
  }

  IsWorkerNonceUnfulfilled(request: IsWorkerNonceUnfulfilledRequest): Promise<IsWorkerNonceUnfulfilledResponse> {
    const data = IsWorkerNonceUnfulfilledRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IsWorkerNonceUnfulfilled", data);
    return promise.then((data) => IsWorkerNonceUnfulfilledResponse.decode(new BinaryReader(data)));
  }

  IsReputerNonceUnfulfilled(request: IsReputerNonceUnfulfilledRequest): Promise<IsReputerNonceUnfulfilledResponse> {
    const data = IsReputerNonceUnfulfilledRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IsReputerNonceUnfulfilled", data);
    return promise.then((data) => IsReputerNonceUnfulfilledResponse.decode(new BinaryReader(data)));
  }

  GetUnfulfilledWorkerNonces(request: GetUnfulfilledWorkerNoncesRequest): Promise<GetUnfulfilledWorkerNoncesResponse> {
    const data = GetUnfulfilledWorkerNoncesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUnfulfilledWorkerNonces", data);
    return promise.then((data) => GetUnfulfilledWorkerNoncesResponse.decode(new BinaryReader(data)));
  }

  GetUnfulfilledReputerNonces(
    request: GetUnfulfilledReputerNoncesRequest,
  ): Promise<GetUnfulfilledReputerNoncesResponse> {
    const data = GetUnfulfilledReputerNoncesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUnfulfilledReputerNonces", data);
    return promise.then((data) => GetUnfulfilledReputerNoncesResponse.decode(new BinaryReader(data)));
  }

  GetInfererNetworkRegret(request: GetInfererNetworkRegretRequest): Promise<GetInfererNetworkRegretResponse> {
    const data = GetInfererNetworkRegretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetInfererNetworkRegret", data);
    return promise.then((data) => GetInfererNetworkRegretResponse.decode(new BinaryReader(data)));
  }

  GetForecasterNetworkRegret(request: GetForecasterNetworkRegretRequest): Promise<GetForecasterNetworkRegretResponse> {
    const data = GetForecasterNetworkRegretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetForecasterNetworkRegret", data);
    return promise.then((data) => GetForecasterNetworkRegretResponse.decode(new BinaryReader(data)));
  }

  GetOneInForecasterNetworkRegret(
    request: GetOneInForecasterNetworkRegretRequest,
  ): Promise<GetOneInForecasterNetworkRegretResponse> {
    const data = GetOneInForecasterNetworkRegretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOneInForecasterNetworkRegret", data);
    return promise.then((data) => GetOneInForecasterNetworkRegretResponse.decode(new BinaryReader(data)));
  }

  IsWhitelistAdmin(request: IsWhitelistAdminRequest): Promise<IsWhitelistAdminResponse> {
    const data = IsWhitelistAdminRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IsWhitelistAdmin", data);
    return promise.then((data) => IsWhitelistAdminResponse.decode(new BinaryReader(data)));
  }

  GetTopicLastWorkerCommitInfo(
    request: GetTopicLastWorkerCommitInfoRequest,
  ): Promise<GetTopicLastWorkerCommitInfoResponse> {
    const data = GetTopicLastWorkerCommitInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTopicLastWorkerCommitInfo", data);
    return promise.then((data) => GetTopicLastWorkerCommitInfoResponse.decode(new BinaryReader(data)));
  }

  GetTopicLastReputerCommitInfo(
    request: GetTopicLastReputerCommitInfoRequest,
  ): Promise<GetTopicLastReputerCommitInfoResponse> {
    const data = GetTopicLastReputerCommitInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTopicLastReputerCommitInfo", data);
    return promise.then((data) => GetTopicLastReputerCommitInfoResponse.decode(new BinaryReader(data)));
  }

  GetTopicRewardNonce(request: GetTopicRewardNonceRequest): Promise<GetTopicRewardNonceResponse> {
    const data = GetTopicRewardNonceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTopicRewardNonce", data);
    return promise.then((data) => GetTopicRewardNonceResponse.decode(new BinaryReader(data)));
  }

  GetReputerLossBundlesAtBlock(
    request: GetReputerLossBundlesAtBlockRequest,
  ): Promise<GetReputerLossBundlesAtBlockResponse> {
    const data = GetReputerLossBundlesAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReputerLossBundlesAtBlock", data);
    return promise.then((data) => GetReputerLossBundlesAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetStakeReputerAuthority(request: GetStakeReputerAuthorityRequest): Promise<GetStakeReputerAuthorityResponse> {
    const data = GetStakeReputerAuthorityRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStakeReputerAuthority", data);
    return promise.then((data) => GetStakeReputerAuthorityResponse.decode(new BinaryReader(data)));
  }

  GetDelegateStakePlacement(request: GetDelegateStakePlacementRequest): Promise<GetDelegateStakePlacementResponse> {
    const data = GetDelegateStakePlacementRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDelegateStakePlacement", data);
    return promise.then((data) => GetDelegateStakePlacementResponse.decode(new BinaryReader(data)));
  }

  GetDelegateStakeUponReputer(
    request: GetDelegateStakeUponReputerRequest,
  ): Promise<GetDelegateStakeUponReputerResponse> {
    const data = GetDelegateStakeUponReputerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDelegateStakeUponReputer", data);
    return promise.then((data) => GetDelegateStakeUponReputerResponse.decode(new BinaryReader(data)));
  }

  GetDelegateRewardPerShare(request: GetDelegateRewardPerShareRequest): Promise<GetDelegateRewardPerShareResponse> {
    const data = GetDelegateRewardPerShareRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDelegateRewardPerShare", data);
    return promise.then((data) => GetDelegateRewardPerShareResponse.decode(new BinaryReader(data)));
  }

  GetStakeRemovalForReputerAndTopicId(
    request: GetStakeRemovalForReputerAndTopicIdRequest,
  ): Promise<GetStakeRemovalForReputerAndTopicIdResponse> {
    const data = GetStakeRemovalForReputerAndTopicIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStakeRemovalForReputerAndTopicId", data);
    return promise.then((data) => GetStakeRemovalForReputerAndTopicIdResponse.decode(new BinaryReader(data)));
  }

  GetDelegateStakeRemoval(request: GetDelegateStakeRemovalRequest): Promise<GetDelegateStakeRemovalResponse> {
    const data = GetDelegateStakeRemovalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDelegateStakeRemoval", data);
    return promise.then((data) => GetDelegateStakeRemovalResponse.decode(new BinaryReader(data)));
  }

  GetPreviousTopicWeight(request: GetPreviousTopicWeightRequest): Promise<GetPreviousTopicWeightResponse> {
    const data = GetPreviousTopicWeightRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreviousTopicWeight", data);
    return promise.then((data) => GetPreviousTopicWeightResponse.decode(new BinaryReader(data)));
  }

  GetTotalSumPreviousTopicWeights(
    request: GetTotalSumPreviousTopicWeightsRequest,
  ): Promise<GetTotalSumPreviousTopicWeightsResponse> {
    const data = GetTotalSumPreviousTopicWeightsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTotalSumPreviousTopicWeights", data);
    return promise.then((data) => GetTotalSumPreviousTopicWeightsResponse.decode(new BinaryReader(data)));
  }

  TopicExists(request: TopicExistsRequest): Promise<TopicExistsResponse> {
    const data = TopicExistsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TopicExists", data);
    return promise.then((data) => TopicExistsResponse.decode(new BinaryReader(data)));
  }

  IsTopicActive(request: IsTopicActiveRequest): Promise<IsTopicActiveResponse> {
    const data = IsTopicActiveRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IsTopicActive", data);
    return promise.then((data) => IsTopicActiveResponse.decode(new BinaryReader(data)));
  }

  GetTopicFeeRevenue(request: GetTopicFeeRevenueRequest): Promise<GetTopicFeeRevenueResponse> {
    const data = GetTopicFeeRevenueRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTopicFeeRevenue", data);
    return promise.then((data) => GetTopicFeeRevenueResponse.decode(new BinaryReader(data)));
  }

  GetInfererScoreEma(request: GetInfererScoreEmaRequest): Promise<GetInfererScoreEmaResponse> {
    const data = GetInfererScoreEmaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetInfererScoreEma", data);
    return promise.then((data) => GetInfererScoreEmaResponse.decode(new BinaryReader(data)));
  }

  GetForecasterScoreEma(request: GetForecasterScoreEmaRequest): Promise<GetForecasterScoreEmaResponse> {
    const data = GetForecasterScoreEmaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetForecasterScoreEma", data);
    return promise.then((data) => GetForecasterScoreEmaResponse.decode(new BinaryReader(data)));
  }

  GetReputerScoreEma(request: GetReputerScoreEmaRequest): Promise<GetReputerScoreEmaResponse> {
    const data = GetReputerScoreEmaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReputerScoreEma", data);
    return promise.then((data) => GetReputerScoreEmaResponse.decode(new BinaryReader(data)));
  }

  GetInferenceScoresUntilBlock(
    request: GetInferenceScoresUntilBlockRequest,
  ): Promise<GetInferenceScoresUntilBlockResponse> {
    const data = GetInferenceScoresUntilBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetInferenceScoresUntilBlock", data);
    return promise.then((data) => GetInferenceScoresUntilBlockResponse.decode(new BinaryReader(data)));
  }

  GetPreviousTopicQuantileForecasterScoreEma(
    request: GetPreviousTopicQuantileForecasterScoreEmaRequest,
  ): Promise<GetPreviousTopicQuantileForecasterScoreEmaResponse> {
    const data = GetPreviousTopicQuantileForecasterScoreEmaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreviousTopicQuantileForecasterScoreEma", data);
    return promise.then((data) => GetPreviousTopicQuantileForecasterScoreEmaResponse.decode(new BinaryReader(data)));
  }

  GetPreviousTopicQuantileInfererScoreEma(
    request: GetPreviousTopicQuantileInfererScoreEmaRequest,
  ): Promise<GetPreviousTopicQuantileInfererScoreEmaResponse> {
    const data = GetPreviousTopicQuantileInfererScoreEmaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreviousTopicQuantileInfererScoreEma", data);
    return promise.then((data) => GetPreviousTopicQuantileInfererScoreEmaResponse.decode(new BinaryReader(data)));
  }

  GetPreviousTopicQuantileReputerScoreEma(
    request: GetPreviousTopicQuantileReputerScoreEmaRequest,
  ): Promise<GetPreviousTopicQuantileReputerScoreEmaResponse> {
    const data = GetPreviousTopicQuantileReputerScoreEmaRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreviousTopicQuantileReputerScoreEma", data);
    return promise.then((data) => GetPreviousTopicQuantileReputerScoreEmaResponse.decode(new BinaryReader(data)));
  }

  GetWorkerInferenceScoresAtBlock(
    request: GetWorkerInferenceScoresAtBlockRequest,
  ): Promise<GetWorkerInferenceScoresAtBlockResponse> {
    const data = GetWorkerInferenceScoresAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWorkerInferenceScoresAtBlock", data);
    return promise.then((data) => GetWorkerInferenceScoresAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetCurrentLowestInfererScore(
    request: GetCurrentLowestInfererScoreRequest,
  ): Promise<GetCurrentLowestInfererScoreResponse> {
    const data = GetCurrentLowestInfererScoreRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCurrentLowestInfererScore", data);
    return promise.then((data) => GetCurrentLowestInfererScoreResponse.decode(new BinaryReader(data)));
  }

  GetForecastScoresUntilBlock(
    request: GetForecastScoresUntilBlockRequest,
  ): Promise<GetForecastScoresUntilBlockResponse> {
    const data = GetForecastScoresUntilBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetForecastScoresUntilBlock", data);
    return promise.then((data) => GetForecastScoresUntilBlockResponse.decode(new BinaryReader(data)));
  }

  GetWorkerForecastScoresAtBlock(
    request: GetWorkerForecastScoresAtBlockRequest,
  ): Promise<GetWorkerForecastScoresAtBlockResponse> {
    const data = GetWorkerForecastScoresAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWorkerForecastScoresAtBlock", data);
    return promise.then((data) => GetWorkerForecastScoresAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetCurrentLowestForecasterScore(
    request: GetCurrentLowestForecasterScoreRequest,
  ): Promise<GetCurrentLowestForecasterScoreResponse> {
    const data = GetCurrentLowestForecasterScoreRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCurrentLowestForecasterScore", data);
    return promise.then((data) => GetCurrentLowestForecasterScoreResponse.decode(new BinaryReader(data)));
  }

  GetReputersScoresAtBlock(request: GetReputersScoresAtBlockRequest): Promise<GetReputersScoresAtBlockResponse> {
    const data = GetReputersScoresAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReputersScoresAtBlock", data);
    return promise.then((data) => GetReputersScoresAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetCurrentLowestReputerScore(
    request: GetCurrentLowestReputerScoreRequest,
  ): Promise<GetCurrentLowestReputerScoreResponse> {
    const data = GetCurrentLowestReputerScoreRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCurrentLowestReputerScore", data);
    return promise.then((data) => GetCurrentLowestReputerScoreResponse.decode(new BinaryReader(data)));
  }

  GetListeningCoefficient(request: GetListeningCoefficientRequest): Promise<GetListeningCoefficientResponse> {
    const data = GetListeningCoefficientRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetListeningCoefficient", data);
    return promise.then((data) => GetListeningCoefficientResponse.decode(new BinaryReader(data)));
  }

  GetPreviousReputerRewardFraction(
    request: GetPreviousReputerRewardFractionRequest,
  ): Promise<GetPreviousReputerRewardFractionResponse> {
    const data = GetPreviousReputerRewardFractionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreviousReputerRewardFraction", data);
    return promise.then((data) => GetPreviousReputerRewardFractionResponse.decode(new BinaryReader(data)));
  }

  GetPreviousInferenceRewardFraction(
    request: GetPreviousInferenceRewardFractionRequest,
  ): Promise<GetPreviousInferenceRewardFractionResponse> {
    const data = GetPreviousInferenceRewardFractionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreviousInferenceRewardFraction", data);
    return promise.then((data) => GetPreviousInferenceRewardFractionResponse.decode(new BinaryReader(data)));
  }

  GetPreviousForecastRewardFraction(
    request: GetPreviousForecastRewardFractionRequest,
  ): Promise<GetPreviousForecastRewardFractionResponse> {
    const data = GetPreviousForecastRewardFractionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreviousForecastRewardFraction", data);
    return promise.then((data) => GetPreviousForecastRewardFractionResponse.decode(new BinaryReader(data)));
  }

  GetPreviousPercentageRewardToStakedReputers(
    request: GetPreviousPercentageRewardToStakedReputersRequest,
  ): Promise<GetPreviousPercentageRewardToStakedReputersResponse> {
    const data = GetPreviousPercentageRewardToStakedReputersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPreviousPercentageRewardToStakedReputers", data);
    return promise.then((data) => GetPreviousPercentageRewardToStakedReputersResponse.decode(new BinaryReader(data)));
  }

  GetTotalRewardToDistribute(request: GetTotalRewardToDistributeRequest): Promise<GetTotalRewardToDistributeResponse> {
    const data = GetTotalRewardToDistributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTotalRewardToDistribute", data);
    return promise.then((data) => GetTotalRewardToDistributeResponse.decode(new BinaryReader(data)));
  }

  GetNaiveInfererNetworkRegret(
    request: GetNaiveInfererNetworkRegretRequest,
  ): Promise<GetNaiveInfererNetworkRegretResponse> {
    const data = GetNaiveInfererNetworkRegretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNaiveInfererNetworkRegret", data);
    return promise.then((data) => GetNaiveInfererNetworkRegretResponse.decode(new BinaryReader(data)));
  }

  GetOneOutInfererInfererNetworkRegret(
    request: GetOneOutInfererInfererNetworkRegretRequest,
  ): Promise<GetOneOutInfererInfererNetworkRegretResponse> {
    const data = GetOneOutInfererInfererNetworkRegretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOneOutInfererInfererNetworkRegret", data);
    return promise.then((data) => GetOneOutInfererInfererNetworkRegretResponse.decode(new BinaryReader(data)));
  }

  GetOneOutInfererForecasterNetworkRegret(
    request: GetOneOutInfererForecasterNetworkRegretRequest,
  ): Promise<GetOneOutInfererForecasterNetworkRegretResponse> {
    const data = GetOneOutInfererForecasterNetworkRegretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOneOutInfererForecasterNetworkRegret", data);
    return promise.then((data) => GetOneOutInfererForecasterNetworkRegretResponse.decode(new BinaryReader(data)));
  }

  GetOneOutForecasterInfererNetworkRegret(
    request: GetOneOutForecasterInfererNetworkRegretRequest,
  ): Promise<GetOneOutForecasterInfererNetworkRegretResponse> {
    const data = GetOneOutForecasterInfererNetworkRegretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOneOutForecasterInfererNetworkRegret", data);
    return promise.then((data) => GetOneOutForecasterInfererNetworkRegretResponse.decode(new BinaryReader(data)));
  }

  GetOneOutForecasterForecasterNetworkRegret(
    request: GetOneOutForecasterForecasterNetworkRegretRequest,
  ): Promise<GetOneOutForecasterForecasterNetworkRegretResponse> {
    const data = GetOneOutForecasterForecasterNetworkRegretRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOneOutForecasterForecasterNetworkRegret", data);
    return promise.then((data) => GetOneOutForecasterForecasterNetworkRegretResponse.decode(new BinaryReader(data)));
  }

  GetActiveTopicsAtBlock(request: GetActiveTopicsAtBlockRequest): Promise<GetActiveTopicsAtBlockResponse> {
    const data = GetActiveTopicsAtBlockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetActiveTopicsAtBlock", data);
    return promise.then((data) => GetActiveTopicsAtBlockResponse.decode(new BinaryReader(data)));
  }

  GetNextChurningBlockByTopicId(
    request: GetNextChurningBlockByTopicIdRequest,
  ): Promise<GetNextChurningBlockByTopicIdResponse> {
    const data = GetNextChurningBlockByTopicIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNextChurningBlockByTopicId", data);
    return promise.then((data) => GetNextChurningBlockByTopicIdResponse.decode(new BinaryReader(data)));
  }

  GetCountInfererInclusionsInTopic(
    request: GetCountInfererInclusionsInTopicRequest,
  ): Promise<GetCountInfererInclusionsInTopicResponse> {
    const data = GetCountInfererInclusionsInTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCountInfererInclusionsInTopic", data);
    return promise.then((data) => GetCountInfererInclusionsInTopicResponse.decode(new BinaryReader(data)));
  }

  GetCountForecasterInclusionsInTopic(
    request: GetCountForecasterInclusionsInTopicRequest,
  ): Promise<GetCountForecasterInclusionsInTopicResponse> {
    const data = GetCountForecasterInclusionsInTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCountForecasterInclusionsInTopic", data);
    return promise.then((data) => GetCountForecasterInclusionsInTopicResponse.decode(new BinaryReader(data)));
  }

  GetActiveReputersForTopic(request: GetActiveReputersForTopicRequest): Promise<GetActiveReputersForTopicResponse> {
    const data = GetActiveReputersForTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetActiveReputersForTopic", data);
    return promise.then((data) => GetActiveReputersForTopicResponse.decode(new BinaryReader(data)));
  }

  GetActiveForecastersForTopic(
    request: GetActiveForecastersForTopicRequest,
  ): Promise<GetActiveForecastersForTopicResponse> {
    const data = GetActiveForecastersForTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetActiveForecastersForTopic", data);
    return promise.then((data) => GetActiveForecastersForTopicResponse.decode(new BinaryReader(data)));
  }

  GetActiveInferersForTopic(request: GetActiveInferersForTopicRequest): Promise<GetActiveInferersForTopicResponse> {
    const data = GetActiveInferersForTopicRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetActiveInferersForTopic", data);
    return promise.then((data) => GetActiveInferersForTopicResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
