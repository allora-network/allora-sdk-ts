// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: mint/v4/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Params } from "../v1beta1/types";

export const protobufPackage = "mint.v4";

/** QueryServiceParamsRequest is the request type for the Query/Params RPC method. */
export interface QueryServiceParamsRequest {
}

/** QueryServiceParamsResponse is the response type for the Query/Params RPC method. */
export interface QueryServiceParamsResponse {
  /** params defines the parameters of the module. */
  params?: Params | undefined;
}

/** QueryServiceInflationRequest is the request type for the Query/Inflation RPC method. */
export interface QueryServiceInflationRequest {
}

/**
 * QueryServiceInflationResponse is the response type for the Query/Inflation RPC
 * method.
 */
export interface QueryServiceInflationResponse {
  /** inflation is the current minting inflation value. */
  inflation: Uint8Array;
}

/** query for a big dump of mint module info */
export interface QueryServiceEmissionInfoRequest {
}

/** return information about the emissions rate on query */
export interface QueryServiceEmissionInfoResponse {
  params?: Params | undefined;
  ecosystemBalance: string;
  previousBlockEmission: string;
  ecosystemMintSupplyRemaining: string;
  blocksPerMonth: string;
  blockHeightTargetEILastCalculated: string;
  blockHeightTargetEINextCalculated: string;
  networkStakedTokens: string;
  lockedVestingTokensTotal: string;
  lockedVestingTokensInvestorsPreseed: string;
  lockedVestingTokensInvestorsSeed: string;
  lockedVestingTokensTeam: string;
  ecosystemLocked: string;
  circulatingSupply: string;
  maxSupply: string;
  targetEmissionRatePerUnitStakedToken: string;
  reputersPercent: string;
  validatorsPercent: string;
  maximumMonthlyEmissionPerUnitStakedToken: string;
  targetRewardEmissionPerUnitStakedToken: string;
  emissionPerUnitStakedToken: string;
  emissionPerMonth: string;
  blockEmission: string;
  validatorCut: string;
  alloraRewardsCut: string;
  previousRewardEmissionPerUnitStakedToken: string;
  monthsAlreadyUnlocked: string;
  updatedMonthsUnlocked: string;
}

function createBaseQueryServiceParamsRequest(): QueryServiceParamsRequest {
  return {};
}

export const QueryServiceParamsRequest: MessageFns<QueryServiceParamsRequest> = {
  encode(_: QueryServiceParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServiceParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServiceParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryServiceParamsRequest {
    return {};
  },

  toJSON(_: QueryServiceParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryServiceParamsRequest>): QueryServiceParamsRequest {
    return QueryServiceParamsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueryServiceParamsRequest>): QueryServiceParamsRequest {
    const message = createBaseQueryServiceParamsRequest();
    return message;
  },
};

function createBaseQueryServiceParamsResponse(): QueryServiceParamsResponse {
  return { params: undefined };
}

export const QueryServiceParamsResponse: MessageFns<QueryServiceParamsResponse> = {
  encode(message: QueryServiceParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServiceParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServiceParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryServiceParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryServiceParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryServiceParamsResponse>): QueryServiceParamsResponse {
    return QueryServiceParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryServiceParamsResponse>): QueryServiceParamsResponse {
    const message = createBaseQueryServiceParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryServiceInflationRequest(): QueryServiceInflationRequest {
  return {};
}

export const QueryServiceInflationRequest: MessageFns<QueryServiceInflationRequest> = {
  encode(_: QueryServiceInflationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServiceInflationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServiceInflationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryServiceInflationRequest {
    return {};
  },

  toJSON(_: QueryServiceInflationRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryServiceInflationRequest>): QueryServiceInflationRequest {
    return QueryServiceInflationRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueryServiceInflationRequest>): QueryServiceInflationRequest {
    const message = createBaseQueryServiceInflationRequest();
    return message;
  },
};

function createBaseQueryServiceInflationResponse(): QueryServiceInflationResponse {
  return { inflation: new Uint8Array(0) };
}

export const QueryServiceInflationResponse: MessageFns<QueryServiceInflationResponse> = {
  encode(message: QueryServiceInflationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inflation.length !== 0) {
      writer.uint32(10).bytes(message.inflation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServiceInflationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServiceInflationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inflation = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryServiceInflationResponse {
    return { inflation: isSet(object.inflation) ? bytesFromBase64(object.inflation) : new Uint8Array(0) };
  },

  toJSON(message: QueryServiceInflationResponse): unknown {
    const obj: any = {};
    if (message.inflation.length !== 0) {
      obj.inflation = base64FromBytes(message.inflation);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryServiceInflationResponse>): QueryServiceInflationResponse {
    return QueryServiceInflationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryServiceInflationResponse>): QueryServiceInflationResponse {
    const message = createBaseQueryServiceInflationResponse();
    message.inflation = object.inflation ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryServiceEmissionInfoRequest(): QueryServiceEmissionInfoRequest {
  return {};
}

export const QueryServiceEmissionInfoRequest: MessageFns<QueryServiceEmissionInfoRequest> = {
  encode(_: QueryServiceEmissionInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServiceEmissionInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServiceEmissionInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryServiceEmissionInfoRequest {
    return {};
  },

  toJSON(_: QueryServiceEmissionInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueryServiceEmissionInfoRequest>): QueryServiceEmissionInfoRequest {
    return QueryServiceEmissionInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueryServiceEmissionInfoRequest>): QueryServiceEmissionInfoRequest {
    const message = createBaseQueryServiceEmissionInfoRequest();
    return message;
  },
};

function createBaseQueryServiceEmissionInfoResponse(): QueryServiceEmissionInfoResponse {
  return {
    params: undefined,
    ecosystemBalance: "",
    previousBlockEmission: "",
    ecosystemMintSupplyRemaining: "",
    blocksPerMonth: "0",
    blockHeightTargetEILastCalculated: "0",
    blockHeightTargetEINextCalculated: "0",
    networkStakedTokens: "",
    lockedVestingTokensTotal: "",
    lockedVestingTokensInvestorsPreseed: "",
    lockedVestingTokensInvestorsSeed: "",
    lockedVestingTokensTeam: "",
    ecosystemLocked: "",
    circulatingSupply: "",
    maxSupply: "",
    targetEmissionRatePerUnitStakedToken: "",
    reputersPercent: "",
    validatorsPercent: "",
    maximumMonthlyEmissionPerUnitStakedToken: "",
    targetRewardEmissionPerUnitStakedToken: "",
    emissionPerUnitStakedToken: "",
    emissionPerMonth: "",
    blockEmission: "",
    validatorCut: "",
    alloraRewardsCut: "",
    previousRewardEmissionPerUnitStakedToken: "",
    monthsAlreadyUnlocked: "",
    updatedMonthsUnlocked: "",
  };
}

export const QueryServiceEmissionInfoResponse: MessageFns<QueryServiceEmissionInfoResponse> = {
  encode(message: QueryServiceEmissionInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.ecosystemBalance !== "") {
      writer.uint32(18).string(message.ecosystemBalance);
    }
    if (message.previousBlockEmission !== "") {
      writer.uint32(26).string(message.previousBlockEmission);
    }
    if (message.ecosystemMintSupplyRemaining !== "") {
      writer.uint32(34).string(message.ecosystemMintSupplyRemaining);
    }
    if (message.blocksPerMonth !== "0") {
      writer.uint32(40).uint64(message.blocksPerMonth);
    }
    if (message.blockHeightTargetEILastCalculated !== "0") {
      writer.uint32(48).uint64(message.blockHeightTargetEILastCalculated);
    }
    if (message.blockHeightTargetEINextCalculated !== "0") {
      writer.uint32(56).uint64(message.blockHeightTargetEINextCalculated);
    }
    if (message.networkStakedTokens !== "") {
      writer.uint32(66).string(message.networkStakedTokens);
    }
    if (message.lockedVestingTokensTotal !== "") {
      writer.uint32(74).string(message.lockedVestingTokensTotal);
    }
    if (message.lockedVestingTokensInvestorsPreseed !== "") {
      writer.uint32(82).string(message.lockedVestingTokensInvestorsPreseed);
    }
    if (message.lockedVestingTokensInvestorsSeed !== "") {
      writer.uint32(90).string(message.lockedVestingTokensInvestorsSeed);
    }
    if (message.lockedVestingTokensTeam !== "") {
      writer.uint32(98).string(message.lockedVestingTokensTeam);
    }
    if (message.ecosystemLocked !== "") {
      writer.uint32(106).string(message.ecosystemLocked);
    }
    if (message.circulatingSupply !== "") {
      writer.uint32(114).string(message.circulatingSupply);
    }
    if (message.maxSupply !== "") {
      writer.uint32(122).string(message.maxSupply);
    }
    if (message.targetEmissionRatePerUnitStakedToken !== "") {
      writer.uint32(130).string(message.targetEmissionRatePerUnitStakedToken);
    }
    if (message.reputersPercent !== "") {
      writer.uint32(138).string(message.reputersPercent);
    }
    if (message.validatorsPercent !== "") {
      writer.uint32(146).string(message.validatorsPercent);
    }
    if (message.maximumMonthlyEmissionPerUnitStakedToken !== "") {
      writer.uint32(154).string(message.maximumMonthlyEmissionPerUnitStakedToken);
    }
    if (message.targetRewardEmissionPerUnitStakedToken !== "") {
      writer.uint32(162).string(message.targetRewardEmissionPerUnitStakedToken);
    }
    if (message.emissionPerUnitStakedToken !== "") {
      writer.uint32(170).string(message.emissionPerUnitStakedToken);
    }
    if (message.emissionPerMonth !== "") {
      writer.uint32(178).string(message.emissionPerMonth);
    }
    if (message.blockEmission !== "") {
      writer.uint32(186).string(message.blockEmission);
    }
    if (message.validatorCut !== "") {
      writer.uint32(194).string(message.validatorCut);
    }
    if (message.alloraRewardsCut !== "") {
      writer.uint32(202).string(message.alloraRewardsCut);
    }
    if (message.previousRewardEmissionPerUnitStakedToken !== "") {
      writer.uint32(210).string(message.previousRewardEmissionPerUnitStakedToken);
    }
    if (message.monthsAlreadyUnlocked !== "") {
      writer.uint32(218).string(message.monthsAlreadyUnlocked);
    }
    if (message.updatedMonthsUnlocked !== "") {
      writer.uint32(226).string(message.updatedMonthsUnlocked);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServiceEmissionInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServiceEmissionInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ecosystemBalance = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.previousBlockEmission = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ecosystemMintSupplyRemaining = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.blocksPerMonth = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.blockHeightTargetEILastCalculated = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.blockHeightTargetEINextCalculated = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.networkStakedTokens = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lockedVestingTokensTotal = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lockedVestingTokensInvestorsPreseed = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lockedVestingTokensInvestorsSeed = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.lockedVestingTokensTeam = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.ecosystemLocked = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.circulatingSupply = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.maxSupply = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.targetEmissionRatePerUnitStakedToken = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.reputersPercent = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.validatorsPercent = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.maximumMonthlyEmissionPerUnitStakedToken = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.targetRewardEmissionPerUnitStakedToken = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.emissionPerUnitStakedToken = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.emissionPerMonth = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.blockEmission = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.validatorCut = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.alloraRewardsCut = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.previousRewardEmissionPerUnitStakedToken = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.monthsAlreadyUnlocked = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.updatedMonthsUnlocked = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryServiceEmissionInfoResponse {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
      ecosystemBalance: isSet(object.ecosystemBalance) ? globalThis.String(object.ecosystemBalance) : "",
      previousBlockEmission: isSet(object.previousBlockEmission) ? globalThis.String(object.previousBlockEmission) : "",
      ecosystemMintSupplyRemaining: isSet(object.ecosystemMintSupplyRemaining)
        ? globalThis.String(object.ecosystemMintSupplyRemaining)
        : "",
      blocksPerMonth: isSet(object.blocksPerMonth) ? globalThis.String(object.blocksPerMonth) : "0",
      blockHeightTargetEILastCalculated: isSet(object.blockHeightTargetEILastCalculated)
        ? globalThis.String(object.blockHeightTargetEILastCalculated)
        : "0",
      blockHeightTargetEINextCalculated: isSet(object.blockHeightTargetEINextCalculated)
        ? globalThis.String(object.blockHeightTargetEINextCalculated)
        : "0",
      networkStakedTokens: isSet(object.networkStakedTokens) ? globalThis.String(object.networkStakedTokens) : "",
      lockedVestingTokensTotal: isSet(object.lockedVestingTokensTotal)
        ? globalThis.String(object.lockedVestingTokensTotal)
        : "",
      lockedVestingTokensInvestorsPreseed: isSet(object.lockedVestingTokensInvestorsPreseed)
        ? globalThis.String(object.lockedVestingTokensInvestorsPreseed)
        : "",
      lockedVestingTokensInvestorsSeed: isSet(object.lockedVestingTokensInvestorsSeed)
        ? globalThis.String(object.lockedVestingTokensInvestorsSeed)
        : "",
      lockedVestingTokensTeam: isSet(object.lockedVestingTokensTeam)
        ? globalThis.String(object.lockedVestingTokensTeam)
        : "",
      ecosystemLocked: isSet(object.ecosystemLocked) ? globalThis.String(object.ecosystemLocked) : "",
      circulatingSupply: isSet(object.circulatingSupply) ? globalThis.String(object.circulatingSupply) : "",
      maxSupply: isSet(object.maxSupply) ? globalThis.String(object.maxSupply) : "",
      targetEmissionRatePerUnitStakedToken: isSet(object.targetEmissionRatePerUnitStakedToken)
        ? globalThis.String(object.targetEmissionRatePerUnitStakedToken)
        : "",
      reputersPercent: isSet(object.reputersPercent) ? globalThis.String(object.reputersPercent) : "",
      validatorsPercent: isSet(object.validatorsPercent) ? globalThis.String(object.validatorsPercent) : "",
      maximumMonthlyEmissionPerUnitStakedToken: isSet(object.maximumMonthlyEmissionPerUnitStakedToken)
        ? globalThis.String(object.maximumMonthlyEmissionPerUnitStakedToken)
        : "",
      targetRewardEmissionPerUnitStakedToken: isSet(object.targetRewardEmissionPerUnitStakedToken)
        ? globalThis.String(object.targetRewardEmissionPerUnitStakedToken)
        : "",
      emissionPerUnitStakedToken: isSet(object.emissionPerUnitStakedToken)
        ? globalThis.String(object.emissionPerUnitStakedToken)
        : "",
      emissionPerMonth: isSet(object.emissionPerMonth) ? globalThis.String(object.emissionPerMonth) : "",
      blockEmission: isSet(object.blockEmission) ? globalThis.String(object.blockEmission) : "",
      validatorCut: isSet(object.validatorCut) ? globalThis.String(object.validatorCut) : "",
      alloraRewardsCut: isSet(object.alloraRewardsCut) ? globalThis.String(object.alloraRewardsCut) : "",
      previousRewardEmissionPerUnitStakedToken: isSet(object.previousRewardEmissionPerUnitStakedToken)
        ? globalThis.String(object.previousRewardEmissionPerUnitStakedToken)
        : "",
      monthsAlreadyUnlocked: isSet(object.monthsAlreadyUnlocked) ? globalThis.String(object.monthsAlreadyUnlocked) : "",
      updatedMonthsUnlocked: isSet(object.updatedMonthsUnlocked) ? globalThis.String(object.updatedMonthsUnlocked) : "",
    };
  },

  toJSON(message: QueryServiceEmissionInfoResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    if (message.ecosystemBalance !== "") {
      obj.ecosystemBalance = message.ecosystemBalance;
    }
    if (message.previousBlockEmission !== "") {
      obj.previousBlockEmission = message.previousBlockEmission;
    }
    if (message.ecosystemMintSupplyRemaining !== "") {
      obj.ecosystemMintSupplyRemaining = message.ecosystemMintSupplyRemaining;
    }
    if (message.blocksPerMonth !== "0") {
      obj.blocksPerMonth = message.blocksPerMonth;
    }
    if (message.blockHeightTargetEILastCalculated !== "0") {
      obj.blockHeightTargetEILastCalculated = message.blockHeightTargetEILastCalculated;
    }
    if (message.blockHeightTargetEINextCalculated !== "0") {
      obj.blockHeightTargetEINextCalculated = message.blockHeightTargetEINextCalculated;
    }
    if (message.networkStakedTokens !== "") {
      obj.networkStakedTokens = message.networkStakedTokens;
    }
    if (message.lockedVestingTokensTotal !== "") {
      obj.lockedVestingTokensTotal = message.lockedVestingTokensTotal;
    }
    if (message.lockedVestingTokensInvestorsPreseed !== "") {
      obj.lockedVestingTokensInvestorsPreseed = message.lockedVestingTokensInvestorsPreseed;
    }
    if (message.lockedVestingTokensInvestorsSeed !== "") {
      obj.lockedVestingTokensInvestorsSeed = message.lockedVestingTokensInvestorsSeed;
    }
    if (message.lockedVestingTokensTeam !== "") {
      obj.lockedVestingTokensTeam = message.lockedVestingTokensTeam;
    }
    if (message.ecosystemLocked !== "") {
      obj.ecosystemLocked = message.ecosystemLocked;
    }
    if (message.circulatingSupply !== "") {
      obj.circulatingSupply = message.circulatingSupply;
    }
    if (message.maxSupply !== "") {
      obj.maxSupply = message.maxSupply;
    }
    if (message.targetEmissionRatePerUnitStakedToken !== "") {
      obj.targetEmissionRatePerUnitStakedToken = message.targetEmissionRatePerUnitStakedToken;
    }
    if (message.reputersPercent !== "") {
      obj.reputersPercent = message.reputersPercent;
    }
    if (message.validatorsPercent !== "") {
      obj.validatorsPercent = message.validatorsPercent;
    }
    if (message.maximumMonthlyEmissionPerUnitStakedToken !== "") {
      obj.maximumMonthlyEmissionPerUnitStakedToken = message.maximumMonthlyEmissionPerUnitStakedToken;
    }
    if (message.targetRewardEmissionPerUnitStakedToken !== "") {
      obj.targetRewardEmissionPerUnitStakedToken = message.targetRewardEmissionPerUnitStakedToken;
    }
    if (message.emissionPerUnitStakedToken !== "") {
      obj.emissionPerUnitStakedToken = message.emissionPerUnitStakedToken;
    }
    if (message.emissionPerMonth !== "") {
      obj.emissionPerMonth = message.emissionPerMonth;
    }
    if (message.blockEmission !== "") {
      obj.blockEmission = message.blockEmission;
    }
    if (message.validatorCut !== "") {
      obj.validatorCut = message.validatorCut;
    }
    if (message.alloraRewardsCut !== "") {
      obj.alloraRewardsCut = message.alloraRewardsCut;
    }
    if (message.previousRewardEmissionPerUnitStakedToken !== "") {
      obj.previousRewardEmissionPerUnitStakedToken = message.previousRewardEmissionPerUnitStakedToken;
    }
    if (message.monthsAlreadyUnlocked !== "") {
      obj.monthsAlreadyUnlocked = message.monthsAlreadyUnlocked;
    }
    if (message.updatedMonthsUnlocked !== "") {
      obj.updatedMonthsUnlocked = message.updatedMonthsUnlocked;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryServiceEmissionInfoResponse>): QueryServiceEmissionInfoResponse {
    return QueryServiceEmissionInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryServiceEmissionInfoResponse>): QueryServiceEmissionInfoResponse {
    const message = createBaseQueryServiceEmissionInfoResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    message.ecosystemBalance = object.ecosystemBalance ?? "";
    message.previousBlockEmission = object.previousBlockEmission ?? "";
    message.ecosystemMintSupplyRemaining = object.ecosystemMintSupplyRemaining ?? "";
    message.blocksPerMonth = object.blocksPerMonth ?? "0";
    message.blockHeightTargetEILastCalculated = object.blockHeightTargetEILastCalculated ?? "0";
    message.blockHeightTargetEINextCalculated = object.blockHeightTargetEINextCalculated ?? "0";
    message.networkStakedTokens = object.networkStakedTokens ?? "";
    message.lockedVestingTokensTotal = object.lockedVestingTokensTotal ?? "";
    message.lockedVestingTokensInvestorsPreseed = object.lockedVestingTokensInvestorsPreseed ?? "";
    message.lockedVestingTokensInvestorsSeed = object.lockedVestingTokensInvestorsSeed ?? "";
    message.lockedVestingTokensTeam = object.lockedVestingTokensTeam ?? "";
    message.ecosystemLocked = object.ecosystemLocked ?? "";
    message.circulatingSupply = object.circulatingSupply ?? "";
    message.maxSupply = object.maxSupply ?? "";
    message.targetEmissionRatePerUnitStakedToken = object.targetEmissionRatePerUnitStakedToken ?? "";
    message.reputersPercent = object.reputersPercent ?? "";
    message.validatorsPercent = object.validatorsPercent ?? "";
    message.maximumMonthlyEmissionPerUnitStakedToken = object.maximumMonthlyEmissionPerUnitStakedToken ?? "";
    message.targetRewardEmissionPerUnitStakedToken = object.targetRewardEmissionPerUnitStakedToken ?? "";
    message.emissionPerUnitStakedToken = object.emissionPerUnitStakedToken ?? "";
    message.emissionPerMonth = object.emissionPerMonth ?? "";
    message.blockEmission = object.blockEmission ?? "";
    message.validatorCut = object.validatorCut ?? "";
    message.alloraRewardsCut = object.alloraRewardsCut ?? "";
    message.previousRewardEmissionPerUnitStakedToken = object.previousRewardEmissionPerUnitStakedToken ?? "";
    message.monthsAlreadyUnlocked = object.monthsAlreadyUnlocked ?? "";
    message.updatedMonthsUnlocked = object.updatedMonthsUnlocked ?? "";
    return message;
  },
};

/** QueryService provides defines the gRPC querier service. */
export interface QueryService {
  /** Params returns the total set of minting parameters. */
  Params(request: QueryServiceParamsRequest): Promise<QueryServiceParamsResponse>;
  /** Inflation returns the current minting inflation value. */
  Inflation(request: QueryServiceInflationRequest): Promise<QueryServiceInflationResponse>;
  EmissionInfo(request: QueryServiceEmissionInfoRequest): Promise<QueryServiceEmissionInfoResponse>;
}

export const QueryServiceServiceName = "mint.v4.QueryService";
export class QueryServiceClientImpl implements QueryService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.Inflation = this.Inflation.bind(this);
    this.EmissionInfo = this.EmissionInfo.bind(this);
  }
  Params(request: QueryServiceParamsRequest): Promise<QueryServiceParamsResponse> {
    const data = QueryServiceParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryServiceParamsResponse.decode(new BinaryReader(data)));
  }

  Inflation(request: QueryServiceInflationRequest): Promise<QueryServiceInflationResponse> {
    const data = QueryServiceInflationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Inflation", data);
    return promise.then((data) => QueryServiceInflationResponse.decode(new BinaryReader(data)));
  }

  EmissionInfo(request: QueryServiceEmissionInfoRequest): Promise<QueryServiceEmissionInfoResponse> {
    const data = QueryServiceEmissionInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EmissionInfo", data);
    return promise.then((data) => QueryServiceEmissionInfoResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
