// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: mint/v3/events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "mint.v3";

export interface EventTokenomicsSet {
  stakedTokenAmount: string;
  circulatingSupply: string;
  emissionsAmount: string;
}

export interface EventEcosystemTokenMintSet {
  blockHeight: string;
  tokenAmount: string;
}

export interface EventRewardCurrentBlockEmission {
  blockHeight: string;
  tokenAmount: string;
}

function createBaseEventTokenomicsSet(): EventTokenomicsSet {
  return { stakedTokenAmount: "", circulatingSupply: "", emissionsAmount: "" };
}

export const EventTokenomicsSet: MessageFns<EventTokenomicsSet> = {
  encode(message: EventTokenomicsSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stakedTokenAmount !== "") {
      writer.uint32(10).string(message.stakedTokenAmount);
    }
    if (message.circulatingSupply !== "") {
      writer.uint32(18).string(message.circulatingSupply);
    }
    if (message.emissionsAmount !== "") {
      writer.uint32(26).string(message.emissionsAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventTokenomicsSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventTokenomicsSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stakedTokenAmount = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.circulatingSupply = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.emissionsAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventTokenomicsSet {
    return {
      stakedTokenAmount: isSet(object.stakedTokenAmount) ? globalThis.String(object.stakedTokenAmount) : "",
      circulatingSupply: isSet(object.circulatingSupply) ? globalThis.String(object.circulatingSupply) : "",
      emissionsAmount: isSet(object.emissionsAmount) ? globalThis.String(object.emissionsAmount) : "",
    };
  },

  toJSON(message: EventTokenomicsSet): unknown {
    const obj: any = {};
    if (message.stakedTokenAmount !== "") {
      obj.stakedTokenAmount = message.stakedTokenAmount;
    }
    if (message.circulatingSupply !== "") {
      obj.circulatingSupply = message.circulatingSupply;
    }
    if (message.emissionsAmount !== "") {
      obj.emissionsAmount = message.emissionsAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<EventTokenomicsSet>): EventTokenomicsSet {
    return EventTokenomicsSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventTokenomicsSet>): EventTokenomicsSet {
    const message = createBaseEventTokenomicsSet();
    message.stakedTokenAmount = object.stakedTokenAmount ?? "";
    message.circulatingSupply = object.circulatingSupply ?? "";
    message.emissionsAmount = object.emissionsAmount ?? "";
    return message;
  },
};

function createBaseEventEcosystemTokenMintSet(): EventEcosystemTokenMintSet {
  return { blockHeight: "0", tokenAmount: "" };
}

export const EventEcosystemTokenMintSet: MessageFns<EventEcosystemTokenMintSet> = {
  encode(message: EventEcosystemTokenMintSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHeight !== "0") {
      writer.uint32(8).uint64(message.blockHeight);
    }
    if (message.tokenAmount !== "") {
      writer.uint32(18).string(message.tokenAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEcosystemTokenMintSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEcosystemTokenMintSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEcosystemTokenMintSet {
    return {
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
      tokenAmount: isSet(object.tokenAmount) ? globalThis.String(object.tokenAmount) : "",
    };
  },

  toJSON(message: EventEcosystemTokenMintSet): unknown {
    const obj: any = {};
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    if (message.tokenAmount !== "") {
      obj.tokenAmount = message.tokenAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<EventEcosystemTokenMintSet>): EventEcosystemTokenMintSet {
    return EventEcosystemTokenMintSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventEcosystemTokenMintSet>): EventEcosystemTokenMintSet {
    const message = createBaseEventEcosystemTokenMintSet();
    message.blockHeight = object.blockHeight ?? "0";
    message.tokenAmount = object.tokenAmount ?? "";
    return message;
  },
};

function createBaseEventRewardCurrentBlockEmission(): EventRewardCurrentBlockEmission {
  return { blockHeight: "0", tokenAmount: "" };
}

export const EventRewardCurrentBlockEmission: MessageFns<EventRewardCurrentBlockEmission> = {
  encode(message: EventRewardCurrentBlockEmission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockHeight !== "0") {
      writer.uint32(8).uint64(message.blockHeight);
    }
    if (message.tokenAmount !== "") {
      writer.uint32(18).string(message.tokenAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventRewardCurrentBlockEmission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRewardCurrentBlockEmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blockHeight = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventRewardCurrentBlockEmission {
    return {
      blockHeight: isSet(object.blockHeight) ? globalThis.String(object.blockHeight) : "0",
      tokenAmount: isSet(object.tokenAmount) ? globalThis.String(object.tokenAmount) : "",
    };
  },

  toJSON(message: EventRewardCurrentBlockEmission): unknown {
    const obj: any = {};
    if (message.blockHeight !== "0") {
      obj.blockHeight = message.blockHeight;
    }
    if (message.tokenAmount !== "") {
      obj.tokenAmount = message.tokenAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<EventRewardCurrentBlockEmission>): EventRewardCurrentBlockEmission {
    return EventRewardCurrentBlockEmission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventRewardCurrentBlockEmission>): EventRewardCurrentBlockEmission {
    const message = createBaseEventRewardCurrentBlockEmission();
    message.blockHeight = object.blockHeight ?? "0";
    message.tokenAmount = object.tokenAmount ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
